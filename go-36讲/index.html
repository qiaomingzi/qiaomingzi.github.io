<!doctype html><html lang=en><head><meta charset=utf-8><meta name=referrer content="no-referrer"><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><title>GO 36讲 | mingzi.li blog</title><meta property="og:type" content="website"><meta property="og:title" content="GO 36讲"><meta property="og:url" content="http://qiaomingzi.github.io/go-36%E8%AE%B2/"><meta property="og:locale" content="en_GB"><meta property="og:image" content="http://qiaomingzi.github.io/images/og-image.png"><link rel=canonical href=http://qiaomingzi.github.io/go-36%E8%AE%B2/><meta name=twitter:card content="summary"><meta name=twitter:site content="@p4lm"><link rel=stylesheet type=text/css href=/styles/main-bundle.108386b285ad502399f3a8ab890a333c177e59d922733a408892e466a7a87f70d143ace3585f247b62a75a780bd7bcff68b60fc6760b5ae1414e52c78fe708e7.css integrity media="screen, tv, projection"><link rel=stylesheet type=text/css href=/styles/print-bundle.f3d1ea3e2e864e24f7a26ff871aef6875b8e6246aad31fa6e63fdc9c91c629f6b4cdd7dca9beb3949f8b61a0db4c6fe8ec1bfc44ccf3a2cd9a91ea8e9eb20d44.css integrity media=print><link rel=preload as=font href=/fonts/muli1.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/muli2.woff2 type=font/woff2 crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#04396c><meta name=theme-color content="#ffffff"><meta name=generator content="Hugo 0.83.1"><svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><symbol id="icon-arrow-right" viewBox="0 0 32 32"><path d="M19.414 27.414l10-10c.781-.781.781-2.047.0-2.828l-10-10c-.781-.781-2.047-.781-2.828.0s-.781 2.047.0 2.828L23.172 14H4c-1.105.0-2 .895-2 2s.895 2 2 2h19.172l-6.586 6.586c-.39.39-.586.902-.586 1.414s.195 1.024.586 1.414c.781.781 2.047.781 2.828.0z"/></symbol><symbol id="icon-arrow-left" viewBox="0 0 32 32"><path d="M12.586 27.414l-10-10c-.781-.781-.781-2.047.0-2.828l10-10c.781-.781 2.047-.781 2.828.0s.781 2.047.0 2.828L8.828 14H28c1.105.0 2 .895 2 2s-.895 2-2 2H8.828l6.586 6.586c.39.39.586.902.586 1.414s-.195 1.024-.586 1.414c-.781.781-2.047.781-2.828.0z"/></symbol><symbol id="icon-calendar" viewBox="0 0 32 32"><path d="M27.2 4.8h-1.6V8h-4.8V4.8h-9.6V8H6.4V4.8H4.8C3.038 4.8 1.6 6.24 1.6 8v19.2c0 1.76 1.438 3.2 3.2 3.2h22.4c1.76.0 3.2-1.44 3.2-3.2V8c0-1.76-1.44-3.2-3.2-3.2zm0 22.4H4.8V14.4h22.4v12.8zM10.4 1.6H7.2v5.6h3.2V1.6zm14.4.0h-3.2v5.6h3.2V1.6z"/></symbol><symbol id="icon-expand" viewBox="0 0 32 32"><path d="M11.179 17.579l-4.69 4.85-3.29-3.886v10.258h10.219l-3.888-3.33 4.848-4.691-3.2-3.2zM18.581 3.2l3.888 3.33-4.848 4.691 3.2 3.2 4.69-4.85 3.29 3.886V3.199H18.582z"/></symbol><symbol id="icon-collapse" viewBox="0 0 32 32"><path d="M6.56 22.56 1.6 27.2l3.2 3.2 4.64-4.96 3.36 3.36v-9.6H3.2l3.36 3.36zM30.4 4.8l-3.2-3.2-4.64 4.96L19.2 3.2v9.6h9.6l-3.36-3.36L30.4 4.8z"/></symbol><symbol id="icon-bubble" viewBox="0 0 32 32"><path d="M16 2c8.837.0 16 5.82 16 13s-7.163 13-16 13c-.849.0-1.682-.054-2.495-.158C10.068 31.279 5.966 31.895 2 31.986v-.841C4.142 30.096 6 28.184 6 26c0-.305-.024-.604-.068-.897-3.619-2.383-5.932-6.024-5.932-10.103.0-7.18 7.163-13 16-13z"/></symbol><symbol id="icon-folder" viewBox="0 0 32 32"><path d="M29.448 7.678C29.27 6.974 28.4 6.4 27.512 6.4H16.61c-.886.0-2.128-.509-2.755-1.131l-.954-.941c-.627-.622-1.867-1.128-2.754-1.128H4.939c-.888.0-1.694.715-1.792 1.59L2.68 9.6h27.09l-.322-1.922zM31.059 11.2h-30.118c-.547.0-.976.47-.923 1.016l1.477 15.47c.059.63.59 1.114 1.226 1.114h26.56c.635.0 1.165-.483 1.226-1.114l1.477-15.47c.053-.546-.376-1.016-.923-1.016z"/></symbol><symbol id="icon-tag" viewBox="0 0 32 32"><path d="M31.021.648c-.178-.502-.726-.768-1.23-.594s-.77.728-.595 1.232c1.486 4.272-1.464 7.462-3.714 9.171l-.909-1.302c-.306-.437-.989-.8-1.52-.806l-5.101.022c-.531-.01-1.32.234-1.755.541l-15.03 10.539c-.728.512-.904 1.515-.395 2.246l6.83 9.773c.512.728 1.33.64 2.059.131l15.03-10.541c.432-.306.931-.965 1.107-1.469l1.597-5.032c.176-.502.069-1.269-.237-1.706l-.554-.794c3.021-2.315 6.157-6.406 4.416-11.413zM24.027 15.621c-1.163.816-2.77.531-3.584-.634-.818-1.168-.533-2.774.632-3.594.925-.648 2.125-.602 2.989.027-.435.262-.734.416-.79.44-.482.229-.688.806-.461 1.288.166.35.514.557.875.557.138.0.278-.032.411-.094.31-.147.643-.322.99-.528.155.95-.222 1.947-1.062 2.538z"/></symbol><symbol id="icon-circle-with-cross" viewBox="0 0 32 32"><title>Close (Esc)</title><path d="M16 2.56C8.578 2.56 2.56 8.578 2.56 16S8.578 29.44 16 29.44 29.44 23.422 29.44 16 23.422 2.56 16 2.56zm7.662 18.338-2.766 2.766L16 18.766l-4.898 4.896-2.766-2.766L13.235 16l-4.898-4.898 2.766-2.765 4.896 4.896 4.898-4.898 2.766 2.766-4.899 4.898 4.898 4.898z"/></symbol></defs></svg></head><body x-data=window.blog :class="{ 'modal-open': isModalOpen, 'keyboard-navigation' : keyboardNavigation }" @mouseup="keyboardNavigation = false" @keydown.tab="keyboardNavigation = true" @keydown.escape=closeModals()><script>try{const a=window.localStorage.getItem('theme');a==='dark'&&document.querySelector('body').classList.add('dark'),a==='light'&&document.querySelector('body').classList.add('light')}catch(a){}</script><link rel=stylesheet type=text/css href=/styles/post-bundle.min.a3c415b51dea409e064708f705f91702ddddb4aaf1c7522073113ac5c6941f198ce5f39ea63cfaf21674b905146c1bdf3eeb0eaa41d22b9d013117c9bb72d81e.css integrity="sha512-o8QVtR3qQJ4GRwj3BfkXAt3dtKrxx1IgcxE6xcaUHxmM5fOepjz68hZ0uQUUbBvfPusOqkHSK50BMRfJu3LYHg==" media="screen, tv, projection"><div id=page-wrapper><header><svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><symbol id="icon-home" viewBox="0 0 32 32"><path d="M32 18.451 16 6.031.0 18.451v-5.064l16-12.42 16 12.42zM28 18v12h-8v-8h-8v8H4V18l12-9z"/></symbol><symbol id="icon-user" viewBox="0 0 32 32"><path d="M18 22.082v-1.649c2.203-1.241 4-4.337 4-7.432.0-4.971.0-9-6-9s-6 4.029-6 9c0 3.096 1.797 6.191 4 7.432v1.649C7.216 22.637 2 25.97 2 30h28c0-4.03-5.216-7.364-12-7.918z"/></symbol><symbol id="icon-search" viewBox="0 0 32 32"><path d="M31.008 27.231l-7.58-6.447c-.784-.705-1.622-1.029-2.299-.998 1.789-2.096 2.87-4.815 2.87-7.787.0-6.627-5.373-12-12-12s-12 5.373-12 12 5.373 12 12 12c2.972.0 5.691-1.081 7.787-2.87-.031.677.293 1.515.998 2.299l6.447 7.58c1.104 1.226 2.907 1.33 4.007.23s.997-2.903-.23-4.007zM12 20c-4.418.0-8-3.582-8-8s3.582-8 8-8 8 3.582 8 8-3.582 8-8 8z"/></symbol></defs></svg><div class=header-content @click.away=menu.close()><div class=site-title>mingzi.li blog<span style=font-size:.5rem;margin-top:20px>&nbsp;&nbsp;行到水穷处，坐看风云起</span></div><div class=theme-switcher :class="{'has-javascript': true}"><div class=switch><input type=checkbox name=toggle id=theme-switcher-indicator aria-label="Switch theme" @click=theme.toggleChanged($event.target) checked>
<label for=theme-switcher-indicator><i></i></label>
<span></span></div></div><a href=#content id=skip-link class=skip-link @click.prevent=skipLink.skipToContent($refs.content) @click.away=skipLink.removeContentTabIndex($refs.content)>Skip to content</a>
<button @click=menu.toggle() class=hamburger-trigger>Menu<div class=hamburger-menu><div class=bar :class="{'animate': menu.hamburgerIsOpen()}"></div></div></button><nav :class="{'open': menu.isOpen() || menu.isOpening(), 'open closing': menu.isClosing()}"><a href=/ class=home><svg class="icon icon-home"><use xlink:href="#icon-home"/></svg>首页</a>
<a href=/about/ class=about><svg class="icon icon-user"><use xlink:href="#icon-user"/></svg>关于我</a>
<a href=/search-requires-javascript/ rel=nofollow class=search x-ref=searchMenuLink @click.prevent="menu.close(); search.open();$nextTick(() => $refs.searchInput.focus())"><svg class="icon icon-search"><use xlink:href="#icon-search"/></svg>搜索</a></nav></div></header><div class=body><div class=body-max-width><main id=content x-ref=content><article class=full-article><h1>GO 36讲</h1><div class=entry-meta><time class=published datetime="2021-10-16 15:42:33 +0000 UTC"><svg class="icon icon-calendar"><use xlink:href="#icon-calendar"/></svg>2021 October 16</time></div><div style=text-align:center;display:block;color:#999><div>本文仅为个人笔记,作为学习使用,如有雷同请联系作者 mingzi.li 处理,mail: qiaomingzi100@sina.com</div></div><h2 id=一概要>一：概要</h2><h3 id=11参考>1.1.参考</h3><p>【GO编程语言规范】https://golang.google.cn/ref/spec</p><p>【GO命令】https://golang.google.cn/cmd/</p><p>【环境设置】https://www.liwenzhou.com/posts/Go/install_go_dev_old/</p><p>【Unicode】https://home.unicode.org/</p><h2 id=二go语言基础知识>二：Go语言基础知识</h2><p>理解Go语言的开发环境配置、常用源码文件写法，以及程序实体（尤其是变量）及其相关的各种概念和编程技巧（比如类型推断、变量重声明、可重名变量、类型断言、类型转换、别名类型和潜在类型等）。</p><h3 id=1工作区和gopath>1.工作区和GOPATH</h3><p>GOROOT：Go语言安装根目录的路径，也就是GO语言的安装路径。</p><p>GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。</p><p>你可以把GOPATH简单理解成Go语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表Go语言的一个工作区（workspace）</p><pre><code>go mod init qiaomingzi.github.io/m/v1
</code></pre><p><img src=./images/1-1.jpg alt></p><p>GOBIN：GO程序生成的可执行文件（executable file）的路径。</p><h3 id=2源码文件>2.源码文件</h3><p><img src=./images/2-1.png alt></p><h4 id=21-运行程序>2.1 运行程序</h4><p>使用 <strong>go run</strong> 命令执行go源码main文件</p><pre><code>$ go run hello.go 
Hello, World!
</code></pre><p>此外我们还可以使用 <strong>go build</strong> 命令来生成二进制文件：</p><pre><code>$ go build hello.go 
$ ls
hello    hello.go
$ ./hello 
Hello, World!
</code></pre><h4 id=22-程序实体>2.2 程序实体</h4><p>是变量、常量、函数、结构体和接口的统称；程序实体的名字被统称为标识符。标识符可以是任何Unicode编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。</p><p>如：<code>var name string</code></p><h4 id=23-源文件包名>2.3 源文件包名</h4><p><code>package xxx</code></p><ul><li><p>同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。</p></li><li><p>源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。</p></li><li><p>为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致</p></li><li><p>名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。</p></li><li><p>Go 1.5及后续版本中，我们可以通过创建<code>internal</code>代码包让一些程序实体仅仅能被当前模块中的其他代码引用。这被称为Go程序实体的第三种访问权限：模块级私有</p></li></ul><h3 id=3程序实体的那些事儿>3.程序实体的那些事儿</h3><h4 id=31-变量声明>3.1 变量声明</h4><p>Go语言是静态类型的编程语言，所以我们在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让Go语言能够推导出它们的类型。Go语言是静态类型的，所以一旦在初始化变量时确定了它的类型，之后就不可能再改变。这就避免了在后面维护程序时的一些问题。另外，请记住，这种类型的确定是在编译期完成的，因此不会对程序的运行效率产生任何影响。</p><blockquote><p>在Go语言中，变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数、结构体或接口。</p></blockquote><p><img src=./images/4-1.jpg alt></p><h4 id=32-重构>3.2 重构</h4><blockquote><p>我们通常把不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码修改方式，叫做对该程序的重构。重构的对象可以是一行代码、一个函数、一个功能模块，甚至一个软件系统。</p></blockquote><h4 id=33-代码块>3.3 代码块</h4><p>代码块一般就是一个由花括号括起来的区域，里面可以包含表达式和语句。全域代码块、空代码块。</p><h4 id=34-变量重声明>3.4 变量重声明</h4><p>对已经声明过的变量再次声明。变量重声明的前提条件如下。</p><ol><li>由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误。</li><li>变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了，我在下一篇文章中会讲到。</li><li>变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字<code>var</code>的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。</li><li>被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。</li></ol><p>对于同一个代码块而言,声明重名的变量是无法通过编译的，用短变量声明对已有变量进行重声明除外;对于不同的代码块来说，其中的变量重名没什么大不了，照样可以通过编译。</p><h4 id=35-重名变量查找过程>3.5 重名变量查找过程</h4><ul><li>首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。</li><li>其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。</li><li>一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么Go语言的编译器就会报错了。</li></ul><h4 id=36-语法糖>3.6 语法糖</h4><p>或者叫便利措施</p><h4 id=37-作用域>3.7 作用域</h4><p>程序实体的访问权限有三种：包级私有的、模块级私有的和公开的，一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制。</p><h4 id=38-类型断言>3.8 类型断言</h4><p>类型断言表达式的语法形式是<code>x.(T)</code>。其中的<code>x</code>代表要被判断类型的值</p><pre><code>var container = []string{&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;}
value,ok = interface{}(container).([]string)
</code></pre><p><img src=./images/6-1.png alt></p><h4 id=39-类型>3.9 类型</h4><ul><li><p><code>interface{}</code>代表了不包含任何方法定义的、空的接口类型。任何类型都是它的实现类型。任何类型的值都可以很方便地被转换成空接口的值。</p></li><li><p><code>struct{}</code>，它就代表了不包含任何字段和方法的、空的结构体类型。</p></li><li><p>比如空的切片值<code>[]string{} </code>表示元素类型为string的切片类型</p></li><li><p>空的字典值<code>map[int]string{}</code> 用来表示键类型为<code>int</code>、值类型为<code>string</code>的字典类型</p></li><li><p>string<code>是表示字符串类型的字面量，</code></p></li><li><p>uint8`是表示8位无符号整数类型的字面量</p></li></ul><h4 id=310-类型转换>3.10 类型转换</h4><p><strong>首先，对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。</strong></p><p><strong>第二，虽然直接把一个整数值转换为一个<code>string</code>类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的Unicode代码点，否则转换的结果将会是<code>"�"</code>（仅由高亮的问号组成的字符串值）。</strong></p><p><strong>关于<code>string</code>类型与各种切片类型之间的互转的。</strong></p><p>一个值在从<code>string</code>类型向<code>[]byte</code>类型转换时代表着以UTF-8编码的字符串会被拆分成零散、独立的字节。</p><pre><code>string([]byte{'\xe4', '\xbd', '\xa0', '\xe5', '\xa5', '\xbd'}) // 你好
</code></pre><p>比如，UTF-8编码的三个字节<code>\xe4</code>、<code>\xbd</code>和<code>\xa0</code>合在一起才能代表字符<code>'你'</code>，而<code>\xe5</code>、<code>\xa5</code>和<code>\xbd</code>合在一起才能代表字符<code>'好'</code>。</p><p>一个值在从<code>string</code>类型向<code>[]rune</code>类型转换时代表着字符串会被拆分成一个个Unicode字符。</p><pre><code>string([]rune{'\u4F60', '\u597D'}) // 你好
</code></pre><h4 id=311-别名类型类型再定义与潜在类型>3.11 别名类型、类型再定义与潜在类型</h4><p>潜在类型相同的不同类型的值之间是可以进行类型转换的。但对于集合类的类型<code>[]MyString2</code>与<code>[]string</code>来说这样做却是不合法的，因为<code>[]MyString2</code>与<code>[]string</code>的潜在类型不同，分别是<code>[]MyString2</code>和<code>[]string</code>。</p><p><img src=./images/6-2.png alt></p><h2 id=三go语言实战与应用>三：Go语言实战与应用</h2><h3 id=1数组和切片>1.数组和切片</h3><p>数组（array）类型和切片（slice）类型。它们的共同点是都属于集合类的类型，并且，它们的值也都可以用来存储某一种类型的值（或者说元素）。它们最重要的不同是：<strong>数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。</strong></p><blockquote><p>Go语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等；而Go语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。</p><p>注意，Go语言里不存在像Java等编程语言中令人困惑的“传值或传引用”问题。在Go语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。</p><p>如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。</p><p>我们在数组和切片之上都可以应用索引表达式，得到的都会是某个元素。我们在它们之上也都可以应用切片表达式，也都会得到一个新的切片。</p></blockquote><p><img src=./images/7-1.png alt></p><h4 id=切片与数组的关系>切片与数组的关系</h4><p>可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。切片的容量代表了它的底层数组的长度，但这仅限于使用<code>make</code>函数或者切片值字面量初始化切片的情况。</p><p>更通用的规则是：一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。</p><pre><code>例子：
s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
s4 := s3[3:6]

the length of s4:3
the captcity of s4(8-3):5
</code></pre><p><img src=./images/7-2.png alt></p><h4 id=切片容量扩容>切片容量扩容</h4><p>一旦一个切片无法容纳更多的元素，Go语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的2倍。</p><p>但是，当原切片的长度（以下简称原长度）大于或等于<code>1024</code>时，Go语言将会以原容量的<code>1.25</code>倍作为新容量的基准（以下新容量基准）。新容量基准会被调整（不断地与<code>1.25</code>相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会比新长度大一些，当然，相等也是可能的。</p><p>另外，如果我们一次追加的元素过多，以至于使新长度比原容量的2倍还要大，那么新容量就会以新长度为基准。注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些</p><pre><code>	s5 := make([]int,0)
	for i :=1; i &lt; 5;i++{
		s5 = append(s5,i)
		fmt.Printf(&quot;s5(%d): len: %d, cap: %d\n&quot;, i, len(s5), cap(s5))
	}
	s5_1 := append(s5,make([]int,102)...)
	fmt.Printf(&quot;s6: len: %d, cap: %d\n&quot;, len(s5_1), cap(s5_1))
	s6 := make([]int, 1024)
	s6_1 := append(s6, make([]int, 200)...)
	fmt.Printf(&quot;s7e1: len: %d, cap: %d\n&quot;, len(s6_1), cap(s6_1))
	
	---------------------
	s5(1): len: 1, cap: 1
	s5(2): len: 2, cap: 2
	s5(3): len: 3, cap: 4
	s5(4): len: 4, cap: 4
	s5_1: len: 106, cap: 112
	s6_1: len: 1224, cap: 1280
</code></pre><p>注意：</p><ul><li><p><strong>一个切片的底层数组永远不会被替换,虽然在扩容的时候Go语言一定会生成新的底层数组，但是它也同时生成了新的切片。它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。</strong></p></li><li><p><strong><code>append</code>函数返回的是指向原底层数组的原切片，而在需要扩容时，<code>append</code>函数返回的是指向新底层数组的新切片。</strong></p></li></ul><h3 id=2container包中的那些容器>2.container包中的那些容器</h3><p>Go语言的链表实现在标准库的<code>container/list</code>代码包中，List实现了一个双向链表（以下简称链表），而Element则代表了链表中元素的结构。</p><h4 id=链表var-l-listlist>链表var l list.List</h4><p><code>List</code>这个结构体类型有两个字段，一个是<code>Element</code>类型的字段<code>root</code>，另一个是<code>int</code>类型的字段<code>len</code>,它们都是包级私有的，也就是说使用者无法查看和修改它们。</p><p><code>len</code>的零值是<code>0</code>，</p><p><code>root</code>是<code>Element</code>类型 零值 Element{}<code>。</code></p><blockquote><blockquote><p>Element`类型包含了几个包级私有的字段，分别用于存储前一个元素、后一个元素以及所属链表的指针值。</p></blockquote></blockquote><blockquote><blockquote><p><code>Value</code>的公开的字段， 它是<code>interface{}</code>类型的。在<code>Element</code>类型的零值中，这些字段的值都会是<code>nil</code>。</p></blockquote></blockquote><h4 id=延迟初始化>延迟初始化</h4><p>所谓的<strong>延迟初始化</strong>，你可以理解为把初始化操作延后，仅在实际需要的时候才进行。延迟初始化的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。</p><h4 id=ringring-与-listlist区别>ring.Ring 与 list.List区别</h4><p><code>container/ring</code>包中的<code>Ring</code>类型实现的是一个循环链表，也就是我们俗称的环。其实<code>List</code>在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。</p><ol><li>Ring<code>类型的数据结构仅由它自身即可代表，而</code>List<code>类型则需要由它以及</code>Element`类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。</li><li>一个<code>Ring</code>类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个<code>List</code>类型的值则代表了一个完整的链表。这是表示维度上的不同。</li><li>在创建并初始化一个<code>Ring</code>值的时候，我们可以指定它包含的元素的数量，但是对于一个<code>List</code>值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的<code>New</code>函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。</li><li>仅通过<code>var r ring.Ring</code>语句声明的<code>r</code>将会是一个长度为<code>1</code>的循环链表，而<code>List</code>类型的零值则是一个长度为<code>0</code>的链表。别忘了<code>List</code>中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。</li><li><code>Ring</code>值的<code>Len</code>方法的算法复杂度是O(N)的，而<code>List</code>值的<code>Len</code>方法的算法复杂度则是O(1)的。这是两者在性能方面最显而易见的差别。</li></ol><h3 id=3字典的操作和约束>3.字典的操作和约束</h3><p>Go语言字典的键类型不可以是函数类型、字典类型和切片类型。Go语言的字典类型其实是一个哈希表（hash table）的特定实现，键的类型是受限的，而元素却可以是任意类型的。</p><h4 id=根据键值获取值>根据键值获取值</h4><p>先把键值作为参数传给这个哈希表。哈希表会先用哈希函数（hash function）把键值转换为哈希值。哈希值通常是一个无符号的整数。一个哈希表会持有一定数量的桶（bucket），我们也可以叫它哈希桶，这些哈希桶会均匀地储存其所属哈希表收纳的键-元素对。</p><p>哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。由于键-元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素值。</p><h4 id=键值的约束>键值的约束</h4><p>Go语言规范规定，在键类型的值之间必须可以施加操作符<code>==</code>和<code>!=</code>键类型的值必须要支持判等操作。</p><h4 id=哈希碰撞>哈希碰撞</h4><p>不同值的哈希值是可能相同的。所以即使哈希值一样，键值也不一定一样。只有键的哈希值和键值都相等，才能说明查找到了匹配的键-元素对。</p><h4 id=哪些类型适和做键类型>哪些类型适和做键类型</h4><p><strong>求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。</strong></p><p>对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go语言都有一套算法与之对应。这套算法中就包含了哈希和判等。</p><h3 id=4通道的基本操作>4.通道的基本操作</h3><p>作为Go语言最有特色的数据类型，通道（channel）完全可以与goroutine（也可称为go程）并驾齐驱，共同代表Go语言独有的并发编程模式和编程哲学。</p><blockquote><p>Don’t communicate by sharing memory; share memory by communicating. （不要通过共享内存来通信，而应该通过通信来共享内存。）</p></blockquote><p>这是作为Go语言的主要创造者之一的Rob Pike的至理名言，这也充分体现了Go语言最重要的编程理念。通道类型的值本身就是并发安全的，这也是Go语言自带的、唯一一个可以满足并发安全性的类型。</p><h4 id=通道特性>通道特性</h4><p><strong>一个通道相当于一个先进先出（FIFO）的队列</strong>。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符<code>&lt;-</code>。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。</p><p>基本特性如下。</p><ol><li><p>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。</p><p><strong>元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。</strong></p></li><li><p>发送操作和接收操作中对元素值的处理都是不可分割的。</p></li><li><p>发送操作在完全完成之前会被阻塞。接收操作也是如此。</p></li></ol><hr><h4 id=通道panic>通道panic</h4><p>通道一旦关闭，再对它进行发送操作，就会引发panic。如果我们试图关闭一个已经关闭了的通道，也会引发panic。</p><h4 id=通道发送和接收>通道发送和接收</h4><p><strong>缓冲通道</strong> 如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。这时，通道会优先通知最早因此而等待的、那个发送操作所在的goroutine，后者会再次执行发送操作。它们所在的goroutine会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。</p><p>相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的goroutine，并使它再次执行接收操作。因此而等待的、所有接收操作所在的goroutine，都会按照先后顺序被放入通道内部的接收等待队列。</p><p>缓冲通道会作为收发双方的中间件。元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。</p><p><strong>非缓冲通道</strong> 无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。</p><p>非缓冲通道是在用同步的方式传递数据。 缓冲通道则在用异步的方式传递数据。</p><p>值为<code>nil</code>的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的goroutine中的任何代码，都不再会被执行。由于通道类型是引用类型，所以它的零值就是<code>nil</code>。换句话说，当我们只声明该类型的变量但没有用<code>make</code>函数对它进行初始化时，该变量的值就会是<code>nil</code>。<strong>我们一定不要忘记初始化通道！</strong></p><h4 id=单向通道>单向通道</h4><p>只能发而不能收 <code>var singleDirectionChan = make(chan&lt;- int, 1)</code></p><p>只能收不能发 `var singleDirectionChan = make(&lt;-chan int, 1)</p><p>单向通道最主要的用途就是约束其他代码的行为:</p><pre><code>type Notifier interface {
	SendInt(ch chan&lt;- int)
}
</code></pre><p>使用带<code>range</code>子句的<code>for</code>语句从通道中获取数据，也可以通过</p><h4 id=for-range语句操纵通道><code>for range</code>语句操纵通道</h4><p>带有<code>range</code>子句的<code>for</code>语句操纵通道：</p><h4 id=select语句操纵通道><code>select</code>语句操纵通道</h4><p><code>select</code>语句是Go语言还有一种专门为了操作通道而存在的语句，规则如下：</p><ul><li><p>对于每一个<code>case</code>表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。它包含的多个表达式总会以从左到右的顺序被求值。</p></li><li><p>select<code>语句包含的候选分支中的</code>case`表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。</p></li><li><p>对于每一个<code>case</code>表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该<code>case</code>表达式的求值就是不成功的。在这种情况下，我们可以说，这个<code>case</code>表达式所在的候选分支是不满足选择条件的。</p></li><li><p>仅当<code>select</code>语句中的所有<code>case</code>表达式都被求值完毕后，它才会开始选择候选分支。这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行。如果这时没有默认分支，那么<code>select</code>语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止。一旦有一个候选分支满足选择条件，<code>select</code>语句（或者说它所在的goroutine）就会被唤醒，这个候选分支就会被执行。</p></li><li><p>如果<code>select</code>语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行。注意，即使<code>select</code>语句是在被唤醒时发现的这种情况，也会这样做。</p></li><li><p>一条<code>select</code>语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关。</p></li><li><p>select<code>语句的每次执行，包括</code>case<code>表达式求值和分支选择，都是独立的。不过，至于它的执行是否是并发安全的，就要看其中的</code>case`表达式以及分支中，是否包含并发不安全的代码了。</p></li></ul><h3 id=5使用函数的正确姿势>5.使用函数的正确姿势</h3><p>“函数是一等的公民”，函数类型它是一种对一组输入、输出进行模板化的重要工具；函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等。</p><p>只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可以说它们是一样的函数，各个参数名称、结果的名称、函数的名称(调用函数时给定的标识符)不能算作函数签名的一部分。</p><p>函数参数原则：<strong>既不要把你程序的细节暴露给外界，也尽量不要让外界的变动影响到你的程序。</strong></p><p><strong>所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是它的副本。</strong></p><h4 id=函数类型>函数类型</h4><p>声明函数类型<code>type operate func(x, y int) int</code> 它有两个参数和一个结果，都是<code>int</code>类型。</p><p>函数类型属于引用类型，零值是nil。</p><h4 id=匿名函数>匿名函数</h4><pre><code>op := func(x, y int) int {
	return x + y
}
</code></pre><h4 id=高阶函数与闭包>高阶函数与闭包</h4><p>高阶函数条件</p><ul><li><p>接受其他的函数作为参数传入</p></li><li><p>把其他的函数作为结果返回</p></li></ul><p><img src=./images/12-1.png alt></p><p>严格来说，函数的名称也不能算作函数签名的一部分，它只是我们在调用函数时，需要给定的标识符而已。</p><h3 id=6结构体及其方法的使用法门>6.结构体及其方法的使用法门</h3><p><strong>Go语言中根本没有继承的概念</strong>，它所做的是通过嵌入字段的方式实现了类型之间的组合，见官方解释 <a href=https://golang.org/doc/faq#inheritance>https://golang.org/doc/faq#inheritance</a></p><blockquote><p>面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。</p></blockquote><h4 id=结构体接收者>结构体接收者</h4><p>接收者声明就是在关键字<code>func</code>和方法名称之间的圆括号包裹起来的内容，其中必须包含<strong>确切的名称</strong>和<strong>类型字面量</strong>。</p><pre><code>func (ac AnimalCategory) String() string {
    ....
}
</code></pre><p>上面代码的接收者声明可以看出它隶属于<code>AnimalCategory</code>类型，方法隶属的类型其实并不局限于结构体类型，但必须是某个自定义的数据类型，并且不能是任何接口类型。在Go语言中，我们可以通过为一个类型编写名为<code>String</code>的方法，来自定义该类型的字符串表示形式。这个<code>String</code>方法不需要任何参数声明，但需要有一个<code>string</code>类型的结果声明。</p><blockquote><p>一个数据类型关联的所有方法，共同组成了该类型的方法集合。同一个方法集合中的方法不能出现重名。并且，如果它们所属的是一个结构体类型，那么它们的名称与该类型中任何字段的名称也不能重复。</p></blockquote><blockquote><p>我们可以把结构体类型中的一个字段看作是它的一个属性或者一项数据，再把隶属于它的一个方法看作是附加在其中数据之上的一个能力或者一项操作。将属性及其能力（或者说数据及其操作）封装在一起，是面向对象编程（object-oriented programming）的一个主要原则。</p></blockquote><blockquote><p>Go语言摄取了面向对象编程中的很多优秀特性，同时也推荐这种封装的做法。从这方面看，Go语言其实是支持面向对象编程的，但它选择摒弃了一些在实际运用过程中容易引起程序开发者困惑的特性和规则。</p></blockquote><h4 id=嵌入字段>嵌入字段</h4><p>嵌入字段是其声明中只有类型而没有名称的字段，它可以以一种很自然的方式为被嵌入的类型带来新的属性和能力。但是需要小心可能产生“屏蔽”现象的地方，尤其是当存在多个嵌入字段或者多层嵌入的时候。“屏蔽”现象可能会让你的实际引用与你的预期不符。</p><pre><code>type Animal struct {
	scientificName string  
	AnimalCategory //嵌入字段 or 匿名字段,相当于此类型变量的名称后跟“.”,嵌入字段的类型既是类型也是名称。
}
</code></pre><h4 id=类型组合>类型组合</h4><p>类型之间的组合采用的是非声明的方式，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。组合要比继承更加简洁和清晰；</p><h4 id=值方法和指针方法区别>值方法和指针方法区别</h4><ul><li><p>值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型。</p></li><li><p>而指针方法的接收者，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内对该副本指向的值进行修改，却一定会体现在原值上。</p></li><li><p>一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。</p></li></ul><h3 id=7接口类型的合理运用>7.接口类型的合理运用</h3><p>接口类型声明中的这些方法所代表的就是该接口的方法集合。一个接口的方法集合就是它的全部特征。对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征（即全部的方法），那么它就一定是这个接口的实现类型。</p><h4 id=动态类型>动态类型</h4><p>除非我们只声明而不初始化，或者显式地赋给它<code>nil</code>，否则接口变量的值就不会为<code>nil</code>。</p><h4 id=接口组合>接口组合</h4><p>Go语言团队鼓励我们声明体量较小的接口，并建议我们通过接口间的组合来扩展程序、增加程序的灵活性。</p><p>这是因为相比于包含很多方法的大接口而言，小接口可以更加专注地表达某一种能力或某一类特征，同时也更容易被组合在一起。</p><h3 id=8关于指针的有限操作>8.关于指针的有限操作</h3><p>从传统意义上说，指针是一个指向某个确切的内存地址的值。</p><pre><code>type struct Dog{
   name string
}
func (dog *Dog) SetName(name string) {
	dog.name = name
}
func New(name string) Dog {
	return Dog{name}
}

【1】New(&quot;cat&quot;).SetName(&quot;miao miao&quot;)   //我们可以在一个基本类型的值上调用它的指针方法，这是因为Go语言会自动地帮我们转译，但是New`函数所得到的结果值属于临时结果 无法取址导致编译报错
【2】
 dog := New(&quot;cat&quot;)
 dog.SetName(&quot;monster&quot;)  //Dog类型的变量dog，被自动地转译为(&amp;dog).SetName(&quot;monster&quot;)，即：先取dog的指针值，再在该指针值上调用SetName方法。

</code></pre><p>从例子代码看：对于基本类型<code>Dog</code>来说，<code>*Dog</code>就是它的指针类型。而对于一个<code>Dog</code>类型，值不为<code>nil</code>的变量<code>dog</code>，取址表达式<code>&dog</code>的结果就是该变量的值（也就是基本值）的指针值。如果一个方法的接收者是<code>*Dog</code>类型的，那么该方法就是基本类型<code>Dog</code>的指针方法。</p><h4 id=可以代表指针有哪些>可以代表指针有哪些</h4><p>在Go语言中 uintptr`类型可以代表“指针”，该类型实际上是一个数值类型，也是Go语言内建的数据类型之一。根据当前计算机的计算架构的不同，它可以存储32位或64位的无符号整数，可以代表任何指针的位（bit）模式，也就是原始的内存地址。</p><p>Go语言标准库中的<code>unsafe</code>包。``unsafe.Pointer<code>也代表了“指针”，表示任何指向可寻址的值的指针，同时它也是前面提到的指针值和</code>uintptr`值之间的桥梁。通过它，我们可以在这两种值之上进行双向的转换——可寻址的（addressable）。</p><h4 id=哪些值是不可寻址>哪些值是不可寻址</h4><p>常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是<strong>不可变的</strong>。由于Go语言中的字符串值也是不可变的，所以对于一个字符串类型的变量来说，基于它的索引或切片的结果值也都是不可寻址的。</p><p>算术操作的结果值属于一种<strong>临时结果</strong>,是不可寻址的。针对数组值、切片值或字典值的<strong>字面量</strong>的表达式会产生临时结果。这主要因为变量的值本身就不是“临时的”。对比而言，值字面量在还没有与任何变量（或者说任何标识符）绑定之前是没有落脚点的，我们无法以任何方式引用到它们。这样的值就是“临时的”。</p><blockquote><p>一个需要特别注意的例外是，对切片字面量的索引结果值是可寻址的。因为不论怎样，每个切片值都会持有一个底层数组，而这个底层数组中的每个元素值都是有一个确切的内存地址的。</p><p>如果针对的是数组类型或切片类型的<strong>变量</strong>，那么索引或切片的结果值就都不属于临时结果了，是可寻址的。</p><p>如果我们把临时结果赋给一个变量，那么它就是可寻址的了。如此一来，取得的指针指向的就是这个变量持有的那个值了。</p></blockquote><p>Go语言中以下是不可寻址</p><ul><li>常量的值。</li><li>基本类型值的字面量。</li><li>算术操作的结果值。</li><li>对各种字面量的索引表达式和切片表达式的结果值。不过有一个例外，对切片字面量的索引结果值却是可寻址的。</li><li>对字符串变量的索引表达式和切片表达式的结果值。</li><li>对字典变量的索引表达式的结果值。</li><li>函数字面量和方法字面量，以及对它们的调用表达式的结果值。</li><li>结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值。</li><li>类型转换表达式的结果值。</li><li>类型断言表达式的结果值。</li><li>接收表达式的结果值。</li></ul><p>不可寻址的判断方法</p><ol><li><strong>不可变的</strong>值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。</li><li>绝大多数被视为<strong>临时结果</strong>的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。</li><li>若拿到某值的指针可能会破坏程序的一致性，那么就是<strong>不安全的</strong>，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。</li></ol><p>不可寻址的值使用限制</p><ul><li><p>无法使用取址操作符<code>&</code>获取它们的指针了。 对不可寻址的值施加取址操作都会使编译器报错。</p></li><li><p>Go语言中的<code>++</code>和<code>--</code>并不属于操作符，只要在<code>++</code>或<code>--</code>的左边添加一个表达式，就可以组成一个自增语句或自减语句，这个表达式的结果值必须是可寻址的。</p></li><li><p>特殊情况</p><p><strong>虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。</strong></p><p><strong>在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。</strong></p><p><strong>在带有<code>range</code>子句的<code>for</code>语句中，在<code>range</code>关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。</strong></p></li></ul><h4 id=go语言中的常用表达式有以下几种>Go语言中的常用表达式有以下几种。</h4><ul><li>用于获得某个元素的索引表达式。</li><li>用于获得某个切片（片段）的切片表达式。</li><li>用于访问某个字段的选择表达式。</li><li>用于调用某个函数或方法的调用表达式。</li><li>用于转换值的类型的类型转换表达式。</li><li>用于判断值的类型的类型断言表达式。</li><li>向通道发送元素值或从通道那里接收元素值的接收表达式。</li></ul><h4 id=使用unsafepointer操纵可寻址的值>使用<code>unsafe.Pointer</code>操纵可寻址的值</h4><p>利用<code>unsafe.Pointer</code>的中转和<code>uintptr</code>的底层操作来操纵类型值，它可以绕过Go语言的编译器和其他工具的重重检查，并达到潜入内存修改数据的目的。这并不是一种正常的编程手段，很有可能造成安全隐患。</p><p>我们总是应该优先使用常规代码包中提供的API去编写程序，当然也可以把像<code>reflect</code>以及<code>go/ast</code>这样的代码包作为备选项。作为上层应用的开发者，请谨慎地使用<code>unsafe</code>包中的任何程序实体。</p><p><code>unsafe.Pointer</code>的中转和<code>uintptr</code>的转换规则：</p><ol><li>一个指针值（比如<code>*Dog</code>类型的值）可以被转换为一个<code>unsafe.Pointer</code>类型的值，反之亦然。</li><li>一个<code>uintptr</code>类型的值也可以被转换为一个<code>unsafe.Pointer</code>类型的值，反之亦然。</li><li>一个指针值无法被直接转换成一个<code>uintptr</code>类型的值，反过来也是如此。</li></ol><p>例：</p><pre><code>dog := Dog{&quot;little pig&quot;}
dogP := &amp;dog   //取出了它的指针值
dogPtr := uintptr(unsafe.Pointer(dogP))

namePtr := dogPtr + unsafe.Offsetof(dogP.name)  //起始存储地址 + 偏移量，以字节为单位
nameP := (*string)(unsafe.Pointer(namePtr)) // 转换成*string`类型的值
</code></pre><h3 id=go语句及其执行规则>go语句及其执行规则</h3><h3 id=if语句for语句和switch语句>if语句、for语句和switch语句</h3><h3 id=错误处理>错误处理</h3><h3 id=panic函数recover函数以及defer语句>panic函数、recover函数以及defer语句</h3><h2 id=四go语言进阶技术>四：Go语言进阶技术</h2><h2 id=五附录>五：附录</h2><h3 id=1go命令>1.go命令</h3><h4 id=go-get><code>go get</code></h4><p>命令<code>go get</code>会自动从一些主流公用代码仓库（比如GitHub）下载目标代码包，并把它们安装到环境变量<code>GOPATH</code>包含的第1工作区的相应目录中。如果存在环境变量<code>GOBIN</code>，那么仅包含命令源码文件的代码包会被安装到<code>GOBIN</code>指向的那个目录。</p><p>最常用的几个标记有下面几种。</p><ul><li><code>-u</code>：下载并安装代码包，不论工作区中是否已存在它们。</li><li><code>-d</code>：只下载代码包，不安装代码包。</li><li><code>-fix</code>：在下载代码包后先运行一个用于根据当前Go语言版本修正代码的工具，然后再安装代码包。</li><li><code>-t</code>：同时下载测试所需的代码包。</li><li><code>-insecure</code>：允许通过非安全的网络协议下载和安装代码包。HTTP就是这样的协议。</li></ul><h4 id=go-build><code>go build</code></h4><p>默认不会编译目标代码包所依赖的那些代码包。当然，如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。</p><p>-a 强制编译,不但目标代码包总是会被编译，它依赖的代码包也总会被编译</p><p>-i 不但要编译依赖的代码包，还要安装它们的归档文件</p><p>-v 可以看到<code>go build</code>命令编译的代码包的名称</p><p>-x 这样可以看到<code>go build</code>命令具体都执行了哪些操作</p><p>-n 可以只查看具体操作而不执行它们</p><h4 id=go-install><code>go install</code></h4><h3 id=1go基础知识>1.go基础知识</h3><p><img src=./images/dt.jpg alt></p><h3 id=2github优秀项目导图>2.github优秀项目导图</h3><p>【clash】https://github.com/Dreamacro/clash</p><p><img src=./images/goproject.jpg alt></p><h3 id=3问题记录>3.问题记录</h3><h4 id=1main-file-has-non-main-package-or-doesnt-contain-main-function>1）Main file has non-main package or doesn&rsquo;t contain main function</h4><p>如果为程序入口的main方法文件，则包应为package main,注意与目录无关。</p><footer><section class=categories-tags><span><svg class="icon icon-folder"><use xlink:href="#icon-folder"/></svg><span class=screen-reader-text>This entry was posted in</span>
<a href=/categories/java>java</a></span> <span><svg class="icon icon-tag"><use xlink:href="#icon-tag"/></svg><a class=article-tags href=/tags/canal>canal</a></span></section></footer><div id=comments-button-container class=comments-button-container><button type=button onclick=loadDisqus() class=comments-button><svg class="icon icon-bubble"><use xlink:href="#icon-bubble"/></svg> <span>Show Comments</span></button></div><div id=disqus_thread></div><script type=text/javascript>function loadDisqus(){var a,b;document.getElementById('comments-button-container').style.display='none',a=document.createElement('script'),a.type='text/javascript',a.async=!0,b='李明梓',a.src='//'+b+'.disqus.com/embed.js',(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(a)}</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><aside id=sidebar><div class=widget><div class=widget-title>Recent posts</div><ol class="recent-widget widget-content"><li><a href=/go-sdk/>GO SDK</a></li><li><a href=/jemeter%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/>jemeter基本使用</a></li><li><a href=/%E5%A4%A7%E9%A3%8E%E6%AD%8C%E7%8E%8B%E7%AB%8B%E7%BE%A4/>&lt;&lt;大风歌>>王立群</a></li><li><a href=/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/>位运算基础知识</a></li><li><a href=/canal-mysql-binlog%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90/>canal-mysql binlog日志解析</a></li></ol></div><div class=widget><div class=widget-title>Categories</div><ol class="all-categories widget-content"><li><a href=/categories/devops>devops</a> (1)</li><li><a href=/categories/java>java</a> (6)</li><li><a href=/categories/mysql>mysql</a> (1)</li><li><a href=/categories/%E5%85%B6%E4%BB%96>其他</a> (4)</li><li><a href=/categories/%E5%89%8D%E7%AB%AF>前端</a> (1)</li><li><a href=/categories/%E5%90%8E%E7%AB%AF>后端</a> (2)</li><li><a href=/categories/%E5%9F%BA%E7%A1%80>基础</a> (1)</li><li><a href=/categories/%E5%B7%A5%E5%85%B7>工具</a> (3)</li></ol></div><div class=widget><div class=widget-title>Tags</div><div class="tag-cloud-tags widget-content"><a href=/tags/canal aria-label="canal (4 posts)" style=font-size:1rem>canal</a>
<a href=/tags/git aria-label="git (1 posts)" style=font-size:1rem>git</a>
<a href=/tags/go aria-label="go (2 posts)" style=font-size:1rem>go</a>
<a href=/tags/hexo aria-label="hexo (1 posts)" style=font-size:1rem>hexo</a>
<a href=/tags/java aria-label="java (1 posts)" style=font-size:1rem>java</a>
<a href=/tags/maven aria-label="maven (1 posts)" style=font-size:1rem>maven</a>
<a href=/tags/mysql aria-label="mysql (1 posts)" style=font-size:1rem>mysql</a>
<a href=/tags/yarn aria-label="yarn (1 posts)" style=font-size:1rem>yarn</a>
<a href=/tags/zabbix aria-label="zabbix (1 posts)" style=font-size:1rem>zabbix</a>
<a href=/tags/%E5%9F%BA%E7%A1%80 aria-label="基础 (1 posts)" style=font-size:1rem>基础</a>
<a href=/tags/%E5%B7%A5%E5%85%B7 aria-label="工具 (2 posts)" style=font-size:1rem>工具</a>
<a href=/tags/%E8%BD%AF%E6%96%87%E6%94%B6%E9%9B%86 aria-label="软文收集 (2 posts)" style=font-size:1rem>软文收集</a></div></div></aside></div></div><svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><symbol id="icon-github" viewBox="0 0 32 32"><path d="M16 .395c-8.836.0-16 7.163-16 16 0 7.069 4.585 13.067 10.942 15.182.8.148 1.094-.347 1.094-.77.0-.381-.015-1.642-.022-2.979-4.452.968-5.391-1.888-5.391-1.888-.728-1.849-1.776-2.341-1.776-2.341-1.452-.993.11-.973.11-.973 1.606.113 2.452 1.649 2.452 1.649 1.427 2.446 3.743 1.739 4.656 1.33.143-1.034.558-1.74 1.016-2.14-3.554-.404-7.29-1.777-7.29-7.907.0-1.747.625-3.174 1.649-4.295-.166-.403-.714-2.03.155-4.234.0.0 1.344-.43 4.401 1.64 1.276-.355 2.645-.532 4.005-.539 1.359.006 2.729.184 4.008.539 3.054-2.07 4.395-1.64 4.395-1.64.871 2.204.323 3.831.157 4.234 1.026 1.12 1.647 2.548 1.647 4.295.0 6.145-3.743 7.498-7.306 7.895.574.497 1.085 1.47 1.085 2.963.0 2.141-.019 3.864-.019 4.391.0.426.288.925 1.099.768C27.421 29.457 32 23.462 32 16.395c0-8.837-7.164-16-16-16z"/></symbol><symbol id="icon-arrow-with-circle-up" viewBox="0 0 32 32"><path d="M16 .64C7.515.64.638 7.517.638 16c0 8.485 6.877 15.362 15.362 15.362 8.482.0 15.36-6.877 15.36-15.362.0-8.483-6.878-15.36-15.36-15.36zM15.998 28.16c-6.715.0-12.16-5.443-12.16-12.16S9.281 3.84 15.998 3.84 28.16 9.285 28.16 16s-5.446 12.16-12.162 12.16zM16 8.8l7.2 7.2h-4v6.4h-6.4V16h-4L16 8.8z"/></symbol></defs></svg><footer id=page-footer><div class=footer-content><a href=https://github.com/qiaomingzi/limz-blog-hugo target=_blank rel=noopener title="Source Code for this Blog"><div class=footer-text><svg class="icon icon-github"><use xlink:href="#icon-github"/></svg>Blog code</div></a><a href=#page-wrapper title="Go to top" id=go-to-top-link><div class=footer-text>To top<svg class="icon icon-arrow-with-circle-up"><use xlink:href="#icon-arrow-with-circle-up"/></svg></div></a><script>document.getElementById("go-to-top-link").onclick=function(){return window.scroll(0,0),!1}</script></div></footer></div><div id=lightbox-container :class="{'open': lightbox.isOpen, 'close': !lightbox.isOpen}"><button type=button aria-label="Close image modal" class=modal-close-button @click=lightbox.close()><svg class="icon icon-circle-with-cross"><use xlink:href="#icon-circle-with-cross"/></svg>
(ESC)</button><div id=lightbox-loading-container x-ref=lightboxLoadingContainer x-show=lightbox.showLoading><div id=lightbox-loading><div aria-busy=true aria-label="Loading, please wait." role=progressbar class=spinner @click=lightbox.cancel() @click.away=lightbox.cancel()></div></div></div><div id=lightbox x-ref=lightbox :class="{'open': lightbox.openImage, 'close': !lightbox.openImage}" @click=lightbox.close()></div></div><div id=code-container :class="{'open': code.isOpening, 'close': !code.isOpening}"><button class=modal-close-button><svg class="icon icon-circle-with-cross"><use xlink:href="#icon-circle-with-cross"/></svg>
(ESC)</button><div id=code-container-inner class=close :class="{'open': code.isOpening, 'close': !code.isOpening}"><div class=box-shadow-container @click.away=code.close()><div id=code-placeholder></div></div></div></div><div id=searchbox-container :class="{'open': search.isOpen}" x-show=search.isOpen x-on:keydown.escape="$nextTick(() => $refs.searchMenuLink.focus())"><button type=button aria-label="Close search modal" class=modal-close-button @click="search.close();$nextTick(() => $refs.searchMenuLink.focus())"><svg class="icon icon-circle-with-cross"><use xlink:href="#icon-circle-with-cross"/></svg>
(ESC)</button><div id=searchbox :class="{'open': search.isOpen}"><svg class="icon icon-search"><use xlink:href="#icon-search"/></svg><label for=search-input class=sr-only>Searchbox</label>
<input id=search-input type=search placeholder=Search... class=search-input x-ref=searchInput autocomplete=off autocorrect=off autocapitalize=off spellcheck=false x-model=search.textInSearchBox x-on:input=search.searchBoxChanged($event.target.value) x-on:keydown.enter="search.focusFirstAnchor($event, $refs.hits)" x-on:keydown.arrow-down="search.focusFirstAnchor($event, $refs.hits)"><svg class="icon icon-circle-with-cross close-search" role="button" aria-label="Close search" @click="search.close();$nextTick(() => $refs.searchMenuLink.focus())"><use xlink:href="#icon-circle-with-cross"/></svg></div><div class=search-results-container><div id=search-output x-show=search.textInSearchBox><div id=no-results-message x-show="search.store && search.textInSearchBox && !search.hits.length">No matching posts found. You can use wildcards and search only in titles, e.g. <code>title:iot</code></div><div id=index-loading-message x-show="!search.indexLoadFailed && search.indexLoading && search.textInSearchBox"><span class=icon-spinner aria-hidden=true></span>Loading search index, please wait...</div><div id=index-failed-message x-show="search.indexLoadFailed && search.textInSearchBox">Search index failed to download 😢</div><div id=number-of-hits-message x-text=search.getHitsText() x-show=search.hits.length></div><ol class=result-list x-show=search.hits.length x-ref=hits><template x-for="hit in search.hits" :key=hit.ref><li><h2><a :href=hit.ref x-text=search.fromStore(hit).title></a></h2><div class=entry-meta><time class=published :datetime=search.fromStore(hit).dateiso><svg class="icon icon-calendar"><use xlink:href="#icon-calendar"/></svg><span x-text=search.fromStore(hit).dateformatted></span></time></div><p x-text=search.fromStore(hit).summary></p></li></template></ol></div></div></div><script src=/bundle.326b2331e4a76c824b17b8d379095b25394912a8f7f1c8a6162a06f763a2caabe6226dee31773ec698c47b06f1de9bb7133091e9260d4d95b4011c7351300442.js integrity="sha512-MmsjMeSnbIJLF7jTeQlbJTlJEqj38cimFioG92OiyqvmIm3uMXc+xpjEewbx3pu3EzCR6SYNTZW0ARxzUTAEQg=="></script></body></html>