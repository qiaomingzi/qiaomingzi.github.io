[{"content":"一：概要 1.1.参考 【GO编程语言规范】https://golang.google.cn/ref/spec\n【GO命令】https://golang.google.cn/cmd/\n【环境设置】https://www.liwenzhou.com/posts/Go/install_go_dev_old/\n【Unicode】https://home.unicode.org/\n二：Go语言基础知识 理解Go语言的开发环境配置、常用源码文件写法，以及程序实体（尤其是变量）及其相关的各种概念和编程技巧（比如类型推断、变量重声明、可重名变量、类型断言、类型转换、别名类型和潜在类型等）。\n1.工作区和GOPATH GOROOT：Go语言安装根目录的路径，也就是GO语言的安装路径。\nGOPATH：若干工作区目录的路径。是我们自己定义的工作空间。\n你可以把GOPATH简单理解成Go语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表Go语言的一个工作区（workspace）\ngo mod init qiaomingzi.github.io/m/v1 GOBIN：GO程序生成的可执行文件（executable file）的路径。\n2.源码文件 2.1 运行程序 使用 go run 命令执行go源码main文件\n$ go run hello.go Hello, World! 此外我们还可以使用 go build 命令来生成二进制文件：\n$ go build hello.go $ ls hello hello.go $ ./hello Hello, World! 2.2 程序实体 是变量、常量、函数、结构体和接口的统称；程序实体的名字被统称为标识符。标识符可以是任何Unicode编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。\n如：var name string\n2.3 源文件包名 package xxx\n 同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。\n 源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。\n 为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致\n 名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。\n Go 1.5及后续版本中，我们可以通过创建internal代码包让一些程序实体仅仅能被当前模块中的其他代码引用。这被称为Go程序实体的第三种访问权限：模块级私有\n 3.程序实体的那些事儿 3.1 变量声明 Go语言是静态类型的编程语言，所以我们在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让Go语言能够推导出它们的类型。Go语言是静态类型的，所以一旦在初始化变量时确定了它的类型，之后就不可能再改变。这就避免了在后面维护程序时的一些问题。另外，请记住，这种类型的确定是在编译期完成的，因此不会对程序的运行效率产生任何影响。\n 在Go语言中，变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数、结构体或接口。\n 3.2 重构 我们通常把不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码修改方式，叫做对该程序的重构。重构的对象可以是一行代码、一个函数、一个功能模块，甚至一个软件系统。\n 3.3 代码块 代码块一般就是一个由花括号括起来的区域，里面可以包含表达式和语句。全域代码块、空代码块。\n3.4 变量重声明 对已经声明过的变量再次声明。变量重声明的前提条件如下。\n 由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误。 变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了，我在下一篇文章中会讲到。 变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。 被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。 对于同一个代码块而言,声明重名的变量是无法通过编译的，用短变量声明对已有变量进行重声明除外;对于不同的代码块来说，其中的变量重名没什么大不了，照样可以通过编译。\n3.5 重名变量查找过程 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么Go语言的编译器就会报错了。 3.6 语法糖 或者叫便利措施\n3.7 作用域 程序实体的访问权限有三种：包级私有的、模块级私有的和公开的，一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制。\n3.8 类型断言 类型断言表达式的语法形式是x.(T)。其中的x代表要被判断类型的值\nvar container = []string{\u0026quot;zero\u0026quot;, \u0026quot;one\u0026quot;, \u0026quot;two\u0026quot;} value,ok = interface{}(container).([]string) 3.9 类型 interface{}代表了不包含任何方法定义的、空的接口类型。任何类型都是它的实现类型。任何类型的值都可以很方便地被转换成空接口的值。\n struct{}，它就代表了不包含任何字段和方法的、空的结构体类型。\n 比如空的切片值[]string{} 表示元素类型为string的切片类型\n 空的字典值map[int]string{} 用来表示键类型为int、值类型为string的字典类型\n string是表示字符串类型的字面量，\n uint8`是表示8位无符号整数类型的字面量\n 3.10 类型转换 首先，对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。\n第二，虽然直接把一个整数值转换为一个string类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的Unicode代码点，否则转换的结果将会是\u0026quot;�\u0026quot;（仅由高亮的问号组成的字符串值）。\n关于string类型与各种切片类型之间的互转的。\n一个值在从string类型向[]byte类型转换时代表着以UTF-8编码的字符串会被拆分成零散、独立的字节。\nstring([]byte{'\\xe4', '\\xbd', '\\xa0', '\\xe5', '\\xa5', '\\xbd'}) // 你好 比如，UTF-8编码的三个字节\\xe4、\\xbd和\\xa0合在一起才能代表字符'你'，而\\xe5、\\xa5和\\xbd合在一起才能代表字符'好'。\n一个值在从string类型向[]rune类型转换时代表着字符串会被拆分成一个个Unicode字符。\nstring([]rune{'\\u4F60', '\\u597D'}) // 你好 3.11 别名类型、类型再定义与潜在类型 潜在类型相同的不同类型的值之间是可以进行类型转换的。但对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，因为[]MyString2与[]string的潜在类型不同，分别是[]MyString2和[]string。\n三：Go语言实战与应用 1.数组和切片 数组（array）类型和切片（slice）类型。它们的共同点是都属于集合类的类型，并且，它们的值也都可以用来存储某一种类型的值（或者说元素）。它们最重要的不同是：数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。\n Go语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等；而Go语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。注意，Go语言里不存在像Java等编程语言中令人困惑的“传值或传引用”问题。在Go语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。我们在数组和切片之上都可以应用索引表达式，得到的都会是某个元素。我们在它们之上也都可以应用切片表达式，也都会得到一个新的切片。 切片与数组的关系 可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。切片的容量代表了它的底层数组的长度，但这仅限于使用make函数或者切片值字面量初始化切片的情况。\n更通用的规则是：一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。\n例子： s3 := []int{1, 2, 3, 4, 5, 6, 7, 8} s4 := s3[3:6] the length of s4:3 the captcity of s4(8-3):5 切片容量扩容 一旦一个切片无法容纳更多的元素，Go语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的2倍。\n但是，当原切片的长度（以下简称原长度）大于或等于1024时，Go语言将会以原容量的1.25倍作为新容量的基准（以下新容量基准）。新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会比新长度大一些，当然，相等也是可能的。\n另外，如果我们一次追加的元素过多，以至于使新长度比原容量的2倍还要大，那么新容量就会以新长度为基准。注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些\n\ts5 := make([]int,0) for i :=1; i \u0026lt; 5;i++{ s5 = append(s5,i) fmt.Printf(\u0026quot;s5(%d): len: %d, cap: %d\\n\u0026quot;, i, len(s5), cap(s5)) } s5_1 := append(s5,make([]int,102)...) fmt.Printf(\u0026quot;s6: len: %d, cap: %d\\n\u0026quot;, len(s5_1), cap(s5_1)) s6 := make([]int, 1024) s6_1 := append(s6, make([]int, 200)...) fmt.Printf(\u0026quot;s7e1: len: %d, cap: %d\\n\u0026quot;, len(s6_1), cap(s6_1)) --------------------- s5(1): len: 1, cap: 1 s5(2): len: 2, cap: 2 s5(3): len: 3, cap: 4 s5(4): len: 4, cap: 4 s5_1: len: 106, cap: 112 s6_1: len: 1224, cap: 1280 注意：\n 一个切片的底层数组永远不会被替换,虽然在扩容的时候Go语言一定会生成新的底层数组，但是它也同时生成了新的切片。它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。\n append函数返回的是指向原底层数组的原切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。\n 2.container包中的那些容器 Go语言的链表实现在标准库的container/list代码包中，List实现了一个双向链表（以下简称链表），而Element则代表了链表中元素的结构。\n链表var l list.List List这个结构体类型有两个字段，一个是Element类型的字段root，另一个是int类型的字段len,它们都是包级私有的，也就是说使用者无法查看和修改它们。\nlen的零值是0，\nroot是Element类型 零值 Element{}。\n Element`类型包含了几个包级私有的字段，分别用于存储前一个元素、后一个元素以及所属链表的指针值。\n Value的公开的字段， 它是interface{}类型的。在Element类型的零值中，这些字段的值都会是nil。\n 延迟初始化 所谓的延迟初始化，你可以理解为把初始化操作延后，仅在实际需要的时候才进行。延迟初始化的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。\nring.Ring 与 list.List区别 container/ring包中的Ring类型实现的是一个循环链表，也就是我们俗称的环。其实List在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。\n Ring类型的数据结构仅由它自身即可代表，而List类型则需要由它以及Element`类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。 一个Ring类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个List类型的值则代表了一个完整的链表。这是表示维度上的不同。 在创建并初始化一个Ring值的时候，我们可以指定它包含的元素的数量，但是对于一个List值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的New函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。 仅通过var r ring.Ring语句声明的r将会是一个长度为1的循环链表，而List类型的零值则是一个长度为0的链表。别忘了List中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。 Ring值的Len方法的算法复杂度是O(N)的，而List值的Len方法的算法复杂度则是O(1)的。这是两者在性能方面最显而易见的差别。 3.字典的操作和约束 Go语言字典的键类型不可以是函数类型、字典类型和切片类型。Go语言的字典类型其实是一个哈希表（hash table）的特定实现，键的类型是受限的，而元素却可以是任意类型的。\n根据键值获取值 先把键值作为参数传给这个哈希表。哈希表会先用哈希函数（hash function）把键值转换为哈希值。哈希值通常是一个无符号的整数。一个哈希表会持有一定数量的桶（bucket），我们也可以叫它哈希桶，这些哈希桶会均匀地储存其所属哈希表收纳的键-元素对。\n哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。由于键-元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素值。\n键值的约束 Go语言规范规定，在键类型的值之间必须可以施加操作符==和!=键类型的值必须要支持判等操作。\n哈希碰撞 不同值的哈希值是可能相同的。所以即使哈希值一样，键值也不一定一样。只有键的哈希值和键值都相等，才能说明查找到了匹配的键-元素对。\n哪些类型适和做键类型 求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。\n对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go语言都有一套算法与之对应。这套算法中就包含了哈希和判等。\n4.通道的基本操作 作为Go语言最有特色的数据类型，通道（channel）完全可以与goroutine（也可称为go程）并驾齐驱，共同代表Go语言独有的并发编程模式和编程哲学。\n Don’t communicate by sharing memory; share memory by communicating. （不要通过共享内存来通信，而应该通过通信来共享内存。） 这是作为Go语言的主要创造者之一的Rob Pike的至理名言，这也充分体现了Go语言最重要的编程理念。通道类型的值本身就是并发安全的，这也是Go语言自带的、唯一一个可以满足并发安全性的类型。\n通道特性 一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符\u0026lt;-。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。\n基本特性如下。\n 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。\n元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。\n 发送操作和接收操作中对元素值的处理都是不可分割的。\n 发送操作在完全完成之前会被阻塞。接收操作也是如此。\n 通道panic 通道一旦关闭，再对它进行发送操作，就会引发panic。如果我们试图关闭一个已经关闭了的通道，也会引发panic。\n通道发送和接收 缓冲通道 如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。这时，通道会优先通知最早因此而等待的、那个发送操作所在的goroutine，后者会再次执行发送操作。它们所在的goroutine会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。\n相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的goroutine，并使它再次执行接收操作。因此而等待的、所有接收操作所在的goroutine，都会按照先后顺序被放入通道内部的接收等待队列。\n缓冲通道会作为收发双方的中间件。元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。\n非缓冲通道 无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。\n非缓冲通道是在用同步的方式传递数据。 缓冲通道则在用异步的方式传递数据。\n值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的goroutine中的任何代码，都不再会被执行。由于通道类型是引用类型，所以它的零值就是nil。换句话说，当我们只声明该类型的变量但没有用make函数对它进行初始化时，该变量的值就会是nil。我们一定不要忘记初始化通道！\n单向通道 只能发而不能收 var singleDirectionChan = make(chan\u0026lt;- int, 1)\n只能收不能发 `var singleDirectionChan = make(\u0026lt;-chan int, 1)\n单向通道最主要的用途就是约束其他代码的行为:\ntype Notifier interface { SendInt(ch chan\u0026lt;- int) } 使用带range子句的for语句从通道中获取数据，也可以通过\nfor range语句操纵通道 带有range子句的for语句操纵通道：\nselect语句操纵通道 select语句是Go语言还有一种专门为了操作通道而存在的语句，规则如下：\n 对于每一个case表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。它包含的多个表达式总会以从左到右的顺序被求值。\n select语句包含的候选分支中的case`表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。\n 对于每一个case表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该case表达式的求值就是不成功的。在这种情况下，我们可以说，这个case表达式所在的候选分支是不满足选择条件的。\n 仅当select语句中的所有case表达式都被求值完毕后，它才会开始选择候选分支。这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行。如果这时没有默认分支，那么select语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止。一旦有一个候选分支满足选择条件，select语句（或者说它所在的goroutine）就会被唤醒，这个候选分支就会被执行。\n 如果select语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行。注意，即使select语句是在被唤醒时发现的这种情况，也会这样做。\n 一条select语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关。\n select语句的每次执行，包括case表达式求值和分支选择，都是独立的。不过，至于它的执行是否是并发安全的，就要看其中的case`表达式以及分支中，是否包含并发不安全的代码了。\n 5.使用函数的正确姿势 “函数是一等的公民”，函数类型它是一种对一组输入、输出进行模板化的重要工具；函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等。\n只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可以说它们是一样的函数，各个参数名称、结果的名称、函数的名称(调用函数时给定的标识符)不能算作函数签名的一部分。\n函数参数原则：既不要把你程序的细节暴露给外界，也尽量不要让外界的变动影响到你的程序。\n所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是它的副本。\n函数类型 声明函数类型type operate func(x, y int) int 它有两个参数和一个结果，都是int类型。\n函数类型属于引用类型，零值是nil。\n匿名函数 op := func(x, y int) int { return x + y } 高阶函数与闭包 高阶函数条件\n 接受其他的函数作为参数传入\n 把其他的函数作为结果返回\n 严格来说，函数的名称也不能算作函数签名的一部分，它只是我们在调用函数时，需要给定的标识符而已。\n6.结构体及其方法的使用法门 Go语言中根本没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的组合，见官方解释 https://golang.org/doc/faq#inheritance\n 面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。\n 结构体接收者 接收者声明就是在关键字func和方法名称之间的圆括号包裹起来的内容，其中必须包含确切的名称和类型字面量。\nfunc (ac AnimalCategory) String() string { .... } 上面代码的接收者声明可以看出它隶属于AnimalCategory类型，方法隶属的类型其实并不局限于结构体类型，但必须是某个自定义的数据类型，并且不能是任何接口类型。在Go语言中，我们可以通过为一个类型编写名为String的方法，来自定义该类型的字符串表示形式。这个String方法不需要任何参数声明，但需要有一个string类型的结果声明。\n 一个数据类型关联的所有方法，共同组成了该类型的方法集合。同一个方法集合中的方法不能出现重名。并且，如果它们所属的是一个结构体类型，那么它们的名称与该类型中任何字段的名称也不能重复。\n 我们可以把结构体类型中的一个字段看作是它的一个属性或者一项数据，再把隶属于它的一个方法看作是附加在其中数据之上的一个能力或者一项操作。将属性及其能力（或者说数据及其操作）封装在一起，是面向对象编程（object-oriented programming）的一个主要原则。\n Go语言摄取了面向对象编程中的很多优秀特性，同时也推荐这种封装的做法。从这方面看，Go语言其实是支持面向对象编程的，但它选择摒弃了一些在实际运用过程中容易引起程序开发者困惑的特性和规则。\n 嵌入字段 嵌入字段是其声明中只有类型而没有名称的字段，它可以以一种很自然的方式为被嵌入的类型带来新的属性和能力。但是需要小心可能产生“屏蔽”现象的地方，尤其是当存在多个嵌入字段或者多层嵌入的时候。“屏蔽”现象可能会让你的实际引用与你的预期不符。\ntype Animal struct { scientificName string AnimalCategory //嵌入字段 or 匿名字段,相当于此类型变量的名称后跟“.”,嵌入字段的类型既是类型也是名称。 } 类型组合 类型之间的组合采用的是非声明的方式，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。组合要比继承更加简洁和清晰；\n值方法和指针方法区别 值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型。\n 而指针方法的接收者，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内对该副本指向的值进行修改，却一定会体现在原值上。\n 一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。\n 7.接口类型的合理运用 在Go语言的语境中，当我们在谈论“接口”的时候，一定指的是接口类型。因为接口类型与其他数据类型不同，它是没法被实例化的，既不能通过调用new函数或make函数创建出一个接口类型的值，也无法用字面量来表示一个接口类型的值。通过关键字type和interface，我们可以声明出接口类型。\n接口类型声明中的这些方法所代表的就是该接口的方法集合。一个接口的方法集合就是它的全部特征。对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征（即全部的方法），那么它就一定是这个接口的实现类型。\n鸭子类型 在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，由\u0026quot;当前方法和属性的集合\u0026quot;决定。这是一种无侵入式的接口实现方式。详细了解：https://baike.baidu.com/item/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\n判断方法是否被实现 两个方法的签名需要完全一致\n 两个方法的名称要一模一样\n 动态类型 type Pet interface { SetName(name string) Name() string Category() string } dog := Dog{\u0026quot;little pig\u0026quot;} var pet Pet = \u0026amp;dog 比如，我们把取址表达式\u0026amp;dog的结果值赋给了变量pet，这时这个结果值就是变量pet的动态值，而此结果值的类型*Dog就是该变量的动态类型。变量pet，我们赋给它的值可以被叫做它的实际值（也称动态值），而该值的类型可以被叫做这个变量的实际类型（也称动态类型）。\n动态类型这个叫法是相对于静态类型而言的。对于变量pet来讲，它的静态类型就是Pet，并且永远是Pet，但是它的动态类型却会随着我们赋给它的动态值而变化。在我们给一个接口类型的变量赋予实际的值之前，它的动态类型是不存在的。\n当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存储在一个专用的数据结构中。这个专用的数据结构在Go语言的runtime包叫做iface。iface的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径，等等。总之,接口变量被赋予动态值的时候，存储的是包含了这个动态值的副本的一个结构更加复杂的值。\n接口类型本身是无法被值化的。在我们赋予它实际的值之前，它的值一定会是nil，这也是它的零值。除非我们只声明而不初始化，或者显式地赋给它nil，否则接口变量的值就不会为nil。\n接口组合 Go语言团队鼓励我们声明体量较小的接口，并建议我们通过接口间的组合来扩展程序、增加程序的灵活性。这是因为相比于包含很多方法的大接口而言，小接口可以更加专注地表达某一种能力或某一类特征，同时也更容易被组合在一起。\n接口类型间的嵌入也被称为接口的组合。接口类型间的嵌入会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此。因此，接口的组合根本不可能导致“屏蔽”现象的出现。\n8.关于指针的有限操作 从传统意义上说，指针是一个指向某个确切的内存地址的值。\ntype struct Dog{ name string } func (dog *Dog) SetName(name string) { dog.name = name } func New(name string) Dog { return Dog{name} } 【1】New(\u0026quot;cat\u0026quot;).SetName(\u0026quot;miao miao\u0026quot;) //我们可以在一个基本类型的值上调用它的指针方法，这是因为Go语言会自动地帮我们转译，但是New`函数所得到的结果值属于临时结果 无法取址导致编译报错 【2】 dog := Dog{\u0026quot;little dog\u0026quot;} dog.SetName(\u0026quot;monster\u0026quot;) //Dog类型的变量dog，被自动地转译为(\u0026amp;dog).SetName(\u0026quot;monster\u0026quot;)，即：先取dog的指针值，再在该指针值上调用SetName方法。 从例子代码看：对于基本类型Dog来说，*Dog就是它的指针类型。而对于一个Dog类型，值不为nil的变量dog，取址表达式\u0026amp;dog的结果就是该变量的值（也就是基本值）的指针值。如果一个方法的接收者是*Dog类型的，那么该方法就是基本类型Dog的指针方法。\n可以代表指针有哪些 在Go语言中 uintptr`类型可以代表“指针”，该类型实际上是一个数值类型，也是Go语言内建的数据类型之一。根据当前计算机的计算架构的不同，它可以存储32位或64位的无符号整数，可以代表任何指针的位（bit）模式，也就是原始的内存地址。\nGo语言标准库中的unsafe包。``unsafe.Pointer也代表了“指针”，表示任何指向可寻址的值的指针，同时它也是前面提到的指针值和uintptr`值之间的桥梁。通过它，我们可以在这两种值之上进行双向的转换——可寻址的（addressable）。\n哪些值是不可寻址 常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是不可变的。由于Go语言中的字符串值也是不可变的，所以对于一个字符串类型的变量来说，基于它的索引或切片的结果值也都是不可寻址的。\n算术操作的结果值属于一种临时结果,是不可寻址的。针对数组值、切片值或字典值的字面量的表达式会产生临时结果。这主要因为变量的值本身就不是“临时的”。对比而言，值字面量在还没有与任何变量（或者说任何标识符）绑定之前是没有落脚点的，我们无法以任何方式引用到它们。这样的值就是“临时的”。\n 一个需要特别注意的例外是，对切片字面量的索引结果值是可寻址的。因为不论怎样，每个切片值都会持有一个底层数组，而这个底层数组中的每个元素值都是有一个确切的内存地址的。\n如果针对的是数组类型或切片类型的变量，那么索引或切片的结果值就都不属于临时结果了，是可寻址的。\n如果我们把临时结果赋给一个变量，那么它就是可寻址的了。如此一来，取得的指针指向的就是这个变量持有的那个值了。\n Go语言中以下是不可寻址\n 常量的值。 基本类型值的字面量。 算术操作的结果值。 对各种字面量的索引表达式和切片表达式的结果值。不过有一个例外，对切片字面量的索引结果值却是可寻址的。 对字符串变量的索引表达式和切片表达式的结果值。 对字典变量的索引表达式的结果值。 函数字面量和方法字面量，以及对它们的调用表达式的结果值。 结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值。 类型转换表达式的结果值。 类型断言表达式的结果值。 接收表达式的结果值。 不可寻址的判断方法\n 不可变的值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。 绝大多数被视为临时结果的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。 若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。 不可寻址的值使用限制\n 无法使用取址操作符\u0026amp;获取它们的指针了。 对不可寻址的值施加取址操作都会使编译器报错。\n Go语言中的++和--并不属于操作符，只要在++或--的左边添加一个表达式，就可以组成一个自增语句或自减语句，这个表达式的结果值必须是可寻址的。\n 特殊情况\n虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。\n在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。\n在带有range子句的for语句中，在range关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。\n Go语言中的常用表达式有以下几种。 用于获得某个元素的索引表达式。 用于获得某个切片（片段）的切片表达式。 用于访问某个字段的选择表达式。 用于调用某个函数或方法的调用表达式。 用于转换值的类型的类型转换表达式。 用于判断值的类型的类型断言表达式。 向通道发送元素值或从通道那里接收元素值的接收表达式。 使用unsafe.Pointer操纵可寻址的值 利用unsafe.Pointer的中转和uintptr的底层操作来操纵类型值，它可以绕过Go语言的编译器和其他工具的重重检查，并达到潜入内存修改数据的目的。这并不是一种正常的编程手段，很有可能造成安全隐患。\n我们总是应该优先使用常规代码包中提供的API去编写程序，当然也可以把像reflect以及go/ast这样的代码包作为备选项。作为上层应用的开发者，请谨慎地使用unsafe包中的任何程序实体。\nunsafe.Pointer的中转和uintptr的转换规则：\n 一个指针值（比如*Dog类型的值）可以被转换为一个unsafe.Pointer类型的值，反之亦然。 一个uintptr类型的值也可以被转换为一个unsafe.Pointer类型的值，反之亦然。 一个指针值无法被直接转换成一个uintptr类型的值，反过来也是如此。 例：\ndog := Dog{\u0026quot;little pig\u0026quot;} dogP := \u0026amp;dog //取出了它的指针值 dogPtr := uintptr(unsafe.Pointer(dogP)) namePtr := dogPtr + unsafe.Offsetof(dogP.name) //起始存储地址 + 偏移量，以字节为单位 nameP := (*string)(unsafe.Pointer(namePtr)) // 转换成*string`类型的值 9.go语句及其执行规则 Go语言编程提倡:不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。\n struct{}类型值的表示法只有一个，即：struct{}{}。并且，它占用的内存空间是0`字节。确切地说，这个值在整个Go程序中永远都只会存在一份。虽然我们可以无数次地使用这个值字面量，但是用到的却都是同一个值。\n 关键词: sleep、chan struct{}、sync.WaitGroup、自旋（spinning）\n 进程\u0026amp;线程 主线程之外的其他线程都只能由代码显式地创建和销毁。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。系统级线程由Go语言的运行时（runtime）系统帮助我们自动地创建和销毁。\nGo语言不但有着独特的并发编程模型，以及用户级线程goroutine，还拥有强大的用于调度goroutine、对接系统级线程的调度器。这个调度器是Go语言运行时系统的重要组成部分，它主要负责统筹调配Go并发编程模型中的三个主要元素，即：G（goroutine的缩写）、P（processor的缩写）和M（machine的缩写）。\n其中的M指代的就是系统级线程。而P指的是一种可以承载若干个G，且能够使这些G适时地与M进行对接，并得到真正运行的中介。\ngoroutine 主goroutine的go函数就是那个作为程序入口的main函数。\ngo函数真正被执行的时间，总会与其所属的go语句被执行的时间不同。当程序执行到一条go`语句的时候，Go语言的运行时系统，会先试图从某个存放空闲的G的队列中获取一个G（也就是goroutine），队列中的G总是会按照先入先出的顺序，它只有在找不到空闲G的情况下才会去创建一个新的G。这也是为什么我总会说“启用”一个goroutine，而不说“创建”一个goroutine的原因。已存在的goroutine总是会被优先复用。\n byte类型是uint8类型的别名类型\n 10.if语句、for语句和switch语句 if语句、for语句和switch`语句都属于Go语言的基本流程控制语句。\n 关键词: 类型switch语句\n for range nums := [...]int{1,2,3,4,5,6} maxIndex := len(nums) - 1 for i,meta := range nums { if i == maxIndex { num[0] += meta } else { number[i+1] += meta } } fmt.Println(nums) 当for语句被执行的时候，在range关键字右边的numbers1会先被求值。range表达式的结果值可以是数组、数组的指针、切片、字符串、字典或者允许接收操作的通道中的某一个，并且结果值只能有一个。\n这里需要注意两点：\n range表达式只会在for语句开始执行时被求值一次，无论后边会有多少次迭代； range表达式的求值结果会被复制，也就是说，被迭代的对象是range表达式结果值的副本而不是原值。 switch 在Go语言中，只有类型相同的值之间才有可能被允许进行判等操作。如果switch表达式的结果值是无类型的常量，比如1 + 3的求值结果就是无类型的常量4，那么这个常量会被自动地转换为此种常量的默认类型的值，比如整数4的默认类型是int，又比如浮点数3.14的默认类型是float64。\nswitch的case表达式的所有子表达式的结果值都是要与switch表达式的结果值判等的，它们的类型必须相同或者能够都统一到switch表达式的结果类型。\nswitch语句会进行有限的类型转换，但肯定不能保证这种转换可以统一它们的类型。还要注意，如果这些表达式的结果类型有某个接口类型，那么一定要小心检查它们的动态值是否都具有可比性（或者说是否允许判等操作）,如果不是，虽然不会造成编译错误，但是后果会更加严重：引发panic（也就是运行时恐慌）。\nswitch语句在case子句的选择上是具有唯一性的。 switch语句不允许case表达式中的子表达式结果值存在相等的情况，不论这些结果值相等的子表达式，是否存在于不同的case表达式中，都会是这样的结果。\n11.错误处理 error类型其实是一个接口类型，也是一个Go语言的内建类型。\n 关键词:卫述语句、最小化访问权限\n 怎样判断一个错误值具体代表的是哪一类错误？\n 对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型switch语句来判断；\n如：os包中的几个代表错误的类型os.PathError、os.LinkError、os.SyscallError和os/exec.Error来说\n 对于已有相应变量且类型相同的一系列错误值，一般直接使用判等操作来判断；\n 对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来做判断。\n Go语言中处理错误的最基本方式，这涉及了函数结果列表设计、errors.New函数、卫述语句以及使用打印函数输出错误值。构建错误值体系的基本方式有两种，即：创建立体的错误类型体系和创建扁平的错误值列表。用类型建立起树形结构的错误体系，用统一字段建立起可追根溯源的链式错误关联。\npanic 在大多数操作系统中，只要退出状态码不是0，都意味着程序运行的非正常结束。在Go语言中，因panic导致程序结束运行的退出状态码一般都会是2。panic详情会在控制权传播的过程中，被逐渐地积累和完善，并且，控制权会一级一级地沿着调用栈的反方向传播至顶端。当一个panic发生时，如果我们不施加任何保护措施，那么导致的直接后果就是程序崩溃\nrecover Go语言的内建函数recover专用于恢复panic，或者说平息运行时恐慌。recover函数无需任何参数，并且会返回一个空接口类型的值。\nfunc main() { fmt.Println(\u0026quot;Enter function main.\u0026quot;) defer func(){ fmt.Println(\u0026quot;Enter defer function.\u0026quot;) if p := recover(); p != nil { fmt.Printf(\u0026quot;panic: %s\\n\u0026quot;, p) } fmt.Println(\u0026quot;Exit defer function.\u0026quot;) }() // 引发panic。 panic(errors.New(\u0026quot;something wrong\u0026quot;)) fmt.Println(\u0026quot;Exit function main.\u0026quot;) } defer 当一个函数即将结束执行时，其中的写在最下边的defer函数调用会最先执行，其次是写在它上边、与它的距离最近的那个defer函数调用，以此类推，最上边的defer函数调用会最后一个执行。 同一条defer语句每被执行一次，其中的defer函数调用就会产生一次，而且，这些函数调用同样不会被立即执行。\n在defer语句每次执行的时候，Go语言会把它携带的defer函数及其参数值另行存储到一个链表中。这个链表与该defer语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈。这正是我说“defer函数调用与其所属的defer语句的执行顺序完全相反”的原因了。\n四：Go语言进阶技术 1.测试的基本规则和流程 测试源码文件的主名称应该以被测源码文件的主名称为前导，并且必须以“_test”为后缀。例如，demo.go 测试源码文件的名称是demo_test.go。\nGo语言对测试函数的名称和签名都有哪些规定？\n 对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。 对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。 对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。 go test基本规则和主要流程的 只有测试源码文件的名称对了，测试函数的名称和签名也对了，当我们运行go test命令的时候，其中的测试代码才有可能被运行。\n go test命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，以及判断我们给予的标记是否合法，等等。\n 在准备工作顺利完成之后，go test命令就会针对每个被测代码包，依次地进行构建、执行包中符合要求的测试函数，清理临时文件，打印测试结果。这就是通常情况下的主要测试流程。\n 为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试，只不过，在最后打印测试结果的时候，它会依照我们给定的顺序逐个进行，这会让我们感觉到它是在完全串行地执行测试流程。\n由于并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的。更具体地说，只有在所有构建步骤都做完之后，go test命令才会真正地开始进行性能测试。\n并且，下一个代码包性能测试的进行，总会等到上一个代码包性能测试的结果打印完成才会开始，而且性能测试函数的执行也都会是串行的。\n 2.并发同步变成 2.1.sync.Mutex与sync.RWMutex 共享资源与一致性 相比于Go语言宣扬的“用通讯的方式共享数据”，通过共享数据的方式来传递信息和协调线程运行的做法其实更加主流，毕竟大多数的现代编程语言，都是用后一种方式作为并发编程的解决方案的。\n一旦数据被多个线程共享，那么就很可能会产生争用和冲突的情况。这种情况也被称为竞态条件（race condition），这往往会破坏共享数据的一致性。共享数据的一致性代表着某种约定，即：多个线程对共享数据的操作总是可以达到它们各自预期的效果。\n同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。\n由于这样的数据块和代码块的背后都隐含着一种或多种资源（比如存储资源、计算资源、I/O资源、网络资源等等），所以我们可以把它们看做是共享资源，或者说共享资源的代表。我们所说的同步其实就是在控制多个线程对共享资源的访问。\n临界区 多个并发运行的线程对这个共享资源的访问是完全串行的。只要一个代码片段需要实现对共享资源的串行化访问，就可以被视为一个临界区（critical section），也就是说，由于要访问到资源而必须进入的那个区域。\n互斥锁 在Go语言中我们最常用的同步工具当属互斥量（mutual exclusion，简称mutex）。sync包中的Mutex就是与其对应的类型，该类型的值可以被称为互斥量或者互斥锁。一个互斥锁可以被用来保护一个临界区或者一组相关临界区。我们可以通过它来保证，在同一时刻只有一个goroutine处于该临界区之内。\n互斥锁可以看作是针对某一个临界区或某一组相关临界区的唯一访问令牌。\n使用互斥锁的注意事项如下：\n 不要重复锁定互斥锁； 不要忘记解锁互斥锁，必要时使用defer语句； 不要对尚未锁定或者已解锁的互斥锁解锁； 不要在多个函数之间直接传递互斥锁。 死锁：指的就是当前程序中的主goroutine，以及我们启用的那些goroutine都已经被阻塞。这些goroutine可以被统称为用户级的goroutine。这就相当于整个程序都已经停滞不前了。对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的goroutine的。这个goroutine所执行的流程，会一直停滞在调用该互斥锁的Lock方法的那行代码上。直到该互斥锁的Unlock方法被调用\n我们一定要尽量避免这种情况的发生。而最简单、有效的方式就是让每一个互斥锁都只保护一个临界区或一组相关临界区。在这个前提之下，我们还需要注意，对于同一个goroutine而言，既不要重复锁定一个互斥锁，也不要忘记对它进行解锁。\n 读写锁 读写锁是读/写互斥锁的简称。在Go语言中，读写锁由sync.RWMutex类型的值代表。与sync.Mutex类型一样，这个类型也是开箱即用的。\n读写锁是把对共享资源的“读操作”和“写操作”区别对待了。它可以对这两种操作施加不同程度的保护。换句话说，相比于互斥锁，读写锁可以实现更加细腻的访问控制。\n一个读写锁中实际上包含了两个锁，即：读锁和写锁。sync.RWMutex类型中的Lock方法和Unlock方法分别用于对写锁进行锁定和解锁，而它的RLock方法和RUnlock方法则分别用于对读锁进行锁定和解锁。\n另外，对于同一个读写锁来说有如下规则。\n 在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的goroutine。 在写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的goroutine。 在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的goroutine。 在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的goroutine。 2.2.条件变量 条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用。\n条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。\n条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。\n条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。\n发送 lock.Lock() for mailbox == 1 { sendCond.Wait() } mailbox = 1 lock.Unlock() recvCond.Signal() 接收 lock.RLock() for mailbox == 0 { recvCond.Wait() } mailbox = 0 lock.RUnlock() sendCond.Signal() 条件变量的Wait方法主要做了四件事。\n 把调用它的goroutine（也就是当前的goroutine）加入到当前条件变量的通知队列中。 解锁当前的条件变量基于的那个互斥锁。 让当前的goroutine处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个goroutine就会阻塞在调用这个Wait方法的那行代码上。 如果通知到来并且决定唤醒这个goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的goroutine就会继续执行后面的代码了。 条件变量的Signal方法和Broadcast方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的goroutine，而后者的通知却会唤醒所有为此等待的goroutine。\n条件变量的Wait方法总会把当前的goroutine添加到通知队列的队尾，而它的Signal方法总会从通知队列的队首开始，查找可被唤醒的goroutine。所以，因Signal方法的通知，而被唤醒的goroutine一般都是最早等待的那一个。\n2.3.原子操作 sync/atomic包中提供了几种原子操作？可操作的数据类型又有哪些？\nsync/atomic包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称CAS）、加载（load）、存储（store）和交换（swap）。\n数据类型有：int32、int64、uint32、uint64、uintptr，atomic.Value，以及unsafe包中的Pointer。不过，针对unsafe.Pointer类型，该包并未提供进行原子加法操作的函数。\n原子值使用建议。\n 不要把内部使用的原子值暴露给外界。比如，声明一个全局的原子变量并不是一个正确的做法。这个变量的访问权限最起码也应该是包级私有的。 如果不得不让包外，或模块外的代码使用你的原子值，那么可以声明一个包级私有的原子变量，然后再通过一个或多个公开的函数，让外界间接地使用到它。注意，这种情况下不要把原子值传递到外界，不论是传递原子值本身还是它的指针值。 如果通过某个函数可以向内部的原子值存储值的话，那么就应该在这个函数中先判断被存储值类型的合法性。若不合法，则应该直接返回对应的错误值，从而避免panic的发生。 如果可能的话，我们可以把原子值封装到一个数据类型中，比如一个结构体类型。这样，我们既可以通过该类型的方法更加安全地存储值，又可以在该类型中包含可存储值的合法类型信息。 怎样用好sync/atomic.Value\n 一旦atomic.Value类型的值（以下简称原子值）被真正使用，它就不应该再被复制了。 不能用原子值存储nil。也就是说，我们不能把nil作为参数值传入原子值的Store方法，否则就会引发一个panic。 我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。 2.4.sync.WaitGroup sync.WaitGroup类型（以下简称WaitGroup类型）是开箱即用的，是并发安全的。它一旦被真正使用就不能被复制了。它拥有三个指针方法：Add、Done和Wait。你可以想象该类型中有一个计数器，它的默认值是0。我们可以通过调用该类型值的Add方法来增加、Done方法减一操作、Wait方法阻塞当前的goroutine，直到其所属值中的计数器归零。\nWaitGroup值的使用禁忌，即：不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的goroutine中执行。换句话说，要杜绝对同一个WaitGroup值的两种操作的并发执行。\n2.5.sync.Onece sync.Once类型（以下简称Once类型）也属于结构体类型，是开箱即用和并发安全的。由于这个类型中包含了一个sync.Mutex类型的字段，复制该类型的值也会导致功能的失效。\nOnce类型的Do方法只接受一个参数，这个参数的类型必须是func()，即：无参数声明和结果声明的函数。该方法的功能是只执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数。\nOnce类型中还有一个名叫done的uint32类型的字段。它的作用是记录其所属值的Do方法被调用的次数。不过，该字段的值只可能是0或者1。一旦Do方法的首次调用完成，它的值就会从0变为1。\n这个Do方法在功能方面的两个特点\n第一个特点，由于Do方法只会在参数函数执行结束之后把done字段的值变为1，因此，如果参数函数的执行需要很长时间或者根本就不会结束（比如执行一些守护任务），那么就有可能会导致相关goroutine的同时阻塞。\n第二个特点，Do方法在参数函数执行结束后，对done字段的赋值用的是原子操作，并且，这一操作是被挂在defer语句中的。因此，不论参数函数的执行会以怎样的方式结束，done字段的值都会变为1。\n2.6.context.Context context.Context类型（以下简称Context类型）是在Go 1.7发布时才被加入到标准库的。而后，标准库中的很多其他代码包都为了支持它而进行了扩展，包括：os/exec包、net包、database/sql包，以runtime/pprof包和runtime/trace`包，等等。\nContext类型它是一种非常通用的同步工具。它的值不但可以被任意地扩散，而且还可以被用来传递额外的信息和信号。Context类型可以提供一类代表上下文的值。此类值是并发安全的，也就是说它可以被传播给多个goroutine。\ncontext.Background、context.WithCancel、context.WithDeadline、context.WithTimeout和context.WithValue。\nContext类型的实际值大体上分为三种，即：根Context值、可撤销的Context值和含数据的Context值。所有的Context值共同构成了一颗上下文树。这棵树的作用域是全局的，而根Context值就是这棵树的根。它是全局唯一的，并且不提供任何额外的功能。\n可撤销的Context值又分为：只可手动撤销的Context值，和可以定时撤销的Context值。\n2.7.sync.Pool sync.Pool类型可以被称为临时对象池，它的值可以被用来存储临时的对象。与Go语言的很多同步工具一样，sync.Pool类型也属于结构体类型，它的值在被真正使用之后，就不应该再被复制了。\n我们可以把临时对象池当作针对某种数据的缓存来用。sync.Pool类型只有两个方法——Put和Get。Put用于在当前的池中存放临时对象，它接受一个interface{}类型的参数；而Get则被用于从当前的池中获取临时对象，它会返回一个interface{}类型的值。\n为什么说临时对象池中的值会被及时地清理掉？\n因为，Go语言运行时系统中的垃圾回收器，在每次开始执行之前，都会对所有已创建的临时对象池中的值进行全面地清除。\n临时对象池存储值所用的数据结构\n在临时对象池中，有一个多层的数据结构。这个数据结构的顶层，我们可以称之为本地池列表，不过更确切地说，它是一个数组。这个列表的长度，总是与Go语言调度器中的P的数量相同，原因是为了分散并发程序的执行压力，这里所说的压力包括了存储和性能两个方面。\n在每个本地池中，都包含一个私有的临时对象和一个共享的临时对象列表。前者只能被其对应的P所关联的那个goroutine中的代码访问到，而后者却没有这个约束。从另一个角度讲，前者用于临时对象的快速存取，而后者则用于临时对象的池内共享。\n从sync.Pool中获取临时对象的步骤\n2.8.sync.Map Go语言官方终于在2017年发布的Go 1.9中，正式加入了并发安全的字典类型sync.Map。这个字典类型提供了一些常用的键值存取操作方法，并保证了这些操作的并发安全。它们的算法复杂度与map类型一样都是O(1)的。\n使用锁就意味着要把一些并发的操作强制串行化。这往往会降低程序的性能，尤其是在计算机拥有多个CPU核心的情况下。因此，能用原子操作就不要用锁，不过这很有局限性，毕竟原子只能对一些基本的数据类型提供支持。\n并发安全字典对键的类型有要求吗？\n有要求。键的实际类型不能是函数类型、字典类型和切片类型。我们必须保证键的类型是可比较的（或者说可判等的）。我们可以先通过调用reflect.TypeOf函数得到一个键值对应的反射类型值（即：reflect.Type类型的值），然后再调用这个值的Comparable方法，得到确切的判断结果。\n保证并发安全字典中的键和值的类型正确性\n 方案一，在编码时就完全确定键和值的类型，然后利用Go语言的编译器帮我们做检查。\ntype IntStrMap struct { m sync.Map } 方案二，接受动态的类型设置，并在程序运行的时候通过反射操作进行检查。\ntype ConcurrentMap struct { m sync.Map keyType reflect.Type valueType reflect.Type } 并发安全字典如何做到尽量避免使用锁？\nsync.Map类型在内部使用了大量的原子操作来存取键和值，并使用了两个原生的map作为存储介质。\n其中一个原生map被存在了sync.Map的read字段中，该字段是sync/atomic.Value类型的。 这个原生字典可以被看作一个快照，它总会在条件满足时，去重新保存所属的sync.Map值中包含的所有键值对。\n另一个原生字典由它的dirty字段代表。 它存储键值对的方式与read字段中的原生字典一致，它的键类型也是interface{}，并且同样是把值先做转换和封装后再进行储存的。我们暂且把它称为脏字典。\n 注意，脏字典和只读字典如果都存有同一个键值对，那么这里的两个键指的肯定是同一个基本值，对于两个值来说也是如此。\n **只读字典和脏字典之间是会互相转换的。**在脏字典中查找键值对次数足够多的时候，sync.Map会把脏字典直接作为只读字典，保存在它的read字段中，然后把代表脏字典的dirty字段的值置为nil。在这之后，一旦再有新的键值对存入，它就会依据只读字典去重建脏字典。这个时候，它会把只读字典中已被逻辑删除的键值对过滤掉。\n9.unicode与字符编码 10.strings包与字符串操作 11.bytes包与字节串操作 12.io包中的接口和工具 13.bufio包中的数据类型 14.使用os包中的API 15.访问网络服务 16.基于HTTP协议的网络服务 17.程序性能分析基础 五：附录 1.go命令 go get 命令go get会自动从一些主流公用代码仓库（比如GitHub）下载目标代码包，并把它们安装到环境变量GOPATH包含的第1工作区的相应目录中。如果存在环境变量GOBIN，那么仅包含命令源码文件的代码包会被安装到GOBIN指向的那个目录。\n最常用的几个标记有下面几种。\n -u：下载并安装代码包，不论工作区中是否已存在它们。 -d：只下载代码包，不安装代码包。 -fix：在下载代码包后先运行一个用于根据当前Go语言版本修正代码的工具，然后再安装代码包。 -t：同时下载测试所需的代码包。 -insecure：允许通过非安全的网络协议下载和安装代码包。HTTP就是这样的协议。 go build 默认不会编译目标代码包所依赖的那些代码包。当然，如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。\n-a 强制编译,不但目标代码包总是会被编译，它依赖的代码包也总会被编译\n-i 不但要编译依赖的代码包，还要安装它们的归档文件\n-v 可以看到go build命令编译的代码包的名称\n-x 这样可以看到go build命令具体都执行了哪些操作\n-n 可以只查看具体操作而不执行它们\ngo install 1.go基础知识 2.github优秀项目导图 【clash】https://github.com/Dreamacro/clash\n3.问题记录 1）Main file has non-main package or doesn\u0026rsquo;t contain main function 如果为程序入口的main方法文件，则包应为package main,注意与目录无关。\n","dateformatted":"29, May 2022","dateiso":"2022-05-29T15:42:33Z","ref":"/%E8%AF%BBgo%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2/","summary":"\n 一：概要 1.1.参考 【GO编程语言规范】https://golang.google.cn/ref/spec\n【GO命令】https://golang.google.cn/cmd/\n【环境设置】https://www.liwenzhou.com/posts/Go/install_go_dev_old/\n【Unicode】https://home.unicode.org/\n二：Go语言基础知识 理解Go语言的开发环境配置、常用源码文件写法，以及程序实体（尤其是变量）及其相关的各种概念和编程技巧（比如类型推断、变量重声明、可重名变量、类型断言、类型转换、别名类型和潜在类型等）。\n1.工作区和GOPATH GOROOT：Go语言安装根目录的路径，也就是GO语言的安装路径。\nGOPATH：若干工作区目录的路径。是我们自己定义的工作空间。\n你可以把GOPATH简单理解成Go语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表Go语言的一个工作区（workspace）\ngo mod init qiaomingzi.github.io/m/v1 GOBIN：GO程序生成的可执行文件（executable file）的路径。\n2.源码文件 2.1 运行程序 使用 go run 命令执行go源码main文件\n\n","tags":["GO"],"title":"读[GO语言核心36讲]"},{"content":"all.bat all.rc archive bootstrap.bash bufio buildall.bash builtin bytes clean.bash clean.bat clean.rc cmd cmp.bash compress container context crypto database debug embed encoding errors expvar flag fmt 格 式 描 述 %v 按值的本来值输出 %+v 在 %v 基础上，对结构体字段名和值进行展开 %#v 输出 Go 语言语法格式的值 %T 输出 Go 语言语法格式的类型和值 %% 输出 % 本体 %b 整型以二进制方式显示 %o 整型以八进制方式显示 %d 整型以十进制方式显示 %x 整型以十六进制方式显示 %X 整型以十六进制、字母大写方式显示 %U Unicode 字符 %f 浮点数 %p 指针，十六进制方式显示 go go.mod go.sum hash html image index internal io log make.bash make.bat Make.dist make.rc math mime net os path plugin race.bash race.bat README.vendor reflect regexp run.bash run.bat run.rc runtime sort strconv strings sync syscall testdata testing text time unicode unsafe vendor ","dateformatted":"17, May 2022","dateiso":"2022-05-17T21:34:28+08:00","ref":"/go-sdk/","summary":"\n all.bat all.rc archive bootstrap.bash bufio buildall.bash builtin bytes clean.bash clean.bat clean.rc cmd cmp.bash compress container context crypto database debug embed encoding errors expvar flag fmt 格 式 描 述 %v 按值的本来值输出 %+v 在 %v 基础上，对结构体字段名和值进行展开 %#v 输出 Go 语言语法格式的值 %T 输出 Go 语言语法格式的类型和值 %% 输出 % 本体 %b 整型以二进制方式显示 %o 整型以八进制方式显示 %d 整型以十进制方式显示 %x 整型以十六进制方式显示 %X 整型以十六进制、字母大写方式显示 %U Unicode 字符 %f 浮点数 %p 指针，十六进制方式显示 go go.\n\n","tags":["GO"],"title":"GO SDK"},{"content":"一：参考 [jemeter] https://jmeter.apache.org/\n二：概要 三：jemeter使用 3.1 启动 1）配置 jemeter/bin/setenv.bat set JVM_ARGS=-Xms1024m -Xmx1024m -Dpropname=value 2)启动方式 jmeter.bat run JMeter (in GUI mode by default) jmeterw.cmd run JMeter without the windows shell console (in GUI mode by default) jmeter-n.cmd drop a JMX file on this to run a CLI mode test jmeter-n-r.cmd drop a JMX file on this to run a CLI mode test remotely jmeter-t.cmd drop a JMX file on this to load it in GUI mode jmeter-server.bat start JMeter in server mode mirror-server.cmd runs the JMeter Mirror Server in CLI mode shutdown.cmd Run the Shutdown client to stop a CLI mode instance gracefully stoptest.cmd Run the Shutdown client to stop a CLI mode instance abruptly 3）启动时参数 jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder] HEAP=\u0026quot;-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m\u0026quot; egg: jmeter -n -t testplan/RedisLock.jmx -l testplan/result/result.txt -e -o testplan/webreport 3.1聚合报告 Label\u0026mdash;-每个请求的名称，比如HTTP请求等\nSamples\u0026mdash;-发给服务器的请求数量\nAverage\u0026mdash;-单个请求的平均响应时间\nMedian\u0026mdash;-50%请求的响应时间\n90%Line\u0026mdash;-90%请求响应时间\n95%Line\u0026mdash;-95%请求响应时间\n99%Line\u0026mdash;-99%请求的响应时间\nMin\u0026mdash;-最小的响应时间\nMax\u0026mdash;-最大的响应时间\nError%\u0026mdash;-错误率=错误的请求的数量/请求的总数\nThroughput\u0026mdash;-吞吐量即表示每秒完成的请求数\nReceived KB/sec\u0026mdash;-每秒从服务器端接收到的数据量\nSent KB/sec\u0026mdash;-每秒从客户端发送的请求的数量\n","dateformatted":"20, March 2022","dateiso":"2022-03-20T15:42:33Z","ref":"/jemeter%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"\n 一：参考 [jemeter] https://jmeter.apache.org/\n二：概要 三：jemeter使用 3.1 启动 1）配置 jemeter/bin/setenv.bat set JVM_ARGS=-Xms1024m -Xmx1024m -Dpropname=value 2)启动方式 jmeter.bat run JMeter (in GUI mode by default) jmeterw.\n\n","tags":["工具"],"title":"jemeter基本使用"},{"content":"\u0026laquo;大风歌\u0026raquo;王立群 大风歌 歌手: 极泷 望华车 市井夺未央 尘沙起 鸿门巧对王 纳贤良 无畏得天下 三章法 垓下定汉疆 大风起兮云飞扬 威加海内兮归故乡 安得猛士兮守四方 大风起兮云飞扬 威加海内兮归故乡 安得猛士兮守四方 守四方 55期：传奇皇帝 公元前202年从山东定陶的一个土台上，一位五十五岁的中年男子，在群臣的欢呼声中，戴上了皇帝冠冕，他就是大汉王朝的开国皇帝刘邦，一个开创了从布衣到皇帝的神话，三年鏖战 摧毁强秦，四载奋斗 战胜项羽，创建了延续400多年的大汉王朝，然而这位不读书的皇帝,却写下了一首大气蓬勃的\u0026laquo;大风歌\u0026raquo;。\n传奇在几个方面 1）出生传奇，2）好喝酒，4）婚姻传奇，50面相，6)经历\n刘邦和吕雉是在泗水亭中的任上，刘邦假“贺钱万“乘酒喝，吕公看中刘邦面相，并许配儿女给刘邦。\n在从江苏押送刑徒到江西骊山过程出现丰西泽纵徒，此后就藏匿芒砀山。\n\u0026laquo;史记\u0026raquo;神话刘邦，就为了体现刘邦不是一般人，通过感生说的人有炎帝、皇帝、颛顼、尧、舜、禹、刘邦，者几个都是大人物。\n刘邦通过三年反秦，四年刘项战争，后面就当了皇帝。\n故事\n1：刘邦母亲刘媪,大湖旁边，做了一场梦\u0026mdash;与神仙相遇，后面就怀孕生下刘邦，面相像蛟龙\u0026laquo;史记.高祖本纪\u0026raquo;，胡子很长，大腿上有72个黑痣。\n2：经常到人家賖酒喝，醉了之后睡觉，两个女老板在刘邦身上隐隐约约现出一条龙，\n3：老先生：相者夫人 因而皆似君 君相贵不可言，回曰：诚如父言 不敢望德\n4：刘邦挥剑斩蛇，白帝子化成一条白蛇被赤弟子斩了，\n5：刘邦藏匿芒砀山，吕雉每次都能找到他，因为刘邦头上有一股运气。\n56期：时代玉成 由于发生丰西泽事件，刘邦只能潜伏莽荡山，此时时代正巧赶上陈胜吴广起义 ”等死 死国可乎“，各地纷纷杀县令、郡守起义，\n萧何 曹参让樊哙找刘邦起兵反秦，刘邦取代沛公后，派雍齿守丰邑，后面雍齿叛变，三夺奉邑才夺回；此时陈胜已经开始走下坡路(周文起义军一路凯歌，然后败于章邯，最后节节败退，最后兵败被杀)。\n各地反秦人走了三条路，一：自立为王，树大招风最后都被杀，二：立六国王族后人为王(项梁立了楚国的后裔熊心为王),三：加盟别人刘邦加盟项梁,借兵收复丰邑。\n项梁战死，楚王熊心到彭城就夺了项羽、吕臣兵权并立盟约，\u0026ldquo;先入关折，王之\u0026rdquo;\n57期：西入秦关 此时有两件事情一个是救赵，另一个是灭秦，目前形势是秦军势力很强，楚怀王让宋义当主帅,项羽为副帅北伐；让刘邦为主帅西征。\n刘邦西征：\n1.偷袭陈留 陈留县囤积大量军粮，陈留县令与郦食其是朋友，刘邦与郦食其(li yi ji)内外结合攻下陈留。\n2.智取南阳，由于在洛阳打了败仗，就南下洛阳通过南阳进武关，接收张良、陈恢的建议约降南阳郡\n故事：\n 刘项战争时候，项羽抓住王陵母亲，为了不让其儿子背叛刘邦，在使者的面自杀了，并表示刘邦是个长者。 高阳酒徒郦食其(60多岁) 、刘邦(40多岁)，郦食其问刘邦：你是帮天下灭秦，还是帮助秦来没诸侯， 张良本想加盟景驹，在途中与刘邦巧遇，张良熟悉太公兵法，与刘邦交谈后，只有刘邦听懂张良的兵法。 58期：率先入关 刘邦轻松过了武关，入了陕西，此时赵高杀了秦二世，后面秦王子婴被扶上台后杀了赵高，子婴收集军队在峣关进行拦截。\n刘邦采纳张良建议,通过贿赂秦军守将诱降、虚张声势、攻其不备拿下了峣关；后来秦王又收集最后军队在蓝田决战，最后刘邦战胜，在公元前206年10月纳降秦王子婴，就这样刘邦就进入了咸阳。\n刘邦入咸阳后，接受樊哙、张良等建议 ”忠言逆耳利于行，毒药苦口利于病“等建议，约法三章，还军坝上，争取民心；秦军在三年内灭亡是因为完全失去民心。\n最后刘邦做了间错事就是封堵函谷关，暗喻与项羽作对。此时北上救赵的项羽，杀主帅宋义，后在巨鹿破釜沉舟，战胜了秦军的章邯军团、长城军团，最后到函谷关的时候才知道刘邦把住了函谷关。\n59期：在劫可逃 项羽三次大怒，一是刘邦把住函谷关想做关中王，项羽一怒之下功进入关，二是左司马曹无伤告密,沛公欲望关中，使子婴为相，珍宝尽有之。三是范增的建议，\u0026laquo;史记.项羽本纪\u0026raquo; 沛公居山东时 贪于财货 好美姬 今入关 财物无所取 妇女无所幸 此其志不在小 急击勿失；项羽在巨鹿之战之后奠定了地位，诸侯对项羽都是诚服的，而刘邦没有。\n项羽大怒背后的三大原因，一是自尊受损，二是怀王伤痛，三是项羽对天下有自己的战略，咸阳以西的土地归章邯\u0026ndash;雍王所管。最后项羽并没有用军事解决刘邦，核心原因是项羽没有认识到谁是自己最大的敌人。\n项伯(左伊-左丞相)夜见张良,为义救张良，张良也为义，告知刘邦“沛公奉卮酒为寿，约为婚姻”，\n60期：鸿门脱险 刘邦虽然躲过了兵祸，但是还得卖你对鸿门宴，于是有了一下鸿门说辞：\n刘邦说辞分析：\n1） 与刘邦一起打敌人，项羽在河北打，我在河南打\u0026mdash;\u0026mdash;战友；\n2）表达自己是意外先入关\n3）有小人挑拨离间\u0026mdash;\u0026ndash;(左司马曹无伤,曹无伤是项羽的老战友)，把刘项两家的矛盾话必然为偶然\n项羽回应分析: 表达忏愧、请客吃饭(鸿门宴)、\n范增：1）范增数目项王，举所配玉玦，以示之者三，项王默然不应。\n​ 2）找项庄舞剑\n樊哙：樊哙闯帐 ，为沛公说辞\n最后刘邦逃席, 张良主持断后，计算刘邦回到军中的时长，然后向大王解释，最后送礼；刘邦回营后就杀了曹无伤。\n让刘邦鸿门脱险主要有一下几点：\n1)鸿门说词解除了项羽的思想武装,\n2)项伯的帮忙让项庄的行刺无法进行\n3)樊哙的闯帐转义了宴会的视线\n4)刘邦的逃席避免了节外生枝，\n5)项羽的糊涂(项羽选择霸业，刘邦选择帝业\u0026ndash;独裁)\n五个明白人陪着一个糊涂人喝酒(项羽 项伯 范增 项庄舞剑，张良 刘邦 ) ,后续：陈平使反间计，让项羽 猜疑范曾。\n61期：屈就汉王 三秦大地咸阳以西雍王(章邯)，咸阳以东塞王(司马欣 曾经救过项梁的命),咸阳以北翟王(董翳)\n刘邦封得巴蜀，后让通过项伯争取追封了汉中；在回汉中途中接收张良计谋\u0026quot;王何不烧绝所过栈道 示天下无还心 以固项王意\u0026quot;;\n韩信年轻穷困潦倒(老是到人家蹭饭吃、漂母匀饭吃)，后面参军到了项羽没受重用，就转会到刘邦军中，在要被执行死刑死，被夏侯婴-滕工解救推荐；萧何夜下追韩信(此时27岁)，让刘邦派韩信为大将军，韩信国士无双，\u0026ldquo;王必欲争天下，非信无所与计事也\u0026rdquo;。\n韩信：分析项羽项羽匹夫之勇(力能扛鼎,不会用将)，妇人之仁(看到受伤士兵回落泪，舍不得给有功的人封赏)，失去民心(为人残暴)；给刘邦建议以仁义昭示天下，把城分给功臣，以老兵表率士兵；汉中对策先杀回关中，然后以关中夺取天下。\n62期：还定三秦 刘邦用了韩信的决策，明修栈道，暗度陈仓(陕西宝鸡市)，从公元前206年4月到达汉中，到了8月就杀到关中；刘邦夺下关中的原因章邯战败、刘邦兵盛气、项羽没有出手。\n项梁由于田荣不出兵，自身轻敌最后战败被章邯所杀；田荣在山东齐地把项羽分的三个王(齐王、胶东王、济北王)给杀了，后又联合彭越、陈艅；所以项羽出兵收拾田荣，无力在关注刘邦。\n63期：彭城之战 汉二年公元前205年的春天，刘邦率56万人东出函谷关，攻下西楚国国都彭城，主要又几个原因刘邦兵力众多、军心大振(很多士兵事江苏人)、正义之旗(受三老董工的提示，利用义帝的死进行讨伐)、彭城空虚(项羽带士兵去平叛了)；\n义帝是项梁接受范增的建议，在陈胜死了以后，找到当年的楚怀王孙子熊心，立他为楚怀王，项羽入关后把楚怀王升为义帝。然后就把义帝迁到南方去，最后由黥布派人把义帝给杀了。\n项羽带领3万精兵从萧县进入然后打败了刘邦军队，刘邦失败的原因楚军士气高昂、项羽指挥得当、张良陈平皆无预见、刘邦盲目乐观、联军组织松散、骑兵奔袭步兵，最后刘邦退守荥阳。\n下邑话策,捐出函谷关以东的土地，联合韩信、彭越、黥布(派随何去说服九江王叛变)攻打项羽。\n64期：韩信北伐 魏豹叛汉，后面韩信灭魏(利用明修栈道暗度陈仓的方式，向西开拔到山西的韩城，在少梁渡口偷渡黄河，韩信和曹两个月灭魏)；在韩信灭魏后，刘邦把韩信的精兵挑走补充荥阳的兵力，然后命令韩信继续北伐灭代。山西的中部南部是西魏国，山西的北部是代国。\n韩信翻过太行山攻打赵国，在井陉之战，赵王和陈鮽没有接受李左车的意见(前面深挖战壕，绕后路烧对方粮草辎重)，韩信打听到这个消息后，让两千士兵到对方军营插旗，自己带一万士兵背水列阵，最后大败赵军，此次胜利韩信运用了主客异位、阵型合一、奇正相和；\n韩信请教李左车问题说，当年由一个人在虞国后来虞国灭了，到了秦国，秦国切称霸了，此人并不是在虞国是个笨人，到了秦国变成聪明人了，原因是虞国国君不用他，而秦国国君听他用他的，此人就是百里奚；李左车被韩信的真诚感动，李左车说了两句很有名的话\u0026quot;智者千虑必有一失 愚者千虑必有一得\u0026quot;,陈鮽很熟悉兵法，一次败仗命丢了，而你的强项是取得了一系列的胜率，涉西河、擒魏王、杀夏说、灭代国、井陉之战一个早晨把20万赵军灭了，你的弱项是士兵疲劳，现在最好的方式按兵不动，等休整好了，派精锐部队驻扎到通往燕国的大道上，然后派使者带一封信给燕王，好好说说你的功绩，燕国自然投降，最后果然如李左车所说燕国投降。\n北灭燕东灭齐\u0026mdash;\u0026mdash;\u0026ndash;李左车一语道破韩信的大谋略，北举燕赵，东灭齐，断楚粮道，然和和大王在荥阳相会。\n65期：鏖战荥阳 刘邦时汉二年四月进入彭城，遭到惨败，汉二年五月退守荥阳，郦食其建议在荥阳驻扎，因为荥阳有一个大粮仓是秦朝时候建立起来的\u0026mdash;-叫敖仓，就在黄河边上，建议刘邦应该“据敖仓之栗 守城皋之险”，才能阻击项羽，于是就专门修了一条甬道(两边时墙)来运送粮食。\n张良阻封\u0026mdash;\u0026mdash;\u0026mdash;郦食其建议铸造六国印，封六国后人，为了树立更多项羽的敌人。\n刘邦第一次出逃：\n汉三年五月荥阳城失守，纪信让刘邦快逃，然后假借刘邦车马、衣服，还组织2000名妇女从东门出，让刘邦从西门出去。最后纪信被烧死了，纪信救主这次时第二次，第一次时鸿门宴，当时刘邦带四名大将其中一名就是纪信。\n刘邦化被动为主动的第一仗：\n刘邦从荥阳西门出来先跑到成皋，在从成皋跑回关中，到了关中后刘邦重新组织军队，想再出函谷关和项羽决战，最后被袁生(袁先生)拦住，建议他向南从武关出发到南阳，然后高筑城垒坚守不战，这样项羽就会从荥阳追到南阳，补给线就会从徐州一直扯到南阳(河南)，然后在想办法断项羽的后勤补给线，等补给线断了荥阳城也得到休息了，在回去夺荥阳、成皋。\n项羽的粮道被断:\n彭越在彭城大战前已经参加了刘邦集团，刘邦撤军到荥阳时候，彭越没有跟着撤，而是回到河上也就是濮阳(河南)\u0026mdash;梁国，这时候彭越南下到睢阳(河南商丘)断了项羽的粮道。于是项羽就撤兵回去打彭越，然后派终公给他守荥阳，彭越使出敌进我退，敌退我进的策略。最后由于终公不懂军事被杀，刘邦重新夺回荥阳，于是项羽又重新打回荥阳。\n刘邦第二次出逃：\n这次出逃是让人守着荥阳城，然后刘邦只带了赶车的滕公(夏侯婴)逃了，最后跑到韩信和张耳的大营，趁着他们在睡觉，把精锐抽走留下老弱，命令张耳镇守赵地，让韩信带着老弱残兵取灭齐。\n刘邦化被动为主动的第二仗：\n郑忠(郎中)刘邦随从，建议刘邦分一部分人帮助彭越断粮道，彭越得到支持后一下子就得到睢阳、外黄(河南的民权)等17城，于是项羽的粮道又被断了，项羽不得不从荥阳回兵，这次派大司马曹咎守广武，一再叮嘱守城15天不要应战。刘邦使用了骂人的方法诱导曹咎迎战，最后被刘邦冲垮，曹咎自杀跟随他的司马欣、董翳也自杀，自由钟离沫一个人坚持在战斗，其他全部溃败。此时项羽在攻外黄，攻了许久才功下来，项羽很生气本想屠城里15岁以上的男人，最后被小孩感化，最后听了13岁外黄县令门客儿子的话，最后外黄以东的几座城不战而降。项羽解决粮道问题后听说广武又丢了，于是又得再杀回广武，刘邦的军队听到项羽回城，军队一下子全跑了，于是项羽重新夺回广武，就再广武隔了一个大涧与刘邦对峙。\n刘邦经受的磨难：\n1）甬道被切断\n被动的情况下采用离间计 刘邦给四万斤铜让陈平使反间计钟离眜(联合刘邦攻击项羽然后一起分地)，离间范增使用“以恶食侍项王使者”的方法，最后导致范增辞职，临走时留了一句话“天下事大定矣 君王自为之”，范增在回彭城的路上由于过度生气,背上长了恶疮死在路上。\n66期：韩信破齐 郦食其：\n郦食其先出使齐国，问：天下将要归谁，齐王回曰:天下无所归\n郦食其说：天下归汉， 项王 言而无信，赏罚不公；汉王 与人同利 汉军是神兵天将\n最后：齐王田广，齐相田横信了决定投降，做了两件事 1)齐国撤销战备级别 2)挽留郦食其,好心招待。\n蒯通(韩信是一个辨士)：\n汉王给你下达过灭齐令？ 汉王下令叫你停止进攻了么？你凭什么停止进攻？ “为将数岁 反不如 一竖儒之功乎”\n最后韩信下令进攻齐国，一下子打垮了毫无准备的20万军队，乘胜追击一直追到齐国都城临淄(山东淄博)兵临城下，最后郦食其被烹了，死前留下话：\n韩信打败齐国救兵：\n项羽闻讯韩信破齐,派龙且带20万大军到齐国帮助齐王田广打韩信，有人给龙且建议说：韩信军队远道而来，兵锋正盛，我们不要硬打，应该深挖战壕 坚守城池 暂不出战，然后派一个有号召力的齐国人去散布消息,消息的内容为：1)齐王田广没有死，2)楚国的救兵到了，到那时候已经投降韩信的70个齐城会集体造反，那时候再和韩信决战，这样韩信必败；龙且未采纳建议，主要有两点 1）韩信胆小怕事 2）此次是来救齐国如果不战而降我没有功劳);两军隔着潍水列阵，韩信头一天晚上让士兵用袋子装沙，堵住潍水的上游，第二天韩信在与龙且作战时，假装怯弱逃跑，等龙且的军队一进入潍水中，韩信就下令把沙袋给撤掉，波涛滚滚的河水就把龙且的军队隔成两断，韩信就用以多打少把龙且和头部全部灭掉，然后乘胜把剩余的楚军打败了。\n韩信求封齐王\n文献记载韩信求封两次，韩信自封记载三次，最后刘邦在不情愿的情况下(\u0026ldquo;大丈夫定诸侯 即为真王尔 何以假为\u0026rdquo;)，封了韩信为齐王，然后让韩信来打项羽。\n项羽反应\n恐惧：1）龙且被杀 2)威胁国都粮道 3)汉强楚弱已经形成。\n派武涉游说韩信的四个理由:\n1)汉王贪得无厌\n“非尽吞天下者不修”\n2)汉王不足相信\n3)韩信因项王存在而存在 “项王今日亡 则次取足下”\n4)智者当中立 “三分天下而王之”\n蒯通游说韩信\n韩信的面相不过封侯，单是“相君之背 贵乃不可言”，项羽跟刘邦两家已经精疲力尽，现在的天下主动权在韩信手中，建议你应该三分天下；\n67期：十罪项王 项羽要烹刘邦，项伯阻止“天下大事未定 凡要天下都是舍小家取小家，杀了指挥增加刘邦仇恨”。\n刘邦十罪项王：\n1）负约\n2）杀宋义，自立为上将军\n3）擅劫诸侯兵入关\n4）烧秦宫 挖秦陵 私吞秦陵财宝\n5）杀子婴\n6）坑秦卒 封请将\n7）分封不公 主要有四个人“刘邦 陈馀 田荣 韩信”\n8）逐义帝 夺韩地 王梁楚\n9）杀义帝 嫌疑人“九江王-黥布 临江王 衡山王”\n10）大逆不道\n​ 夫为人臣而弑其主、杀其已降、为政不平 主约不信\n刘邦在涛涛不绝的演说，项羽一箭射中刘邦胸口，造成刘邦重伤。\n68期：圆满收官 刘邦鸿沟议和\n1）派陆贾 失败 2）派侯公 终于把家属给放了，可以没有把说词记录下来，最后封侯公为平国君。\n刘邦撕毁和平协议\n陈平、张良劝刘邦理由：汉已得天下一大半、已统领天下诸侯、楚军兵疲食尽;当前是灭楚最好得时候。\n刘邦本身：志向远大、刘邦付出极大、经营有方；“汉欲西归”不可信。\n汉五年的10月开始追杀项羽，刘邦带20万军队追项羽10万人，项羽杀个回马枪刘邦打个大败，固守淮阳；因为彭越、项羽都没出兵导致刘邦打败，最后刘邦听了张良建议给两位封王，兵共分天下。\n汉五年的12月,垓下合围项羽，项羽战败自杀，项羽在乌江自刎前，把马送给乌江亭长。\n项羽死后刘邦做了几件事:1)封赏功臣 2）招降鲁地 3）哭祭项羽 4）封赏项伯(赐姓 封侯)\n69期：登基称帝 汉五年的12月刘邦在处理完项羽后，就马上到韩信得大营，把韩信得兵权夺了，说明韩信的事情在刘邦心中是个大事，主要是考虑韩信军事才能、部队实力、功劳天下第一；汉六年的元月把韩信从齐王徙封为楚王，分封彭越为梁王。\n刘邦观念的转变,主要是随着地位的转变：求封到分封；从实践中得到好处，主要有两个高人韩信(提出分封这个手段)、张良(解决分谁的问题)；刘邦的目标是得天下、走得是秦国得郡县制；最后七个诸侯王联名提议刘邦当皇帝，台阶是功劳大、德厚、区分上下，资格是灭乱秦、诛不义、功臣皆受地食邑；正月商量，二月甲午就在山东定陶登基称帝。\n刘邦分封手段：\n1）真心封王：封了赵王-张耳，张耳与刘邦是亲戚，张耳的儿子(张敖)取了刘邦的女儿(鲁元公主)；当韩信和张耳灭了赵国时，要求封张耳为赵王镇守赵国。\n2）半心封王：许诺在打下韩地(河南的中部)时封韩王信为韩王，等天下大定时就把他迁到太原抵御匈奴了。\n2）违心封王：为了灭项羽而封彭越、韩信。\n70期：立仪定都 叔孙通(儒生)，六易其主，先在秦国做候补博士。由于把陈胜吴广的起义说城盗劫而升为正博士，回家后连夜逃回山东老家薛城已被陈胜吴广军队占领，紧跟着项梁到了就参加了项梁的起义军。项梁战死楚怀王接管，叔孙通又从项羽军团投奔到楚怀王。后来项羽成了西楚霸王了，叔孙通又从楚怀王跑到项羽军团去了。刘邦占领西楚国国都彭城时又投奔了刘邦了。\n制订礼仪：叔孙通为皇帝制订了一套礼仪，演练后皇帝很满意说：\u0026ldquo;吾乃今日知 为皇帝之贵也\u0026rdquo;，最后封了叔孙通做了太常，并赏500金，叔孙通把500金全部分给弟子，并推荐底下所有弟子升为郎官。\n定都：刘邦先时选洛阳，主要又几个考虑洛阳时东周的国都、洛阳又现成的宫殿、洛阳地理位置很好(手下大部分都时江苏人离洛阳近)；娄敬分析说：陛下定都洛阳是要跟周朝比高下，周朝积善累德十几代，最后得到诸侯的拥护，灭了商建周，在成王时期，周公辅助周成王，又建了成周洛邑。你是带三千人从沛县起兵，定三秦,战荥阳,大战七十，小战四十，让天下百姓肝脑涂地换来天子之位；张良也支持选长安，因为关中地理形势好、关中有经济文化素养、关中时刘邦的根据地、关中是周朝的发祥地。\n71期：汉初三杰 刘邦从布衣百姓到称帝只有七年，在中国历史上只有一位。秦始皇兼并六国统一天下成功用了十年得时间，在他前面有三十五代秦国国君，有几百年的铺垫。在西汉建国500多年以后的魏晋时期，竹林七贤阮籍登上广武的古战场，看了看楚汉战争的遗存说了句有名的话：“世无英雄 遂使竖子成名”，所以刘邦当皇帝评论是很多的。\n张良：\n张良是韩国贵族，祖父曾经是韩国三代国君的相国，他的父亲做了两代国君的相国，“五世相韩” 一直到公元前250年，张良的父亲去世，张良没有出任国相那时他还小，等长大了可以做官了韩国灭亡了，张良父亲死后20后韩国灭亡。韩国灭亡时韩信家中非常富有(300个奴仆)，此时家里遭遇了不幸，他弟弟夭折了，他在处理好弟弟后事后，放走了300个奴仆，变卖了家产得到了很多钱，然后开始买凶刺杀秦王，找了一个大力士(能把120近得铁锤投得很远)，在秦始皇二十九年也就是公元前218年，秦始皇第三次巡游时，张良和刺客埋伏在博浪沙(河南原阳县得南边)，此时秦始皇已经有了戒备(之前有两次遇刺一个时荆轲、一个时荆轲好朋友高渐离)，于是秦始皇就弄了同型号得多辆车，自己随机坐到一辆车里，这次行刺用铁锤把其中一辆车砸得稀巴烂，刚好没砸到秦始皇的车，秦始皇马上进行大搜捕，张良跟刺客都逃了，张良逃到了江苏的下邳(pi)。\n另外一个热血青年时燕国得太子丹。\n张良遇到的奇人奇事，有一天张良过一个桥，遇到一个老先生冲着张良走过来，然后老先生把自己鞋扔到桥下，叫张良去捡，张良本来要扁老先生但是他太老，然后就压住火把鞋给老先生拣回来了，然后老头脚一伸叫张良把鞋给他穿上，张良又忍着把鞋给老头穿上了，老头一句话没说笑了笑走了，走了一里多地老头又拐回来说了句话“孺子可教”，然后跟张良说5天以后你还在这里等我，张良想了想着老头很奇怪，然后就答应了，5天后天一亮张良就到了那了，可那老头比张良还早，老先生见张良来得晚就一顿训斥“与老人期 何后也”，说5天后再来；到了第5天，天还没亮张良就急吼吼的赶到那，可老头又比张良早到那，然后又是一顿训斥，又说5天后再来；到了第15天张良不敢睡，天刚半夜他就去了，张良刚到那不久老先生就来了，于是老头就交给张良一本书说：看了这本书你就可以成为帝王之师，10年以后你可以发达，13以后再蓟北咱俩可以在见一面，那个古城山下又一块黄石，那块黄石就是我。张良到天亮的时候一看书名叫\u0026laquo;太公兵法\u0026raquo;,从此以后张良就专心研究这个本并发，10年以后陈胜吴广起义，张良也召集了100多个人去投奔另一个人，在路上就遇到了刘邦就加入了刘邦。张良用\u0026laquo;太公兵法\u0026raquo;试了不同的人，只有刘邦能动而且马上就能做，觉得刘邦是个可跟之人。\n刘邦与张良的两离两别 1)项梁立了楚怀王熊心时候，张良看出门道(多树立几个秦国的对立面)，于是张良就去找韩国国君的后人，然后让项梁封他做韩王\u0026mdash;-韩王成，然后项梁就给了1000多个士兵跟着韩王成在韩国的地盘中打天下，可是很不顺，知道刘邦西入秦关，刘邦帮着韩王成打下了十几座城，这个样韩王成才有了立足之地，然后把子房要走. 2) 一直到项羽大分封的时候照样承认韩王成为韩王，这时韩信才回到韩国。但是项羽一直记恨韩王成，因为韩信给刘邦出了很多主意，最后就把韩王扣在军营不方，后来有降成侯，然后有带到彭城，最后在彭城把韩王成给杀了，这时张良彻底绝望了，有重新投奔刘邦去了。\n萧何\n与刘邦的关系老乡(沛县丰邑)、老同事(多次袒护保护刘邦)、老战友；萧何多次拒绝到中央工作；在刘邦称帝过程中，萧何立了四件大功成全了沛公、成全了高帝(抢户口、地图)、举荐韩信、经营后方(汉中、关中、巴蜀都是萧何在经营，给前方补充兵员粮饷)；萧何带领全族的人参加刘邦起义，\n韩信\n72期：血性男儿 齐国田氏三兄弟，田儋、田农、田横。\n田儋\u0026ndash;善度大势、有勇有谋、自主自立：\n田儋狄城县有一个豪强，假借处死奴隶的计谋杀了县令夺了政权，然后说了句话“反秦的大趋势已经形成、齐国是最早建立的诸侯国、田氏本俩就在齐地称王”，然后自立为齐王，带领大军平定了齐地。\n章邯率领主力军团平定起义军，第一个围住魏王，此时魏王向齐王求救，齐王带领军队帮助魏王，结果章邯利用夜晚的偷袭打败了齐、魏联军，杀死了魏王咎、田儋全杀了。\n田农\u0026ndash;心胸狭隘、不顾大局：\n田儋死后，田农在东阿重新聚集了起义大军，然后田儋把东阿包围了，就在极其危险的时候，项梁派兵打败了章邯解了东阿之围，此时齐国在田儋死后又立了一个齐国国君，田农见这个情况就带兵回去把新立的齐王赶跑了(齐王逃到楚国去了，新立的国相和一个将军逃到赵国去了)，然后立他大哥的儿子立为齐王。项梁要求田农出兵一起攻打秦国，田农则提出条件没有出兵(杀了那3个逃掉的人),最后项梁战败被章邯所杀。\n田农没有被项羽封王因为没有参加大决战，于是心生恼火把项羽立新立的三个齐王给杀了,然后自立为齐王。田农又煽动彭越、陈馀(把常山王赶走了)叛乱，然后就写信给刘邦叛乱(引火给田农)，刘邦一转手把信给了项羽。由于西楚国与齐国很近，项羽就带兵打田农，一下子就把田农打个打败，最后田农逃到平原被老百姓给杀。\n田横\u0026mdash;-前仆后继、血性男儿：\n此时刘邦已经平定三秦了、攻占了彭城，于是项羽就带兵回去与项羽作战，这一战就是四 五年，没有精力去管田老三了；项羽打败田农后，没有做好安抚每攻破一个城池就屠城，逼着老百姓造反，田横趁这个机会收复了齐国，立了他各个田农儿子为王、自己为相。\n在楚汉战争后期，郦食其劝齐王投降于是齐王就投降了，最后被韩信攻占了，后面虽然得到龙且支援，还是被韩信打败了就逃了(逃到彭越那去了)，最后刘邦称帝彭越被封为梁王，于是田横就带领手下500壮士逃到了田横岛。\n刘邦就下诏书招田横:田横由于杀了郦食其、又和龙且对抗韩信不敢奉诏，回信说郦食其的弟弟郦商在皇宫当卫蔚；于是刘邦又下了诏书不让郦商动田横，然后再下诏招田横进京，田横最后招来两个随从说了三句话“见天子是耻辱 见到郦商心里有愧 皇上想看我的模样”，于是就自杀让随从快马加鞭把头送到刘邦面前，刘邦夸了他为贤者然后重赏随从并用齐王礼厚葬了田横，最后两个随从把田横坟墓挖开也自杀了，刘邦知道这个事情后觉得田横手下都是贤者，就立即下诏招田横的500壮士进京要一一重用，等刘邦使者到达田横岛时500壮士也集体自杀，彰显了正义和血性之感(抛弃投降放弃荣华富贵)，留下了一段佳话。\n73期：冰火人生 项羽溃败后，不但追杀田横，也追杀项羽的几个部下：\n季布：\n逃到了一个周性人家，在追杀令的裹挟下，周家给他现了一计，把季布当作奴隶卖给朱家，朱家一眼就看出端倪了，朱家是个大侠，于是朱家买下后就交代儿子说“田事听此奴 必与同食”；接着朱家从山东跑到洛阳找了夏侯婴，了解了下事情缘由，最后夏侯婴评价季布是个贤者，朱家一下子给夏侯婴说了四个观点，让滕公转告刘邦：\n1）忠于自己的主人是臣子的职责\n2）项羽的部将刘邦杀得完么\n3）不能公报私仇去追杀一个人有损形象，显得心胸狭隘。\n2）不能逼人太甚，汉刚成立北又匈奴、南面又南越，如果逼得太紧逃了会成为后患。\n​ 历史上楚平王追杀伍子胥、杀了他得家人，后面逃到吴国后取得信任，带兵杀回了楚国攻陷都城，由于楚平王已死，为了报心中怨恨掘坟、鞭尸。\n最后刘邦下令赦免了季布(后面一直做到中郎将)；在吕后收到匈奴大单于得骚扰信，樊哙又口出狂言“臣愿得十万众 横行匈奴”，只有吕布出来说话(当年汉高帝带领40万大军被困平城)，阻止吕后对匈奴用兵。\n丁公(季布得亲舅舅)：\n据者曾经放了刘邦一家三口，由于之前一直追刘邦搞得刘邦很狼狈，最后丁公被杀原因使:\u0026ldquo;使后世为人臣者 无效丁公\u0026rdquo;。\n钟离沫：\n陈平使反间计离间了钟离沫，钟离沫骁勇善战、忠诚逃到楚王韩信那了(两个人都使军事家，年轻的时候使好朋友)，最后有人告韩信谋反，所以刘邦就借口游云梦在陈地大会天下诸侯，韩信由于害怕由于之前吃过刘邦的亏，采用了别人的建议带着钟离沫头去见刘邦免灾，韩信去找了钟离沫，钟离沫说我要是今天死你就是明天死，可韩信坚持要杀钟离沫，最后钟离沫说了句“公非长者”，钟离沫被迫自杀。\n74期：一升一降 汉五年(刘邦登记称帝的这一年)臧荼叛乱，原是燕王韩广下的战将，在赵国被围时燕王派臧荼去救赵，在救赵的过程中认识了被楚怀王派去救赵的项羽，打了巨鹿之战 杀了王立 降了章邯 消灭了秦军主力，所有参战的诸侯推举项羽为上将军，刚开始诸侯们都不敢打，最后是看主力项羽大势已定诸侯们才一拥而上，在项羽分封时封了臧荼为燕王，可是史记没写燕王为什么谋反。臧荼被平后推举了鲁绾为燕王。\n鲁绾：\n与刘邦关系 1）街坊 2）世交 3）同一天出生 4）同学 5）好同学 6）患难之交。鲁绾封王标志着刘邦因功而封 转向 因亲而封。\n刘邦收告密信说韩信谋反：\n“亟发兵 坑竖子耳”\u0026mdash;刘邦身边大臣恨韩信 或者 大臣们知道刘邦恨韩信。\n刘邦听了陈平计谋，假借游云梦在陈郡大会天下诸侯，把韩信给绑了削去王降为侯(六年后被杀)，张良不说话\u0026mdash;明哲保身，萧何不吭\u0026mdash;殃及池鱼。\n75期：分封之争 曹参:\n与刘邦是老乡 老同事 老战友\n曹参一直是跟着韩信立了很多功，在荥阳守卫战开始的28个月，跟着韩信横扫整个黄河以北。在汉高祖六年抓了韩信以后，刘邦封了庶长子刘肥为齐王(韩信被改为楚王)并派了曹参为国相，曹参做了9年的齐国国相，采用了黄老之学(融合道家和法家的学派)盖老先生的思想“清静无为 民自安”，曹参治理齐国非常成功，最后在曹参走后被称为贤相。曹参在诸子百家中选择黄老之学，因为社会现实决定的，从公元前770年进入春秋战国到秦始皇公元前221年统一天下过程中的五百多年都使战争不断，在经过三年反秦四年楚汉战争，这时候的国家的困难是无以复加的。\n惠帝二年在中央任相国的萧何死了，调曹参到中央任职，使用“萧规曹随”的政策。最后惠帝问他怎么回事，啥事都不干，曹参提了两个问题 1)你跟你爹谁高明 2)我跟萧相国比谁高明，所以垂拱之前的规矩就行了。\n滕工-夏侯婴：\n一生给三个皇帝开车汉高祖刘邦、汉惠帝刘盈、汉文帝刘恒。与刘邦使生死之交，很忠诚。夏侯婴慧眼识人(推荐韩信、季布、薛公)。\n事情1：夏侯婴每次赶车回来都会去泗水亭那边与刘邦闲聊，夏侯婴跟刘邦切磋武功被打伤了，这件事被别人告了(在秦国身为吏把别人打伤是犯罪)，夏侯婴替刘邦作伪证，夏侯婴最后挨了上百棍、坐了一年多的牢都没供出刘邦干的。\n事情2：彭城之战刘邦出逃途中救了自己的儿子、女儿，刘邦死后吕后、刘盈都很感激整个赶车的。\n事情3：高祖11年最后一个诸侯王黥布叛乱，夏侯婴找到曾经在西楚国做过令尹(宰相)的门客\u0026mdash;\u0026ndash;薛公,薛公说黥布是被逼叛乱(韩信、彭越、黥布这三个人功劳相等休戚与共,黥布害怕被杀)，滕公认为薛公对平叛黥布很有帮助就推荐给刘邦。\n76期：奇谋天才 陈平特点 1)长得帅 2)看重金钱 3)是个有本事得人\n陈平杨武户牖(you)乡人今河南的原阳，在刘邦封赏的第一批的十个侯中，农村户口有家里有几亩地，他哥哥不让他种地，因为他嫂子容不下陈平，他哥就把他嫂子给修了；陈平还是个美男也是个剩男，。\n故事1：陈平择偶，被一个克夫的女人得爷爷选中(死了五个丈夫)，这个女的爷爷看到陈平家背靠城墙，门店有许多豪车的车辙，最后选择让孙女嫁个陈平，还帮陈平出了聘金。\n故事2：陈平分肉，在一次祭土神后主刀分肉让大家很满意，说假如让我主宰天下，我也能像分祭肉一样治理得非常公平。\n陈平三易其主:\n1)跟魏咎，当时陈胜吴广起义后，立了很多六国的后代来对立秦国，魏咎是就是其中之一的魏王；由于魏王没有认识到陈平的重要性，后面就离开了魏咎(他向魏王提的建议魏王不听，有人向魏王进他的谗言)。\n2)跟项羽，离开魏咎两年后，项羽打完巨鹿之战经过陈平的家乡，陈平就跟了项羽。此时殷王司马昂，司马昂都城在河南的淇县(河南省的北部)，司马昂见刘邦还定三秦杀出函谷关后就叛楚归汉了，项羽很生气排陈平去平叛把司马昂打败了，所以司马昂又归顺项羽了，后来又被刘邦把殷国给灭了这样司马昂又归顺刘邦了，项羽就很生气就要杀当时去平定印地的人\u0026mdash;陈平，此时陈平已经做到督蔚，知道项羽要杀他就逃到刘邦去了(投奔刘邦的过程中要过黄河，陈平识破了摆渡人劫财的意图，他把衣服脱了帮船夫划船化解了危机)。\n3)跟刘邦：通过刘邦手下魏无知引荐，刘邦一口气召见7个人找他们谈话、吃饭，吃晚饭后刘邦让他们回去休息了，陈平感觉很可惜赖着不走，其他6个人都老实的走了，唯独陈平留下跟刘邦谈了一番话(说我有话要说，我的话必须要说过不了今天)，谈完刘邦很高幸就还让陈平做督蔚。后面有人举报陈平\u0026quot;盗嫂受金 反复无常\u0026quot;，刘邦就向找魏无知算账，魏无知说了段话：\n陈平解释说魏王不听、项王不信任，听说刘邦善用人就来投奔您了，我是属于裸官不收点贿赂怎么生活，如果您觉得我的计谋不能用，您可以把我的钱和官帽一起收走，刘邦听完后觉得陈平很坦率就给他更高的官。\n陈平功劳：韩信要求封假齐王，陈平、张良阻止刘邦大骂；鸿沟议和欠刘邦继续灭项羽；\n陈平善于腾挪躲闪\n事情1：杀樊哙，刘邦晚年在征黥布时受了箭伤，回去后一病不起，在刘邦病危期间有人反应樊哙要在刘邦死后杀赵王刘如意、和戚夫人，刘邦相信了就召陈平商议，刘邦依陈平的计谋把周勃叫到病榻前来下了一道口谕，让陈平和周勃立马赶到燕地去找正在燕地平叛的樊哙，一到军中立斩樊哙，然后让周勃代替樊哙平叛，在去燕地的途中陈平跟周勃说了樊哙现在不能杀“樊哙是刘邦的敌人、樊哙有很大的功劳、樊哙与刘邦是连襟”，最后他们决定“宁囚而致上 上自诛之”，到了燕地后周勃就代替樊哙平叛，陈平押送樊哙回京了；在回京的途中传来刘邦去世了，于是就一个人直奔京城，走到办道有遇到汉惠帝让陈平和灌婴驻守荥阳的诏书，陈平第二次不奉诏还是直奔京城哭泣刘邦，最后陈平把吕后感动，就下了新诏书把陈平改任郎中令(皇宫警卫司令)，后面樊哙的囚车压京城就赦免了。\n事情2：封诸吕，汉惠帝死了以后，吕后要封吕姓诸侯王，右丞相王陵不同意，左丞相陈平迎合吕后同意封，吕后就把王陵暗地里夺了权，让陈平做了右丞相，做了右丞相后杀都不干整天吃喝玩乐,吕后很高兴(本来吕后就不想让陈平揽事)，一直到吕后死后，陈平跟周勃联手把姓吕都给杀了。\n77期：臧否不一 陈平是张良的最佳搭档\u0026quot;凡六出奇计\u0026quot;：\n1）反间计：汉三年离间钟离沫、范增。\n2）金蝉脱壳：在荥阳即将被攻陷时，让汉军在东门放出两千女子吸引楚兵的注意力，让后刘邦跟陈平走西门逃了。纪信救主陈平只是辅助。\n3）韩信封王：提醒刘邦稳住韩信。\n4）调虎离山：高祖六年高祖伪游云梦抓捕韩信。\n5）白登解围：高祖七年刘邦带领先头部队到达白登山结果被匈奴40万大军围困，导致刘邦在平城被困七天七夜，用了陈平奇计(收买阏氏、陈平独见阏氏吓她说刘邦要用美女献单于)。\n陈平计谋评价：机变有余 深谋不足；刘邦评价\u0026quot;陈平智有余 然难以独任\u0026quot;；后世评价“盗嫂受金 过于圆滑”；司马迁对陈平”盗嫂“评价“犟侯 灌婴等 咸陈平口”；\n陈平洞明世事善于自保，自保的方法事迎合。\n78期：并峙双雄 高帝六年正月第二封侯19人，\u0026ldquo;绛灌无文\u0026quot;他们问什么并称功劳大、有权势、资格老。\n绛侯-周勃：\n封绛县，与刘邦是同乡沛县人，本领有编织匠、会吹箫、强弓手；功劳反秦、灭项、平叛。刘邦很信任他，刘邦死后15年吕后也死了(惠帝7年吕后8年)，吕后死后两个月周勃灭了吕氏一族\u0026quot;安刘\u0026rdquo;。\n颖阴侯-灌婴：\n封颖阴县，从小商贩参军做了中绢(打扫卫生)，主要功劳：\n1）打败项羽的骑兵军团\n2）大规模的破坏项羽后方\n3）追杀项羽\n灭诸吕：\n吕后死后两个月齐王刘襄起兵灭诸吕，这时候是上将军吕禄掌南军、相国吕产掌北军，这两个人派灌婴去对付刘襄，灌婴带军到了荥阳后才表示与刘襄联合灭诸吕，发挥了以下作用：\n1）手握重兵，灌婴不迎合不做事最终别人还是信任他(刘邦信任当起兵司令、汉惠帝信任他、吕后信任他、吕禄吕产信任他、汉文帝信任他)；\n2）政变的支柱，周勃是名义上的太尉没有兵权、陈平是右丞相日饮美酒戏妇女；\n3）保证了新君的顺利选拔，主要是灌婴带重兵在荥阳驻扎了阻止了刘襄进入关中，周勃、陈平选了一圈立了汉文帝-刘恒(周勃任务文帝懦弱、无能)；由于刘襄是第一个起兵最后没选中当皇帝，几个月后刘襄气死了(本来计划向西打，从函谷关杀如关中然后称帝,但是被驻扎在荥阳灌婴挡住了)。汉文帝被立当天晚上就下了三道诏书(立亲信掌管京城的南北二军、立周勃为左丞相(后面陈平故意让右丞相让给周勃)、立灌婴为太尉)，很快陈平就死了，陈平死后周勃被免官了，汉文帝三年灌婴也死了。\n79期：吕氏英杰 刘邦在高帝六年的正月、十二月两次封侯,第一次封侯有以下三人：\n周吕侯吕泽\u0026ndash;吕后大哥、建成侯吕释之\u0026ndash;吕后的二哥：\n刘邦在彭城打了败仗后树倒猢狲散(56完人打项羽)，最后跑到下邑(今天的鹿邑县)找到吕泽，然后收据散兵、做出捐关以东的大战略。\n舞阳侯樊哙-吕后的妹夫：\n与刘邦是老乡是亲戚，从芒砀山-；；参加三大战役灭秦、亡楚、平叛。胡三醒在资治通鉴上加注高度评价樊哙。功劳：\n1)阻止刘邦腐败还军坝上”沛公欲有天下邪 将为富家翁邪“、留足后路(在项羽要灭他的时候留了借口)、争取民心(六国抵抗秦的兼并用了100年最后秦国统一天下，陈胜吴广振臂一挥以后三年灭秦);\n2)鸿门宴闯帐解围\n3）擅闯汉宫：高帝11年刘邦病重不想见人”群臣绛灌莫敢入“，此时黥布叛乱情况紧急，樊哙排闼直入后的欠说鼓舞了刘邦(当年你沛县起兵多威武，现在竟让躺在宦官身上，你然道忘记赵高的事了么)，在是吕后哭闹(让太子统帅着一群老将，去攻打秦国的第一悍将，如果打赢了该赢，打输了太子之位难保)，最后刘邦领兵平叛受了致命的箭伤不久就死了，\n汉惠帝六年的时候樊哙死了，死后九年吕后才死，在诸吕过程中樊哙老婆、儿子被杀；最后汉文帝觉得樊哙是个功臣才找了一个庶子顶上他的侯位；在吕后掌权时做上将军，洗刷不掉吕党嫌疑。\n奉天承运\u0026mdash;就是天命，革命的意思革天命。\n80期：幸运之歌 堂邑侯\u0026ndash;陈婴\n五个幸运：被头领、投项梁、辅怀王、取江南、惠子孙，\n秦末大起义，东阳县(安徽天长县)的年轻人闹革命推举了陈莹当领头；项梁在吴地起兵带着八千人渡江而西来到安徽的天长，于是就找陈婴联合(陈婴在他娘的道说下最后投靠项梁：“首善必办 胁从不问”)；陈婴加入项梁后被项梁按排在楚怀王做宰相(高官 厚禄 无权，不会领兵打仗不会与刘邦结仇)；义帝被迁到江南去了最后被刺杀，从此陈婴就流落江南，等刘邦胜利了陈婴也把江南(江西、浙江)这一带给平定后就投奔刘邦了，刘邦封了他为唐邑侯；陈婴的儿子陈午取了汉文帝的女儿(长公主刘嫖，刘嫖很有野心，在汉景帝面前说栗姬坏话导致栗太子被废，说王夫人好话导致刘彻做了皇太子\u0026ndash;汉武帝，汉武帝的第一任皇后\u0026ndash;陈阿娇，有一个名言叫“金屋藏娇”)\n周昌\n堂兄周苛，他们两个是刘邦的老乡，原是泗水郡(下辖沛县)的办事员后面参加了刘邦的起义，周苛官到御史大夫，周昌做了汉王的中尉。汉四年荥阳会战(纪信假扮汉王东门头像、陈平献计让假汉王带两千女子出东门，让周苛守城，刘邦带着灌婴、陈平从西门溜走了)，周苛城破被俘最后与另外一个将领一起被杀了(项羽说:\u0026ldquo;为我将 我以公为上将军 封三万户\u0026rdquo;；周苛会曰：“若不趣降汉 汉今虏若 若非汉敌也”)，纪信被烧；周苛死后刘邦封周昌为御史大夫、周苛儿子也封侯了。\n周昌特别敢说话(有一次到刘邦寝宫汇报工作，恰巧看到刘邦抱着戚夫人在吃饭，刘邦按住周昌脖子并骑到头上问我是什么样的皇帝，周昌回答:\u0026ldquo;陛下即桀纣之主也\u0026rdquo;)。\n郦商\n哥哥是郦食其都是高阳人(今河南的杞县是开封的五个县之一)，郦食其是一个良禽择木而栖的人，等到刘邦经过县城的时候加入了刘邦，成为刘邦排名第一的说客，把他弟弟引到正道上来了(弟弟是武将带领的起义军也加入了刘邦)，郦商参加灭秦、亡楚、平叛三大战役。\n郦商功劳\n1）立主发丧：高主十二年病重故去，刘邦死后吕后秘不发丧，吕后与亲信审食其杀诸将，郦商听说此事后找审食其说明厉害关系让吕后放弃计划。 2）协助杀诸吕：郦寄与吕禄是好朋友，陈平与周勃用郦商为人质让郦寄骗吕禄较初兵权(吕后在死前交代吕氏叮嘱不要交出兵权受制于人；郦寄让吕禄交出兵权回赵国去可以免灾郦寄信了把兵权交给太尉周勃；周勃拿到兵权就把吕氏家族全部灭了)。\n81期：谋圣受封 张良“子房”功劳：\n1）攻取南阳，免除后患 2）智取峣关，进入咸阳 张良让刘邦拿钱贿赂咸阳守将一起抗秦让其麻痹，然后功其不备夺取咸阳 3）退出秦宫，还军霸上 4）利用项伯，化险为夷 5）下邑划策，重用人才 6）阻封六国，集中力量 7）劝阻刘邦，加封齐王 8）废止合约，追杀项羽 9）固陵建议，合围垓下 10）建都关中，万世基业 刘邦评价：“运筹帷幄之中 决胜千里之外”，曹参(一万零六百户),周勃(八千一百户)，萧何(八千户)，夏侯婴(六千九百户)，灌婴、陈平、樊哙(五千户)，让张良“自择齐地三万户”超过万户侯，张良回曰： 功成不居：张良受封以后，就开始淡出朝政 “道引不食谷 杜门不出”。有人说有病，有人说他是自保。\n1）“余以为 其人计魁梧其伟” ，但是有人评价画像“妇人之女”。\n2）高祖十一年，刘邦带兵平叛张良抱病送行，刘邦交代“子房虽炳 强卧而傅太子”。\n3）高帝十二年，在刘邦将死之时吕后的三问三答,萧相国死后谁即位，曹相国死后谁即位，王陵、陈平死后谁即位，唯独没有提到张良。\n急封雍齿：高祖六年三月刘邦听了张良的计策，宴请文武百官封雍齿为什邡侯，稳住没有被刘邦受封的人。刘邦起兵沛县下的一个镇丰邑，派雍齿守住丰邑老家大本营，后面雍齿叛变(“雍齿雅不欲属沛公”、魏国军事压力)，刘邦二功丰邑失败，最后投靠项梁，项梁借兵(十元战将五千士兵)借将三夺丰邑才成功，雍齿打败仗逃道魏国去了，后来雍齿又回来投奔刘邦，还帮刘邦打了不少胜仗。\n司马迁评价张良：\n82期：军工封爵 “随陆无武 绛灌无文”，随陆\u0026mdash;随何(主要是策反黥布功劳很大没有封侯) 陆贾\n在西晋灭亡以后，有一个北中国的大乱时期叫“五胡十六国”，十六国中间有一个汉国开创者叫刘渊(匈奴族人)，对刘邦的封侯标准进行评价：\n陆贾露面1：张良在打峣关的时候不要拿两万人去硬拼，派郦食其、陆贾去和峣关守将议和联合攻秦，随后刘邦发动突然袭击打败了峣关守军。\n陆贾露面2：鸿沟议和时，刘邦派很夺人去劝项羽放回人质(刘邦父亲太公、妻子吕后、庶长子刘肥和刘邦侄子一帮人)，其中就有陆贾结果失败了。\n陆贾露面3：刘邦称帝以后在南边出现南越国，国君是南越武王赵佗；秦始皇统一六国以后北击匈奴、南征南岳，最后把南越给平定了建立了三个郡南海郡(今广东)、桂林郡(今广西)、象郡(越南中部以北)，秦始皇使用五十万大军征南越而且打了两次，副统帅就是赵佗(真定人\u0026ndash;今河北石家庄)，赵佗后面就做了龙川县(南海郡管辖)的县令，南海郡郡蔚很有谋略的人,在秦末大乱时郡蔚临终任命赵佗为新的郡蔚，交代赵佗把南海郡建成一个独立的国家，于是赵佗就下令封关,并把秦始皇委派官员杀掉换成自己的亲信，等秦帝国灭亡赵佗就发动突然袭击把桂林郡、象郡给吞并了，建立南越国自称南越王。刘邦称帝后派说客陆贾去解决南越国，陆贾到南越国后说了三条：1）你是中原人(祖先坟墓、亲戚都在真定) 2）借助天意镇住赵佗(天意让刘邦称帝),弹丸之地对付不了中原 3）威胁赵佗归降中央；赵佗对陆贾很佩服留了陆贾好几个越，赏了陆贾双千金，归顺了中央。\n陆贾提出西汉初年将近70年的治国理念，在中国历史上是一个里程碑到今天还值得研究。刘邦说：\u0026ldquo;乃公居马上而得之 安事诗书\u0026rdquo;，陆贾回说：马上能得天下，马上能治天下么？马上治理天下的有吴王夫差被勾践灭了、晋国的智伯被韩、赵、魏灭了、秦被你灭了。刘邦无言道道就让陆贾写点东西总结下秦为什么灭亡，把历史上的王国教训都写一写，于是这一写就出了十二篇叫\u0026laquo;新语\u0026raquo;\n刘邦之前只总结怎么打败项羽\u0026mdash;三杰，但是没有思考怎么夺得天下，陆贾给他点出来了\u0026mdash;\u0026ldquo;逆取顺守 恃力而亡\u0026rdquo;，所以陆贾提出三个治国观点\n1)反秦之弊 与民休息\n2)以农为本轻徭薄赋\n3)无为而治\n陆贾对西汉政府事立有大功得但是没有被封侯，所以汉代封侯是以军功为功，司马迁史记也是按军功档案写的。在封萧何时受到了大臣们的对抗，刘邦在评价时说：在前面打仗得是功狗，指挥猎狗抓捕猎物的猎人\u0026mdash;萧何，萧何一直在后方做后勤他是功人：\n军功阶层的出现利是这些功臣坚决支持中央政府，功臣派与皇族派利益是一致的，他们涉及人太多太强大了，所以后面出现了外戚派很块就被灭了；弊端是军功受益阶层一定程度上压制后起之秀(萧何、张良有刘邦给与辩解，但是陆贾、汉文帝时期的贾谊就没那么幸运了，贾谊在中央没几年就贬到长沙做太傅，最后转到梁怀王做太傅，梁怀王坠马而死，最后贾谊哭泣而死，排挤他的就是绛灌)。\n83期：第一功臣 高帝六年刘邦在十二月和正月连续分封了29为列侯，列侯分封完毕后还需要对他们排一个座次，大臣都推举曹参，但是刘邦想让萧何排第一，在关键时刻鄂(er)千秋提出说：曹参是一旦之功而萧何是万世之功，于是刘邦没等大臣接话就立即表态、下诏书为第一功臣，萧何上殿可以“剑履上殿 入朝不趋”。\n打天下时刘邦需要会打仗的人，管理天下刘邦需要能治国文官，而这些人中间张良时高参，周勃、曹参都时武将，萧何是经过实践可以经营国家的人，所以此时刘邦想让萧何做汉帝国的第一任丞相。封列侯是回报是过去的总结，排座次是未来的开始。\n楚汉战争四年刘邦把汉中、关中、巴蜀交给萧何管理而刘邦在前面奋战，在灭秦以后颁布两道法令1)约法三章(去除秦国繁琐苛法) 2)所有的秦帝国官吏一律留任，所以包括郡县制还有秦国的法令基本都留下了，除了这些基层管理以外，萧何是最清楚这些法令(在沛县起兵前是主吏掾)。\n萧何几个事情：\n事情1：在封第一功臣是在高帝六年，在高帝三年时刘邦和项羽在荥阳对峙时候派人去慰问萧何，这时候萧何手下门客叫鲍生发现了问题(刘邦开始怀疑萧何了)，于是建议萧何把自己的子孙凡是符合当兵的都派到刘邦的大营去做人质，此时“汉王大悦”，因为萧何权力太大了。\n事情2：萧何临死时汉惠帝去看望萧何问:“君即百岁后 谁可代君者”，萧何回曰:\u0026ldquo;知臣莫如主\u0026rdquo;，惠帝问:\u0026ldquo;曹参何如\u0026rdquo;，萧何回:\u0026ldquo;帝得之矣 臣死不恨矣\u0026rdquo;；萧何很谨慎如履薄冰，后人评价萧何：举贤不计私仇。\n事情3：萧何买房买地都时跑到刘环以外去买，而且不买别墅，房子都是不带围墙的，萧何说：\n84期：刘姓封王 高帝六年大封29位诸侯王其中有四同姓诸侯王，目的使为了削弱异性诸侯王(主要在异性诸侯王封地上封同姓王)、巩固刘氏政权稳定政局、发展经济；说明刘邦封王标准从因公转向因亲。\n老四刘交：1)刘邦每次出去都是带小弟弟刘交,让二哥跟审食其照顾太公 2)从沛县起就跟着刘邦，只有他小弟弟和发小卢绾可以自由出入刘邦卧室 3)汉六年楚王韩信被废后薛郡、彭城郡、东海郡的36个城交给刘交管理(第一次封的同姓诸侯王)。刘交老师是先秦诸子中间荀子的门生叫浮丘伯，刘交同学申公(名字叫培)精通\u0026laquo;诗经\u0026raquo;\u0026mdash;称为鲁诗。\n老大：老大死的早大嫂跟刘邦关系不好，刘邦回太公说:\u0026ldquo;某非敢忘封之也 为其母非长者\u0026rdquo;，最后封了埂颉侯(锅铲子蹭锅的声音)。\n二哥：刘喜能做生意做点小钱但无政治才能被封为代王，结果匈奴一打过来就跑到京城去了，就从王降成侯。刘喜儿子刘濞(带领吴楚齐国叛乱)很有本事在平定黥布叛乱后也封了王。\n庶长子刘肥：封齐王下辖73座城，谋士田肯说：关中是“百二之地” 齐国是“十二之地”，“非亲子弟 莫可使王齐者”。\n刘贾：楚国剩余的53个城给了荆王刘贾，后来在黥布叛乱刘贾战死，改封吴王-刘濞的封地。\n85期：太上皇帝 高帝六年封太公为太上皇,之前有秦始皇称帝后追封庄襄王(已故)为太上皇，高帝十年七月太上皇驾崩葬在万年县(今西安)。\n刘邦与太公关系:\n1)留侍太公\n2)扣为人质\n3)烹了喝汤\n4)未央夸富\n5)营造新丰\n按老家的原貌造了一座新奉。\n6)修建太上皇庙、大赦天下：\n张萱评价刘邦\u0026laquo;尊母不尊父\u0026raquo;:\n1)山东定陶称帝当天封皇后-吕后、封太子-嫡子刘盈、封母亲(昭灵夫人) 不封太公\n2)高帝六年 封兄弟、封儿子 不封太公\n3)未央宫夸父让太公丢面子\n太上皇的情况：\n1)为了身后 提前退位\n五胡十六国大乱时候，后凉太祖吕光在做皇帝时候得病，他的嫡子要即位但是性格很弱掌握不了局势，庶长子、次子比较厉害，所以吕光就提前退位为太上皇辅佐嫡子，在临死前交代三个儿子要辅佐皇帝，如果兄弟相残国家必灭，在吕光死后兄弟相残最后国家就灭掉了。\n2）年老有病 无法履政\n唐顺宗即位以后因为本身有病，第二年就立了广陵王做为太子，后来传位给太子也就十唐宪宗，唐宪宗即位以后尊唐顺宗为太上皇后46岁就死了。\n3）形式所迫 不得不交政\n唐高宗李渊武德元年代隋做了皇帝只做了九年，武德九年六月秦王李世民发动玄武门政变，杀死了太子和李元吉逼李渊在九月传位给他。\n4）他人擅立 只能默认\n唐玄宗因为安史之乱跑到四川避难，在马嵬坡赐死杨贵妃，紧跟着被老百姓留下来的太子李亨在大臣们的拥立下，在灵武即位为唐肃宗，即位后就尊他父亲为太上皇。\n5）退居二线 掌握实权\n乾隆皇帝(之前康熙即位61年)活到到了85岁，在60岁退位为太上皇立嘉庆为皇帝，一直到嘉庆四年乾隆才死去之前一直掌握实权训政。\n6）淡薄政务 诚心内禅\n86期：白登之围 韩王信是韩国国君韩襄王的儿子，韩王信特点身高、武功超群、活命第一，韩王信亲身经历韩国灭亡，韩国灭亡后韩襄王的子孙绝大多数被杀，只有韩王信侥幸活了下来。\n张良被任命为韩国的司徒奉命西征意外的发现韩王信, 并带着韩王信入关成为刘邦手下的一员，此后张良就去辅佐韩王成了。韩王信与刘邦对话：“项王王诸降将近地 而王独远局此 此左迁也”，当刘邦挥师东进时候任命韩王信为韩太尉去攻打韩地，汉二年韩王信打败郑昌占领了韩地，刘邦就任命韩王信为韩王；汉三年刘邦在荥阳打了败仗，派三人留守荥阳城周苛拒降被杀、枞公不降牺牲了、韩王信投降项羽，后面韩王信从项羽逃出来投奔刘邦了。汉六年刘邦把韩王信迁到代国去。\n汉六年九月韩王信投降匈奴，与匈奴联手攻打太原郡，十月也就是汉高帝七年第一月刘邦带领32大军攻打匈奴，很块就把韩王信打败了，刘邦不顾刘敬反对轻敌冒进，匈奴隐藏实力在白登山围住刘邦。最后陈平献计解围。刘邦采用刘敬用和亲之策缓和与匈奴关系。\n87期：爱子封王 戚夫人人美、能歌善舞、善乐器；刘邦也很会玩与戚夫人珠壁联合 笙箫同音。刘邦评价太子刘盈\u0026quot;不类我\u0026quot;,对刘如意评价\u0026quot;类我\u0026quot;。刘邦封汉王51岁。\n废太子，刘邦早年萌发换太子的想法，晚年高祖12年越发的强烈，\n张良、周昌反对，叔孙通更是以死相谏反对说:\n1）立嫡立长的制度不能废\n晋献公宠爱郦姬废了太子申生 立了奚齐导致晋国几十年的内乱。\n秦始皇没有及早的立太子扶苏，结果被赵高诈立胡亥导致国亡。\n2）太子仁孝天下皆知\n3）吕后对大汉王朝的建立是有功劳的\n吕后：\n密切关注：吕后跪谢周昌“微君 太子几废”；让吕泽劫持张良问计：张良首先是反对,其实是事不关己高高挂起，现在皇帝因爱废立说话没作用，建议请商山四皓来导师太子。\n刘邦平叛黥布后设宴群臣，见到四皓(东园公、用里先生、绮(qi)里季、夏黄公)在辅佐太子，四皓说你不尊文人而太子尊文所以就来了，然后刘邦感概唱了\u0026laquo;鸿鹄歌\u0026raquo;,从此不在说废立太子。\n88期：夺储之祸 戚夫人失败的原因:判断失误】阻力很大、没有妻党。\n废长立幼：汉景帝废了黄长子刘荣然后立了刘彻为太子\u0026mdash;汉武帝，汉武帝晚年听了谗言废了皇长子立了8岁儿子刘弗陵做了皇帝\u0026mdash;汉昭帝。\n戚夫人判断失误，刘邦优柔寡断，吕后应对得力，最后刘邦没在保护戚夫人上足功夫，导致戚夫人、爱子刘如意都被杀。\n89期：封王之路 张耳幸运：\n1）婚姻\n在外黄飘荡，有一个富家女退婚选择了张耳，张耳有了钱后九广交朋友，后面就做秦帝国外黄的县令。陈馀有一个忘年交朋友，陈馀取的也是富家女，张耳、陈馀关系：“父事张耳 两人相遇为刎颈之交”。\n2）陈渉起义\n第一次参加了起义，受到陈渉、吴广的重用，采纳了张耳、陈馀的建议给了一支军队去打赵地让武臣做将军，另外派了一个人做督蔚，张耳、陈馀做校尉辅佐武臣，到了赵地很快就打了大片土地。\n3）巧遇蒯通\n张耳在赵地遇到蒯通，采纳了蒯通的建议“不功而降城 不战而掠地 传檄(xi)而千里定”，一下子赵地另外的30几个城都拿下来了；封投降的范县县令，其他县令也跟着效仿范县。\n4）武臣被杀\n张耳、陈馀建议武臣自立为王并化解武臣的顾虑。陈渉见武臣称王采取了以下办法派使者祝贺武臣称王、扣押武臣家属，然后又命令武臣向西功秦。最后武臣采用了张耳、陈馀的意见向南打河内郡、向北打燕代，于是武臣分三只军队：\n4.1 韩广攻打燕地，后面打下燕地自立燕王，然后武臣很生气就带兵去打韩广，在者过程中由于武臣贪玩打猎被俘虏，最后张耳赵军中的一个厮养卒(炊事员)为使者，向韩广讲了张耳、陈馀 与 武臣的厉害关系，就把武臣给放回去了。\n4.2 李良攻占常山，拿下常山后，就在井陉受挫，由于收到秦军将领的炸降信，回去搬救兵时不巧拜武臣姐姐，所以就一怒之下反了，然后直扑邯郸把武臣、督蔚都给杀了。\n4.3张黡攻占上党。\n张耳、陈馀逃脱后，立了赵国王族后裔赵歇，张耳做了丞相 陈馀做大将军，把李良打败重新收回了赵地，李良投靠章邯去了。\n90期：翁婿嫌隙 各地起义军风起云涌时，秦国受命章邯镇压各地起义，章邯横扫所有的反秦义军然只有赵国还没占领，于是章邯和王离的长城军团来打赵国，章邯先是把邯郸的老百姓迁走然后拆城墙，这样赵王歇和张耳、陈馀就被打垮了，陈馀被隔离在巨鹿城外，赵王歇和张耳被困城中。由于陈馀没有答应张耳的催促救援，于是两人就出现了矛盾。\n项羽杀了宋义夺了军权然后派黥布渡河 自己破釜沉舟断了王离的粮道，天下诸侯看项羽打败了秦军然后齐下手把把长城军团给灭了，活捉了王离解了邯郸之围。之后章邯投降，张耳被封常山王,原来的赵王歇迁到北边封代王，陈馀只封了三个县。\n陈馀\n陈馀屈从出兵(屈从张耳手下突出重围的两个将军，给他们五千士兵最后全部被灭，张耳怀疑两个将军是被陈馀所杀)、负气交权(夺了陈馀的兵权)、对项羽分封不功(最后在田农的支持下打败了张耳)。打败项羽后陈馀把赵王歇接回来做赵王，赵王又封陈馀做代王，陈馀没回代国就在赵国辅佐赵王。汉二年刘邦要求赵国出兵打项羽，陈馀提出“汉杀张耳 乃从”，刘邦用假人头谎骗陈馀出兵，但最后被项羽打败，然后陈馀识破刘邦做假后又脱离了刘邦阵营。\n张耳\n张耳与项羽的交情是在巨鹿之战一个在内一个在外联手打败秦军。在起义之前张耳是魏国的大名人在广揽天下的宾客时认识了刘邦；在被陈馀打败后又听了手下的建议就投了刘邦，刘邦很高幸就收留了张耳并与张耳结为儿女亲家,。韩信、张耳带军战胜赵国在井陉杀了陈馀，随后杀赵王歇，汉四年刘邦封了张耳做赵王，汉五年就病死了，张耳儿子张傲即位做赵王。\n张傲\n汉七年突围平城路过赵地时，由于经常辱骂赵王，张傲底下老臣气愤不过就私下秘密要杀刘邦；高祖八年刘邦第二此经过赵地时，刺客已经埋伏好了，这时刘邦由于感觉不踏实、地名不吉利,就连夜走了夺过了一劫。汉九年刘邦知道了这件事后就把赵王(在吕后的保护下没有被用刑)、贯高丞相抓走，在刑讯逼供下贯高仍咬定是自己谋划的，于是刘邦又派贯高好朋友泄公了解了整个实情，贯高说了整件事的经过，最后说：我之所以没跟其他人一样自杀是为了证明赵王是清白的，最后刘邦了解到了实情后，就赦免了赵王降成侯；贯高知道案件审清后，拒绝刘邦赦免就自杀了，刘邦知道此事后很感慨，就把跟随赵王的随从都提拔为官。\n91期：成败萧何 陈豨:\n在秦末大起义时带五百士兵加盟刘邦集团，平定臧荼叛乱(燕地 今北京这一带)、韩王信叛乱(代地 今山西的北部 太原以北)立有功劳，刘邦就任命他为赵国的国相，汉七年让他监管赵国、代国两国军队相当于统领北部边防军，汉十年陈豨就叛乱。\n陈豨养了一千多个门客，被周昌报告；陈豨知道被查后由于害怕，就与原来韩王信手下的叛将王黄、曼丘臣联系上了(之前韩王信就派两位联系过陈豨，人在高地时都不愿意趟浑水)；紧跟着太上皇病故昭陈豨进京治丧，陈豨不敢参加，于是刘邦就带兵平叛。\n刘邦平叛陈豨：\n端定陈豨成不了气候(南边不占领漳水 北边不守邯郸)，甄别周昌杀郡守、郡尉的建议(常山郡一共25个县丢了20个，那些郡守是力不敌众才投靠人家)。刘邦勉强用了周昌推荐的四位将军(“竖子能为将乎”，每人给了一千户)，十一年冬天就把陈豨的主力打垮，十二年冬天陈豨就被樊哙杀了，前后三年平定陈豨叛乱。\n韩信谋反：\n陈豨在任命赵国国相之前专程拜访韩信，韩信见陈豨来就只开身边的人说了三点：1）皇帝派你去的地方战略要地 2）你手握重兵 3）皇上对你非常信任。到时候只要你一叛乱皇帝一定是亲征 ，“吾为公从中起 天下可图也”。\n汉十一年刘邦要求韩信随同出征陈豨叛乱，韩信称病未去暗中送信给陈豨 “弟举兵 吾从此助公”；韩信从楚王降为淮阴侯软禁在京城，生活自由没有收到很大的限制,但此时没有兵权，于是想诈称皇帝诏书集中京城中的奴隶袭击吕后、太子占领京城，意外的是韩信手下一个犯罪的门客(关起来要杀掉)，这个门客弟弟知道这个事情后就告发了韩信。\n吕后知道消息后就跟萧何商量，谎称皇帝在前方打了打胜仗邀请韩信进攻祝贺，韩信没去，最后萧何亲自来请韩信才进了宫(因为萧何是韩信的知己)，等韩信一入长乐宫(吕后住的宫殿)，提前埋伏好人就把韩信抓起来推进钟室杀了,韩信最后说了句话：当初后悔没有听蒯通的话，才落到今天的下场。刘邦知道韩信谋反被杀后 \u0026ldquo;且喜且怜之\u0026rdquo;。\n刘邦全国通缉蒯通，蒯通被抓了要被杀时说：冤枉，当初时各为其主忠于自己的主人没错，当初时让韩信保持中立让韩信、刘邦、项羽三分天下，又拿狗比喻狗时不咬主人的，由于刘邦晚年提倡忠诚，所以最后放了蒯通。\n韩信被杀\u0026laquo;史记\u0026raquo;两处不同记载，因为韩信非寻常之人、吕后此时不敢不报、此事影响废立太子 所以萧何的记载更符合清理。\n1）\u0026laquo;淮阴侯列传\u0026raquo; 刘邦平叛回来才知道韩信被杀\n2）\u0026laquo;萧相国世家\u0026raquo; 刘邦在前线已知道韩信被杀\n加封萧何任命萧何为相国、加封五千户、给萧何警卫500人。\n92期：反乎冤乎 韩信谋反被杀：\n不谋反(武渉、蒯通游说) ====\u0026gt;到有怨恨(从王将为侯从此称病不上朝,羞与绛灌、樊哙为伍，大失脸面 人生目标丧失 感到心寒)====\u0026gt;到想谋反====\u0026gt;到真谋\n蒯通第二次游说韩信：\n1）有功称王 错(人与人之间只有永远的利益，从朋友的维度举了张耳、陈馀的关系；从君臣关系越王勾践复国，两个大功臣聪明范蠡走了，文仲留下来最后被勾践杀了，共患难的朋友 同富贵时心患)\n2）功高震主 危(灭魏、灭代、灭赵、胁迫燕国投降、灭齐建了不赏之功 处臣子之位 带震主之威，天不收地不留)\n最后说了三点：\n1）人要识劝\n2）奴仆思想严重\n3）犹豫不决害死人 猛虎要是犹豫的话还不如蜂虿[chài]蟴(si)人，千里马要是犹豫了还不如劣马呢，一个勇士要是犹豫了还不如一个庸人呢，一个聪明人犹豫了还不如一个哑巴。\n韩信不听的原因：\n1）对刘邦抱有幻想\n韩信知恩图报 以德报怨(胯下之辱 最后封那个人做中尉)；我有这么大的功劳 刘邦还会害我么；\n2）无称霸之志 只想做一个因公封王\n3）对刘邦精神臣服\n4）性格犹豫徘徊\n韩信时被冤杀：\n1）策反陈豨不合情理 两人一见面就谈论谋反\n2）谋反时机不符合情理 拥兵的时候不谋反,无兵权的时候谋反\n3）动用兵力不合情理 想要聚合一群乌合之众跟训练有素的士兵对抗\n4）动手条件不合情理 刘邦一离开就应该谋反，为何还要与陈豨书信来往\n5）诛杀韩信过程不合情理 没有审问、查证就杀\n93期：死因之辩 对韩信之死的代表性意见\n1）灭齐惹的祸 齐国投降了韩信还用武力拿下齐国导致郦食其被烹，当时齐国田广重兵在历下(今济南的一个区 )毫无准备，所以韩信打得很顺。灭齐功大于过。\n刘邦为什么不下终止令? 这么大事情刘邦不会忘记；郦食其立过大功 最后在封侯得时候郦疥[jie]\u0026ldquo;功未当侯 上以其父故 封疥为高粱侯\u0026rdquo;，说明刘邦对郦食其之死怀有愧疚。\n刘邦决定用武力解决齐国为什么还派郦食其? 用政治解决实践比较短，防止韩信做大做强。\n刘邦占成韩信灭齐得行动么? 灭齐比降齐结果更好,韩信做大做强。\n2）求封齐王惹的祸 在张良、陈平踩脚提醒最后封韩信为齐王\n错了么？刘邦是认同用土地封功臣的；\n刘邦动了杀人之心了么？起了防范之心,违反潜规则\u0026mdash;-做下级的只能等上级给你封不能自己要。\n3）扩大齐王封地惹的祸 韩信有英雄之才 同事有市井之心；刘邦在鸿沟议和以后，带兵追项羽时被项羽10万军困在城中，不理解韩信、彭越为什么没来帮忙，最后刘邦给他们加封土地就来了。\n这次刘邦心理把韩信定义在小人的位置上了。\n4）功高震主惹的祸\n张良无权、张良本人很聪明置身于功名利禄之外 没有收到猜忌；\n而韩信有兵权：精于战场，暗于官场；刘邦在伪游云梦到陈郡要抓韩信时三个反应：方寸大乱、自无罪、卖友求荣；韩信四不懂：不懂开国之君的君臣关系(打天下为手足，共天下为心患)、谋反不一定要有证据只要有能力、皇帝杀功臣不关系个人恩怨只关系到江山的存亡、冒犯君王是大忌(“陛下不过能将10万 而臣多多而益善耳 刘邦善于将将 我善于将兵”)。\n萧何有政权 受到两次猜忌，手下人对他进行提了醒，萧何做了措施：4.1)把自己的家人拉到刘邦军营中参军做人质 4.2)以家财佐军资 4.3）自毁英明\n94期：将星陨落 由于陈豨叛乱导致韩信谋反最后被杀，同事卷进去的还有梁王彭越、淮南王黥布。\n彭越：\n在刘邦之前就被项羽封为梁王，后面刘邦打败项羽侯还封彭越为梁王。陈豨叛乱以后刘邦要带兵去平叛，希望靠近赵国的梁王一起参加平叛，梁王称病然后派一个将军随刘邦去平叛，刘邦恼火就派一个使者责备梁王 ，彭越此时“梁王恐 欲自往谢”。彭越手下的扈辄提醒彭越韩信被抓事件，扈辄说以其被抓起来不如反了，最后彭越没去做解释；此时彭越要处死手下一个犯错太仆，但是这个太仆逃到刘邦那诬告彭越谋反，刘邦马上组织人手把未戒备的彭越给抓住，送到洛阳给廷尉审理坐实了谋反，刘邦把彭越的爵位给夺了，发配到蜀地的青衣县(今四川的名山县)监视居住。\n彭越从洛阳走到潼关郑县(今陕西的华县)，此时刚好遇见长安到洛阳吕后，一见吕后彭越就上前喊冤，吕后就把彭越带回长安，然后跟刘邦说你现在在放虎归山，于是让彭越手下在递状子告彭越，最后诛杀三族杀了彭越。\n刘邦下令把彭越的人头挂洛阳城门上示众，不准任何人为彭越收尸和祭奠；彭越手下中大夫栾布来哭祭彭越马上被抓了，栾布说：第一大功当初你跟项羽打得最惨得时候时彭越帮你，彭越断了项羽得粮道 第二大功时垓下战役，现在你欲加之罪把彭越杀了，从此以后天下功臣人人自危，组后刘邦放了栾布(贯高为赵王，蒯通让韩信中立，栾布是为主子)。\n彭越对栾布有救命之恩，栾布跟彭越原时布衣之交，后来栾布在燕地酒保打工，由于主人被杀了然后栾布就替主人报了仇，后来燕王臧荼就用栾布做了将军，臧荼谋反后栾布被抓了，好朋友彭越已经做了梁王了，彭越知道栾布被抓就拿重金赎出了栾布，安排在彭越手下做中大夫，在彭越被杀时栾布正常出使齐国。\n黥布：\n知道韩信死时 \u0026ldquo;步因惊恐\u0026rdquo;,知道彭越死时 “因大恐”，于是黥布就密切关切和兵布控军队。\n淮南王有一个爱姬，黥布找了一个医生为爱姬看病，中大夫贲(ben)赫出于好意给医生送礼，让医生更好志亲不爱姬的病，最后黥布误会贲赫与爱姬由染，要杀了贲赫，于是贲赫就逃刘邦那高黥布谋反，刘邦就派人下来查黥布，黥布知道贲赫告了黑状就下定决心反了；黥布错误的认为刘邦不会亲征，结果导致黥布手下士气不稳战败，最后黥布带着100多个人逃到长沙国去了(因为黥布的老婆是长沙王吴芮的女儿，这时候吴芮已经死了由吴芮的儿子长沙成王在位，长沙成王就骗黥布说：与黥布一块往南逃到南越国去，结果逃到蕃阳县的一个农民家里头杀了黥布)。\n刘邦手下太仆推推荐了门客薛公，曾经是项羽的手下做令尹(宰相)，对黥布非常了解，薛公说：黥布谋反时必然得，因为黥布与韩信、彭越是一损俱损得关系，然后断定黥布会使用下策：\n1)上策:向西攻打楚国，向东攻打吴国，然后吞并齐鲁 胁迫燕赵 并守好已有的地盘，那么函谷关以东得土地不是你刘邦的了。\n2)中策:东取吴 西取楚，然后攻下赵国、魏国，据守敖仓 堵住成皋，那么胜负难定\n3)下策: 东取吴 西取楚，然后把后勤装备运到长沙国去，那么可以高枕无忧。\n黥布是项羽手下的骁将(巨鹿之战第一个打过河的人是黥布；刘邦把住函谷关，项羽破关而入这个人是黥布；项羽派黥布活埋20万投降秦军)。项羽大封诸侯王的时候只封了一个手下黥布为九江王，可是亲不见利忘义：\n1)在刘邦攻入彭城黥布不管\n2)项羽要打田农向黥布征兵，黥布称病派了一个将军带几千人去；\n3)项羽回兵在彭城与刘邦决战的时候黥布袖手旁边\n因为黥布见利忘义，导致项羽与黥布出现关系裂缝被刘邦利用策反了黥布，黥布谋反失败是必然的：见利忘义；黥布本是刑徒素无大志，最大愿望是南面称王；\n95期：高祖还乡 秦二世元年七月陈渉武广起义，刘邦在九月刘邦起义后离开故乡，一生只回一次故乡，回乡一共做了几件事:\n1）开怀畅饮\n\u0026ldquo;悉召故人 父老子弟纵酒\u0026quot;一共喝了十几天 后又“帐饮三日”\n2）唱\n刘邦一生创作了两首歌\u0026laquo;鸿鹄歌\u0026raquo;\u0026laquo;大风歌\u0026raquo;\n3）施恩沛县\n免了沛县故乡老百姓世世代代不再向国家交税和徭役。\n4）复丰比沛\n刘邦的出生地是丰邑长大在沛县；起兵时候丰邑老百姓跟者雍齿叛变这件事不能被刘邦原谅，丰邑让沛县老百姓跟刘邦求情，最后刘邦也面了丰邑的交税和徭役。\n\u0026laquo;大风歌\u0026raquo;是胜利者的乐歌 新唐书记载李世民还乡，李世民出生在武功郡的庆善宫，贞观六年李世民回到武功郡 “宴群臣 赏赐闾里 同汉沛苑”。\n\u0026laquo;大风歌\u0026raquo;应该是一首哀歌:\n1)对臣子的忠诚的深忧：\n在平定黥布之乱后一直在打听萧何在京干什么，萧何的门客说你灭族不远了，最后采纳了门客建议玩腐败，强买民田几千万亩搞得关中老百姓怨声载道 “上乃大悦”。\n2)对继承人他身怀忧虑\n3)对自己生命不永的深忧。\n高主还乡离刘邦死只有六个月\n元代许多写高主还乡这件事，其中流传至今最有名的是睢景臣写了\u0026quot;般渉调哨遍\u0026rdquo;《高主还乡》散曲，总共八支曲只在中国文学史上鼎鼎大名：\n第⑤支：\n第⑥支：\n第⑦支：\n第⑧支：\n96期：英雄陌路 刘邦从故乡回京一入函谷关就遇到几千人告萧何用低价强行买老百姓的土地，然后就召萧说 “君自谢民”，萧何说长安土地少 人口多，建议皇家开放上林苑给农民种，刘邦勃然大怒说1）你收了商人多少贿赂 2）开放上林苑损害皇上的利益讨好老百姓 最后把萧何下到监狱。\n刘邦说秦始皇的国相，凡是有功都归皇上有过都归自己，王卫尉(中央警卫团长)为萧何解释说：萧何要是有事在荥阳、在平定陈豨、黥布叛乱时都是好时机，你凭什么把相国想得那么坏，为民请命本是相国得职责，秦相最后让秦朝二世而亡算什么榜样，于是刘邦无言以对就放了萧何。萧何放出来后赤脚谢恩，刘邦解释说：抓你是为了用我的恶来衬托你是个好官；萧何这次被抓是一个长期不信任叠加的一个结果，刘邦对萧何得猜忌前后有三次：\n1）初汉战争时期 给萧何加官\n萧何把给自己加得东西推掉，让自己儿子及同族得子弟够年龄得都到刘邦帐中参军\n2）韩信叛乱 被杀后， 加封萧何5000户\n萧何全辞了，最后捐出一半家产献给国家做军费。\n3）黥布叛乱 萧何自泼脏水\n卢绾叛乱：\n卢绾因亲封王的第一人，封为第二任燕王，因与刘邦是居同里 生同日 学同师的关系；陈豨叛乱的时候燕王卢绾派了张胜出使匈奴，任务是说服匈奴帮助汉兵灭陈豨，结果卢绾到达匈奴后遇到第一任燕王臧荼的儿子臧衍，臧衍对张胜说(人有没有价值取决于有没有使用价值，如果陈豨一灭，燕国就不重要了，张盛就不能受重用了不断出使匈奴，最后张胜改口让匈奴帮助陈豨对抗汉军):\n卢绾事先怀疑张胜投敌叛国，已经跟中央报告要给张胜灭族了，等到张胜回到燕国后给卢绾说了一番道理才保住性命，然后卢绾做了两件事1)让张胜长期驻守匈奴做一个交通站 2)派范齐驻扎在陈豨帮助陈豨。刘邦在灭了陈豨后知道这两件事后断定卢绾叛乱就派大兵征缴卢绾。卢绾带兵驻扎在匈奴与汉的边界，本想等刘邦病好后跟好好解释下，最后刘邦却死了卢绾就带兵投降匈奴，匈奴封他为东胡卢王做了一年就病死了。\n卢绾叛乱的原因:\n1)私欲膨胀 ，认为帮助陈豨联合匈奴就可以长期稳定的做燕王了。\n2)疑惧之心(刘邦对诸侯王的疑惧 诸侯王对刘邦的疑惧，恐惧症来源于:没有任何理由就夺了齐王韩信的兵权，没有任何确证就诱捕了楚王韩信，没有任何过失就把韩信从楚王降为淮阴侯；晚年与刘邦谈话必反,臧荼(因为是项羽封的) 、韩信、韩王信(被迁到代国去)、梁王彭越被杀、淮南王黥布、卢绾)。\n刘邦病重，吕后请医生为他看病，刘邦说：我提三尺剑，夺取天下，此乃天命尔，现在天命已尽，然后就赏50金把医生给赶走了；吕后在刘邦死前三问：假如萧相国死后谁可以继任，刘邦说曹参；曹参死后谁能继任，刘邦说王陵,但是王陵太戆直，可以让陈平辅助，陈平这个人很有智谋但不能独任，周勃这个人厚重少文但安刘氏者必勃也，可以让他做太尉；在接下来呢，刘邦说在接下去你也管不了了；此番安排说明刘邦英明保证政权的平稳过渡，保障了天下稳定，但是刘邦对所有大臣洞若观火，但对自己的老婆始终没看透，说明刘邦也有糊涂的一面。\n高祖十二年四月二十五日病逝，刘邦走完了62年的人生之路；刘邦死后立即召了亲信审食其，秘不发丧，想把朝中所有大臣全部诛族，就在吕后运筹帷幄调兵遣将之时，最后消息泄露了，郦商知道后就谏言私交很好的审食其(陈平、灌婴10万大军驻守荥阳，樊哙、周勃20万大军驻守燕、代，假如真这样做，那么大臣内应，诸将外判那么天下将打乱),最后审食其把这番分析说给吕后听，最后吕后放弃了计划，吕后所有行动都是围绕者让年轻的儿子保住皇权。\n97期：自信人生 \u0026ldquo;世味酸咸谁自信 人生声利古难全\u0026rdquo;；刘邦一生分三个阶段:1)反秦 2)灭项 3)巩固政权\n刘邦自信的例子：\n 反秦:刘邦敢挑头起兵反秦当了沛公；\n 可以打败,但不被打垮(三攻丰邑)；\n雍齿叛变有两个原因:\n1)雍齿这个人压根就不佩服刘邦\n2)张耳、陈馀和武臣去攻略赵地，周市(fu)奉命去攻占魏地，在周市攻下魏地后就把目标锁定丰邑(江苏省的丰县，当时的丰邑属于沛县)，周市对雍齿说丰邑市属于魏地，他奉陈王的命令前来征讨，如果降魏就封你为侯，不降就要攻下丰邑，最后雍齿就带这老百姓投了魏。\n丰邑丢失刘邦很急，就带兵来攻打丰邑，最后失败了还气了害病。刘邦回到沛县养好病后，就去找景驹借兵，此时刚好章邯带兵打陈渉,同时又分一部分兵来打景驹,这样景驹就没办法分兵给刘邦；这时刘邦把目光瞄准了砀郡,并把砀郡打了下来，收编了砀郡的五六千士兵，加上沛县起兵的两三千人，就有了九千士兵然后就二功丰邑最后还是失败了。最后刘邦投奔了项梁，项梁给他十元战将五千士兵,三攻丰邑打下来了，雍齿逃到魏国去了。\n 敢于称王(封堵函谷关)；\n韩信就没有这个胆量\n 速胜论-破灭；\n彭城大败刘邦五十六万人败给项羽的三万人，刘邦计划只要说服九江王黥布倒戈，刘邦就能迅速的平定天下，最后黥布叛乱项羽没有亲自攻打，而是派了手下去打，手下人跟黥布打了几个月最后把黥布打败了，在这几个月里，刘邦并没有跟想象的一样平定天下,而是一直吃败仗退到荥阳打成了拉锯战。\n 建国立制-帝国制；\n刘邦从还定三秦后，就把关中几个诸侯王的封地改为郡县制，然后出关河南王申阳投降，西魏王魏豹被灭，韩王郑昌被灭，然后就把被灭的地方改成郡县制。汉二年三月刘邦下令废除秦国的社稷，然后定汉的祭祀，紧跟着立嫡长子刘盈为汉王太子守栎阳，等到定陶一登基就把汉王太子升为皇帝的太子。\n 屡败屡战-精神不垮；\n楚汉战争刘邦败得很惨，汉三年在荥阳打败仗(纪信主动报名假扮汉王，陈平建议两千女子穿汉服开东门，刘邦带着陈平几十个人开西门溜了)，汉四年只带着滕公一个人逃了(渡过黄河跑到韩信军营中，趁着韩信睡觉把兵权夺了)\n 平叛有远见；\n汉十年陈豨叛变，刘邦带兵去平叛，到了邯郸看了陈豨的驻扎地点就断定陈豨成不了气候。\n 刘邦的自信来源两个方面：\n1）自命不凡\n文献记载秦始皇认为天下的东南有天子之气，秦始皇多次巡游到东南就是为了镇住这个天子之气，刘邦认为这个天子之气是应着自己的。\n丰西泽纵徒躲在芒砀山，吕雉是根据头顶上的云气找到刘邦的，这件事传开了成了明星。\n彭城大败后要派人去策反黥布，骂了所有人 “如彼等者 无足与计天下事”。\n2）认知大势\n“天下苦秦久矣” \u0026mdash;陈渉、武臣、刘邦都说了这句话\n98期：魅力四射 刘邦是一个有市井之气，同时也是一个非常鲜明的个人魅力的人。\n刘邦魅力：\n1）王陵的母亲非常看重刘邦，称刘邦为长者，刘邦在临死前钦定王陵为第三任丞相，王陵原是县豪(有钱有势力)，在沛县起兵时独树一帜驻在南阳，到了楚汉战争开始后王陵才并入刘邦，王陵并入刘邦后项羽就恼火了，把王陵的母亲抓走逼王陵投降，王陵母亲自杀交代王陵一心一意跟刘邦。\n2）纪信救主 愿意牺牲自己。\n刘邦的美丽主要点\n1）敢于担当\n有一种豁出去的精神，丰西泽纵徒 从吏变成了逃犯；敢于称王；敢于称帝(强秦二世亡国，当时人们认为皇帝制度不好，对于想当皇帝的人是需要智慧和勇气)；\n2）共享成果\n在刘邦死前一共封了143个列侯。\n3）雅量\n 不计前嫌\n刘邦最恨的人雍齿，能够克制自己的情绪，最后封雍齿 一不杀二封侯。\n刘邦对王陵(又记仇 又报复)，看重王陵的耿直不畏权势，在死之前安排王陵为第三任右丞相在左丞相陈平之上：\n 不计易主\n陈平三为其主，叔孙通六为其主。人性的弱点只看结果不计过程。\n 不计言语冲撞\u0026ndash;雅量、能容人\n周昌一直顶撞刘邦，刘邦最后把保护赵王刘如意的重任交待给他。\n郦食其。\n 不计来自何方\n英雄不论出处，革命不论先后。\n 99期：用人有道 刘邦在用人的五大特长:\n1)一双慧眼\n相信萧何，识别韩信。刘邦对人才分等级有没有才、有没有德(有没有能力威胁到刘邦 大疑大用 大用小疑 大用不疑)。用其所长。\n2)一对好耳朵\n善听下级意见 \u0026mdash;-娄敬，南阳郡守门客；善听不同意见；善听谁的意见正确。\n3）一副好头脑\n懂得放权和收权。\n4)一支好队伍\n丰沛故人集团；三公：相国(有萧何 曹参 王陵 陈平 张苍) 太尉(最高军职，轻易不设太尉，有卢绾 周勃 灌婴 ) 御史大夫(号称副丞相、副丞相，有周苛 周昌 赵尧(周昌手下) 曹窋(zhu 曹参的儿子) 任敖 张苍)。\n容纳五湖四海的人，对异姓诸侯王采取了重点打击 区别对待。\n5)一个好心态。\n勇于向臣子认错(娄敬提议不能打匈奴 白登山解围后认错)。开放园林(向萧何认错)。\n敢于承认自己的判断有误。\n敢于承认自己的能力有限。\n","dateformatted":"19, March 2022","dateiso":"2022-03-19T09:42:33Z","ref":"/%E5%A4%A7%E9%A3%8E%E6%AD%8C%E7%8E%8B%E7%AB%8B%E7%BE%A4/","summary":"\n \u0026laquo;大风歌\u0026raquo;王立群 大风歌 歌手: 极泷 望华车 市井夺未央 尘沙起 鸿门巧对王 纳贤良 无畏得天下 三章法 垓下定汉疆 大风起兮云飞扬 威加海内兮归故乡 安得猛士兮守四方 大风起兮云飞扬 威加海内兮归故乡 安得猛士兮守四方 守四方 55期：传奇皇帝 公元前202年从山东定陶的一个土台上，一位五十五岁的中年男子，在群臣的欢呼声中，戴上了皇帝冠冕，他就是大汉王朝的开国皇帝刘邦，一个开创了从布衣到皇帝的神话，三年鏖战 摧毁强秦，四载奋斗 战胜项羽，创建了延续400多年的大汉王朝，然而这位不读书的皇帝,却写下了一首大气蓬勃的\u0026laquo;大风歌\u0026raquo;。\n\n","tags":["canal"],"title":"\u003c\u003c大风歌\u003e\u003e王立群"},{"content":"一：参考 [算法心得] http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogIEEE64Float\n[运算符优先级] https://tool.oschina.net/commons?type=6\n[位运算技巧] https://www.zhihu.com/question/38206659\n[思考题解法] https://www.iteye.com/blog/yacare-1969931\n二：概要 通过本文可以让我们温习下位运算、进制转换，为写出更精良的代码奠定理论基础。现在我们从一个题目说开去：\n问：如何载预计有10亿个int的数据中，剔除其中重复的数据并排序输出?\n分析：首先要进行排序、排重必须得把相关数据加载到内存中，那么要用哪种数据结构来存储呢?\n10 0000 0000 = 10^9\nint[10^9] 需要内存 10^9 * 4(B) =\u0026gt; ((10^9 * 4)/1000 * 1000)(M) =\u0026gt; 4000M =\u0026gt; 4GB\n对于普通32位最大理论内存为4G的PC来说，这个计算资源是无法实现需求的，那么有没有更好的解决方法呢？在此之前先做些知识点温故。\n三：知识点回顾 1.java基本类型 Data Type Default Value Default size range range value boolean false 1 bit char \u0026lsquo;\\u0000\u0026rsquo; 2 byte \u0026lsquo;\\u0000\u0026rsquo;~'\\uFFFF' byte 0 1 byte -2^7~2^7-1 -128~127 short 0 2 byte -2^15~2^15-1 -32768~32767 int 0 4 byte -2^31~2^31-1 0x80000000~0x7fffffff long 0L 8 byte -2^63~2^63-1 float 0.0f 4 byte double 0.0d 8 byte 2.进制 **二进制：**由0，1组成，运算规律是逢二进一，计算机只能识别二进制表示的数据；\n**八进制：**由0、1、2、3、4、5、6、7组成，运算规律是逢八进一；用前导0区别，例如 012；\n**十进制：**由0，1，2、3、4、5、6、7、8、9组成，运算规律是逢十进一；例如 12；\n**十六进制：**由数字0～9以及字母A (10)，B (11)，C (12)，D (13)，E (14)，F (15)组成,大小写均可，运算规律是逢十六进一；例如 0XC；\n2.1 十进制转二进制 除2取余倒排，每发生一次除必须要有一个余数，必须除倒商是0的时候，最后把所得的余数倒排。\n2.2 二进制转十进制 按位乘权相加\n2.3 十进制转八进制 10进制数转换成8进制的方法，和转换为2进制的方法类似，唯一变化：将图1中的基数由2变成8，然后依次计算。\n2.4 八进制转十进制 可参考图2中二进制的计算过程: 进制数第1位的权值为8的0次方，第2位权值为8的1次方，第3位权值为8的2次方，依次计算，公式：第N位 * 8的N-1次方，结果再相加便是最后结果。\n2.5 十进制转十六进制: 10进制数转换成16进制的方法，和转换为2进制的方法类似，唯一变化：将图1中的基数由2变成16，然后依次计算。\n2.6 十六进制转十进制: 第0位的权值为16的0次方，第1位的权值为16的1次方，第2位的权值为16的2次方，依次计算，公式：第N位 * 16的N-1次方，结果再相加便是最后结果。\n2.7 二进制与八进制的转换 1）二进制转八进制，3位二进制位压缩为1位，\n2）八进制转二进制，1位展开为3位\n3）可先转换为十进制在转换为二进制或者八进制\n2.8 二进制与十六进制的转换 1）二进制转十六进制，4位二进制位压缩为1位，\n2）十六进制转二进制，1位展开为4位\n3）可先转换为十进制在转换为二进制或者十六进制\n2.9 八进制与十六进制的转换 可先转换为十进制在转换为十六进制或者八进制\n3.进制存储单位 在计算机的二进制数系统中，位简记为bit，也称为比特，是数据存储的最小单位，每个二进制数字0或1就是一个位(bit)，也就是一比特；也可以把二进制中的0和1看做开关中的“开”和“关”，1表示“开”，0表示“关”。\n8 bit（位）= 1B，也就是一个字节（Byte），然而1KB却不等于1000B，下面是详细的计算规则：\n1B（byte，字节）= 8 bit；\n1KB（Kilobyte，千字节）= 1024B = 2^10 B；\n1MB（Megabyte，兆字节，百万字节，简称“兆”）= 1024KB = 2^20 B；\n1GB（Gigabyte，吉字节，十亿字节，又称“千兆”）= 1024MB = 2^30 B；\n1TB（Terabyte，万亿字节，太字节）= 1024GB = 2^40 B；\n1PB（Petabyte，千万亿字节，拍字节）= 1024TB = 2^50 B；\n4.原码、反码和补码 在计算机内，有符号数（这里的符号指的是正负符号，有符号数指的就是正负数）有3种表示法：原码、反码和补码，所有数据的运算都是采用补码进行的：\n1). 正数的原码，反码，补码都相同；\n2). 负数的有些不同，详情如下：\n**原码：**根据二进制定点表示法，二进制最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。\n**反码：**负数的反码是对其原码逐位取反（0变1，1变0），但符号位除外。\n**补码：**负数的补码是在其反码的末位加1（逢二进一）。\n需要注意的是：求反码的时候，最高位（符号位）是不能被改变的， 正数的符号位是0，负数的符号位是1。\n例子：分别求出5和-5的原码、反码和补码\n5.位运算 位运算只能整型或者字符型，计算时将非二进制转成二进制后在进行按位运算，按位运算不产生进位、借位，最后在还原成十进制。\n5.1 运算符 5.1.1 位运算符 运算符 描述 运算规则 \u0026amp; 按位与 两个位都为1时，结果才为11\u0026amp;1=1 1\u0026amp;0=0 0\u0026amp;1=0 0\u0026amp;0=0 | 按位或 两个位都为0时，结果才为01|1=1 1|0=1 0|1=1 0|0=0 ^ 按位异或 两个位相同为0，相异为11^1=0 1^0=1 0^1=1 0^0=0 ~ 按位取反 0变1，1变0,属于单目运算符 \u0026laquo; 左移 各二进位全部左移若干位，高位丢弃，低位补0 \u0026raquo; 右移 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） 5.1.2 复合赋值运算符 \u0026amp;= 例：a\u0026amp;=b 相当于 a=a\u0026amp;b |= 例：a|=b 相当于 a=a|b \u0026gt;\u0026gt;= 例：a\u0026gt;\u0026gt;=b 相当于 a=a\u0026gt;\u0026gt;b \u0026lt;\u0026lt;= 例：a\u0026lt;\u0026lt;=b 相当于 a=a\u0026lt;\u0026lt;b ^= 例：a^=b 相当于 a=a^b += 例：a+=b 相当于 a=a+b -= 例：a-=b 相当于 a=a-b *= 例：a*=b 相当于 a=a*b /= 例：a/=b 相当于 a=a/b %= 例：a%=b 相当于 a=a%b 5.1.3 逻辑运算符 逻辑运算符有短路现象，\u0026amp;\u0026amp; 如果第一个数为0则会短路第2个结果为0，||如果第一个数非0短路第2个结果为1\n 运算符 含义 效 果 \u0026amp;\u0026amp; 与 将两个表达式连接成一个。两个表达式必须都为 true，整个表达式才为 true || 或 将两个表达式连接成一个。必须有一个或两个表达式为 true，才能使整个表达式为 true。只要其中有一个为 true，那么另外一个就变得无关紧要 ！ 非 反转一个表达式的“真相”。它使一个表达式从 true 变成了 false，或者从 false 变成了 true 5.2 按位运算 计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。\n5.2.1 \u0026amp; 按位与运算 ​ 1 0 0 1 1 \u0026amp; 1 1 0 0 1 ------------------------------ ​ 1 0 0 0 1\n全1为1，有0为0，也叫按位乘\n主要作用：\n1）清零\n如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。\n2）取一个数的指定位\n比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X\u0026amp;Y=0000 1110）即可得到X的指定位。\n3）判断奇偶\n只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a \u0026amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。\n5.2.2 | 按位或运算 ​ 1 0 0 1 1 | 1 1 0 0 1 ------------------------------ ​ 1 1 0 1 1\n有1为1，全0为0，也叫按位加。注意：负数按补码形式参加按位或运算。\n主要作用：置1操作\n5.2.3 ^ 按位异或运算 ​ 1 0 0 1 1 ^ 1 1 0 0 1 ----------------------------- ​ 0 1 0 1 0\n相异为1，相同为0\n异或的几条性质:\n 1、交换律 2、结合律 (a^b)^c == a^(b^c) 3、对于任何数x，都有 x^x=0，x^0=x 4、自反性: a^b^b=a^0=a; 异或运算的用途：\n1）翻转指定位\n比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。\n2）与0相异或值不变\n例如：1010 1110 ^ 0000 0000 = 1010 1110\n3）交换两个数\nvoid Swap(int \u0026amp;a, int \u0026amp;b){ if (a != b){ a ^= b; b ^= a; a ^= b; } } 5.2.4 ~ 按位取反运算 ~ 1 0 0 1 1 ----------------------------- 0 1 1 0 0\n对于一个数按位取反得到的值为该数+1后在乘以-1\n**技巧：(该数+1) * (-1) **\n异或运算的用途：\n1）使一个数的最低位为零\n使a的最低位为0，可以表示为：a \u0026amp; ~1。~1的值为 1111 1111 1111 1110，再按\u0026quot;与\u0026quot;运算，最低位一定为0。因为\u0026quot; ~\u0026ldquo;运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。\n5.2.5 \u0026laquo; 按位左移运算 int a = 8; a \u0026lt;\u0026lt; 3; 移位前：0000 0000 0000 0000 0000 0000 0000 1000 移位后：0000 0000 0000 0000 0000 0000 0100 0000 主要作用：将二进制位按位依序左移n位\n对于一个十进制数左移n位后得到的值为该数乘以2^n的积。\n5.2.6 \u0026raquo; 按位右移运算 向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，如\nunsigned int a = 8; a \u0026gt;\u0026gt; 3; 移位前：0000 0000 0000 0000 0000 0000 0000 1000 移位后：0000 0000 0000 0000 0000 0000 0000 0001 int a = -8; a \u0026gt;\u0026gt; 3; 移位前：1111 1111 1111 1111 1111 1111 1111 1000 移位前：1111 1111 1111 1111 1111 1111 1111 1111 主要作用：将二进制位按位依序右移n位\n对于一个十进制数，若该数为负数 并且 不能被2^n整除，则得到的数为商加-1。\n正数||(负数 \u0026amp;\u0026amp; 能被2^n整除)则结果为=\u0026gt; 数/2^n (负数 \u0026amp;\u0026amp; 不能被2^n整除)则结果为=\u0026gt;数/2^n+(-1)\n5.3 位运算技巧 1、 a \u0026amp; a = a a | a = a a ^ a = 0 2、 a \u0026amp; 0 = 0 a | 0 = a a ^ 0 = a 3、 a | ( a \u0026amp; b ) = a a \u0026amp; ( a | b ) = a 4、交换值 a ^= b; b ^= a; a ^= b; 5、判断奇偶(取出最后一位) a \u0026amp; 1 等价于 a % 2(结果等于,位运算效率高) 6、比较两值是否相等 a ^ b ==0 7、i+1位 置1 a |=1\u0026lt;\u0026lt;i 8、i+1位 置0 a \u0026amp;=~(1\u0026lt;\u0026lt;i) 9、取出i+1位(联系第5点) a \u0026amp; (1\u0026lt;\u0026lt;i) 10、在对应i+1位，插入b的对应位； a |=1\u0026lt;\u0026lt;i; （a的bit位置1） a \u0026amp; (b \u0026amp; 1\u0026lt;\u0026lt;i) （与b的bit位相与） 11、删除最后的1； a \u0026amp; (a-1) 12、负数 -a = ~a+1 13、仅保留最后一个1; a\u0026amp;(-a) 14、得到全1 ~0 15、保留最后i-1位； a \u0026amp; ((1\u0026lt;\u0026lt;i)-1) 16、清零最后i-1位； a \u0026amp; ~((1\u0026lt;\u0026lt;i)-1) 17、判断最高位是否为1 a\u0026amp;lt;0 18、得到最高位的1； a = a |(a\u0026gt;\u0026gt;1); a = a |(a\u0026gt;\u0026gt;2); a = a |(a\u0026gt;\u0026gt;4); a = a |(a\u0026gt;\u0026gt;8); a = a |(a\u0026gt;\u0026gt;16); return (a+1)\u0026gt;\u0026gt;1; 四：问题解答 对于概要的问题，有没有更好的方式来解决呢，答案是肯定的。\n计算机中最小的存储单位是bit，它的值只有两个0或1，假如刚好有10亿个int的数据，那么我们是否可以构造出10个bit,然后以我们想象中的方式从左到右平铺开来，然后把这10亿个int的数据从小到大一一对应到这些bit中，如果数值存在则标记为1，那么所需空间为10^9位，换算成10^9/8/1000/1000 约为125M，\n由于两位bit可以表示4位数即2^2，那么对于4个byte能表示的数据量为2^32个(bit)，2^32 bit =2^32 / 2^3(byte) = 2^29 byte= 512M；int数据范围为【-2^31,2^31-1】即[-21,4748,3648 ~ 21,4748,3648-1]\n那么把10亿个数据平铺开的效果如下：\n那么可以得出\n1.ilong bitIndex = 任意int数 + (1l \u0026laquo; 31); 得出数字在理论bit数组中的位置2.int byteIndex = bitIndex / 8; 得出数字在真实byte[]数组的位置3.int innerByteIndex = bitIndex % 8; 得出数字在真实byte[byteIndex]中8个位置中的哪个位置4.byteData[index] = (byte) (byteData[byteIndex ] | (1 \u0026lt; innerByteIndex)); 将定位到的innerByteIndex位置如果为0设置为1\n那么可以得出\n1.int bitIndex = 任意int数; 得出数字在理论bit数组中的位置2.int byteIndex = bitIndex / 8; 得出数字在真实byte[]数组的位置3.int innerByteIndex = bitIndex % 8; 得出数字在真实byte[byteIndex]中8个位置中的哪个位置4.byteData[index] = (byte) (byteData[byteIndex ] | (1 \u0026lt; innerByteIndex)); 将定位到的innerByteIndex位置如果为0设置为1\n一下为有符号int的场景测试代码\nimport java.util.Random; public class BigDataSort { //数据容量 private final int CAPACITY = 1 000 000 000; // 定义一个byte数组缓存所有的数据 private byte[] byteData = new byte[1 \u0026lt;\u0026lt; 29]; public static void main(String[] args) { BigDataSort ms = new BigDataSort(); Random random = new Random(); for (int i = 0; i \u0026lt; CAPACITY; i++) { int num = random.nextInt(); System.out.println(\u0026quot;读取了第 \u0026quot; + (i + 1) + \u0026quot;\\t个数: \u0026quot; + num); ms.setNumBit(num); } ms.output(); } /** * 读取数据，并将对应数数据的 到对应的bit中，并返回byte数组 * @param num 读取的数据 */ private void setNumBit(int num) { //获取num数据对应bit数组（虚拟）的索引 long bitIndex = num + (1l \u0026lt;\u0026lt; 31); //bit数组（虚拟）在byte数组中的索引 int index = (int) (bitIndex / 8); //bitIndex 在byte[]数组索引index 中的具体位置 int innerIndex = (int) (bitIndex % 8); System.out.println(\u0026quot;byte[\u0026quot; + index + \u0026quot;] 中的索引：\u0026quot; + innerIndex); byteData[index] = (byte) (byteData[index] | (1 \u0026lt;\u0026lt; innerIndex)); return; } /** * 输出数组中的数据 */ private void output() { int count = 0; for (int i = 0; i \u0026lt; byteData.length; i++) { for (int j = 0; j \u0026lt; 8; j++) { //判断是否对应的bit位为1则输出原始数据 if (!(((byteData[i]) \u0026amp; (1 \u0026lt;\u0026lt; j)) == 0)) { count++; int number = (int) ((((long) i * 8 + j) - (1l \u0026lt;\u0026lt; 31))); System.out.println(\u0026quot;取出的第 \u0026quot; + count + \u0026quot;\\t个数: \u0026quot; + number); } } } } } 五：java无符号处理 有符号数（signed）可以表示特定类型规定范围内的整数（包括负数），而无符号数只能表示非负数（0及正数）\njava unsigned表示 // java 中没有 unsigned，所以为了实现 unsigned，需要使用比原本类型更大的类型，通过位运算获取其 unsigned 的值 // unsigned byte \u0026amp; short -\u0026gt; int，unsigned int -\u0026gt; long private static int getUnsignedByte(byte b) { return b \u0026amp; 0x0FF; } private static int getUnsignedShort(short data) { return data \u0026amp; 0x0FFFF; } private static long getUnsignedInt(int data) { // data \u0026amp; 0xFFFFFFFF 和 data \u0026amp; 0xFFFFFFFFL 结果是不同的，需要注意，有可能与 JDK 版本有关 return data \u0026amp; 0xFFFFFFFFL; } short、int 和 long 转 bytes import java.nio.ByteBuffer; import java.nio.ByteOrder; ByteOrder order = ByteOrder.LITTLE_ENDIAN; // long long l = 2147483648L; byte[] bytes = ByteBuffer.allocate(8).order(order).putLong(l).array(); long data = ByteBuffer.wrap(bytes, 0, bytes.length).order(order).getLong(); // int int i = 123456; byte[] bytes = ByteBuffer.allocate(4).order(order).putInt(i).array(); int data = ByteBuffer.wrap(bytes, 0, bytes.length).order(order).getInt(); // short short s = 32767; byte[] bytes = ByteBuffer.allocate(2).order(order).putShort(s).array(); int data = ByteBuffer.wrap(bytes, 0, bytes.length).order(order).getShort(); String转Byte import java.nio.charset.Charset; Charset charset = Charset.forName(\u0026quot;UTF-8\u0026quot;); String data = \u0026quot;abc\u0026quot;; byte[] bytes = data.getBytes(charset); String newData = new String(bytes, 0, bytes.length, charset); ","dateformatted":"16, March 2022","dateiso":"2022-03-16T15:42:33Z","ref":"/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"\n 一：参考 [算法心得] http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogIEEE64Float\n[运算符优先级] https://tool.oschina.net/commons?type=6\n[位运算技巧] https://www.zhihu.com/question/38206659\n[思考题解法] https://www.iteye.com/blog/yacare-1969931\n二：概要 通过本文可以让我们温习下位运算、进制转换，为写出更精良的代码奠定理论基础。现在我们从一个题目说开去：\n问：如何载预计有10亿个int的数据中，剔除其中重复的数据并排序输出?\n分析：首先要进行排序、排重必须得把相关数据加载到内存中，那么要用哪种数据结构来存储呢?\n10 0000 0000 = 10^9\nint[10^9] 需要内存 10^9 * 4(B) =\u0026gt; ((10^9 * 4)/1000 * 1000)(M) =\u0026gt; 4000M =\u0026gt; 4GB\n\n","tags":["java","基础"],"title":"位运算基础知识"},{"content":"1.参考 【alibaba canal】https://github.com/alibaba/canal\n【mysql binlog】https://dev.mysql.com/doc/refman/8.0/en/binary-log.html\n【mysql event】https://dev.mysql.com/doc/internals/en/event-meanings.html\n【mysqlbinlog 命令】https://dev.mysql.com/doc/refman/8.0/en/mysqlbinlog.html\n2.基本简介 canal [kə\u0026rsquo;næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费\n2.1 mysql主备复制实现 master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）； slave将master的binary log events拷贝到它的中继日志(relay log)； slave重做中继日志中的事件，将改变反映它自己的数据。 2.2 mysql binglog 数据包格式 mysql 事件体目前有一下版本\n v1：在 MySQL 3.23 中使用\n+=====================================+ | event | timestamp 0 : 4 | | header +----------------------------+ | | type_code 4 : 1 | | +----------------------------+ | | server_id 5 : 4 | | +----------------------------+ | | event_length 9 : 4 | +=====================================+ | event | fixed part 13 : y | | data +----------------------------+ | | variable part | +=====================================+ 标头长度 = 13 字节 数据长度 = (event_length - 13) 字节 y 特定于事件类型。 v3：在 MySQL 4.0.2 到 4.1 中使用\n+=====================================+ | event | timestamp 0 : 4 | | header +----------------------------+ | | type_code 4 : 1 | | +----------------------------+ | | server_id 5 : 4 | | +----------------------------+ | | event_length 9 : 4 | | +----------------------------+ | | next_position 13 : 4 | | +----------------------------+ | | flags 17 : 2 | +=====================================+ | event | fixed part 19 : y | | data +----------------------------+ | | variable part | +=====================================+ 标头长度 = 19 字节 数据长度 = (event_length - 19) 字节 y 特定于事件类型。 v4：用于 MySQL 5.0 及更高版本\n+=====================================+ | event | timestamp 0 : 4 | | header +----------------------------+ | | type_code 4 : 1 | | +----------------------------+ | | server_id 5 : 4 | | +----------------------------+ | | event_length 9 : 4 | | +----------------------------+ | | next_position 13 : 4 | | +----------------------------+ | | flags 17 : 2 | | +----------------------------+ | | extra_headers 19 : x-19 | +=====================================+ | event | fixed part x : y | | data +----------------------------+ | | variable part | +=====================================+ 标头长度 = x 字节 数据长度 = (event_length - x) 字节 固定数据长度 = y 字节可变数据长度 = (event_length - (x + y)) 字节 2.2 canal工作原理 canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议 mysql master收到dump请求，开始推送binary log给slave(也就是canal) canal解析binary log对象(原始为byte流) 2.3 canal架构 说明：\n server代表一个canal运行实例，对应于一个jvm instance对应于一个数据队列 （1个server对应1..n个instance) instance模块：\n eventParser (数据源接入，模拟slave协议和master进行交互，协议解析)\n eventSink (Parser和Store链接器，进行数据过滤，加工，分发的工作)\n eventStore (数据存储)\n metaManager (增量订阅\u0026amp;消费信息管理器)\n canal-instance instance代表了一个实际运行的数据队列，包括了EventPaser,EventSink,EventStore等组件。\n抽象了CanalInstanceGenerator，主要是考虑配置的管理方式：\n manager方式： 和你自己的内部web console/manager系统进行对接。(目前主要是公司内部使用) spring方式：基于spring xml + properties进行定义，构建spring配置. canal-event-parser 整个parser过程大致可分为几步：\n Connection获取上一次解析成功的位置 (如果第一次启动，则获取初始指定的位置或者是当前数据库的binlog位点) Connection建立链接，发送BINLOG_DUMP指令 // 0. write command number // 1. write 4 bytes bin-log position to start at // 2. write 2 bytes bin-log flags // 3. write 4 bytes server id of the slave // 4. write bin-log file name Mysql开始推送Binaly Log 接收到的Binaly Log的通过Binlog parser进行协议解析，补充一些特定信息 // 补充字段名字，字段类型，主键信息，unsigned类型处理 传递给EventSink模块进行数据存储，是一个阻塞操作，直到存储成功 存储成功后，定时记录Binaly Log位置 canal-event-sink 说明：\n 数据过滤：支持通配符的过滤模式，表名，字段内容等 数据路由/分发：解决1:n (1个parser对应多个store的模式) 数据归并：解决n:1 (多个parser对应1个store) 数据加工：在进入store之前进行额外的处理，比如join 数据1:n业务\n 为了合理的利用数据库资源， 一般常见的业务都是按照schema进行隔离，然后在mysql上层或者dao这一层面上，进行一个数据源路由，屏蔽数据库物理位置对开发的影响，阿里系主要是通过cobar/tddl来解决数据源路由问题。\n 所以，一般一个数据库实例上，会部署多个schema，每个schema会有由1个或者多个业务方关注\n 数据n:1业务\n 同样，当一个业务的数据规模达到一定的量级后，必然会涉及到水平拆分和垂直拆分的问题，针对这些拆分的数据需要处理时，就需要链接多个store进行处理，消费的位点就会变成多份，而且数据消费的进度无法得到尽可能有序的保证。\n 所以，在一定业务场景下，需要将拆分后的增量数据进行归并处理，比如按照时间戳/全局id进行排序归并.\n canal-event-store 目前仅实现了Memory内存模式，后续计划增加本地file存储，mixed混合模式 借鉴了Disruptor的RingBuffer的实现思路 RingBuffer设计：\n定义了3个cursor\n Put : Sink模块进行数据存储的最后一次写入位置 Get : 数据订阅获取的最后一次提取位置 Ack : 数据消费成功的最后一次消费位置 借鉴Disruptor的RingBuffer的实现，将RingBuffer拉直来看： 实现说明：\n Put/Get/Ack cursor用于递增，采用long型存储 buffer的get操作，通过取余或者与操作。(与操作： cusor \u0026amp; (size - 1) , size需要为2的指数，效率比较高) 2.4 canal HA设计 canal的ha分为两部分，canal server和canal client分别有对应的ha实现\n canal server: 为了减少对mysql dump的请求，不同server上的instance要求同一时间只能有一个处于running，其他的处于standby状态. canal client: 为了保证有序性，一份instance同一时间只能由一个canal client进行get/ack/rollback操作，否则客户端接收无法保证有序。 整个HA机制的控制主要是依赖了zookeeper的几个特性，watcher和EPHEMERAL节点(和session生命周期绑定)。\n大致步骤：\n canal server要启动某个canal instance时都先向zookeeper进行一次尝试启动判断 (实现：创建EPHEMERAL节点，谁创建成功就允许谁启动) 创建zookeeper节点成功后，对应的canal server就启动对应的canal instance，没有创建成功的canal instance就会处于standby状态 一旦zookeeper发现canal server A创建的节点消失后，立即通知其他的canal server再次进行步骤1的操作，重新选出一个canal server启动instance. canal client每次进行connect时，会首先向zookeeper询问当前是谁启动了canal instance，然后和其建立链接，一旦链接不可用，会重新尝试connect. Canal Client的方式和canal server方式类似，也是利用zookeeper的抢占EPHEMERAL节点的方式进行控制.\n2.5 canal client client-server交互 get/ack/rollback协议介绍：\n Message getWithoutAck(int batchSize)，允许指定batchSize，一次可以获取多条，每次返回的对象为Message，包含的内容为： a. batch id 唯一标识 b. entries 具体的数据对象，对应的数据对象格式：EntryProtocol.proto void rollback(long batchId)，顾命思议，回滚上次的get请求，重新获取数据。基于get获取的batchId进行提交，避免误操作 void ack(long batchId)，顾命思议，确认已经消费成功，通知server删除数据。基于get获取的batchId进行提交，避免误操作 canal的get/ack/rollback协议和常规的jms协议有所不同，允许get/ack异步处理，比如可以连续调用get多次，后续异步按顺序提交ack/rollback，项目中称之为流式api.\n流式api设计的好处：\n get/ack异步化，减少因ack带来的网络延迟和操作成本 (99%的状态都是处于正常状态，异常的rollback属于个别情况，没必要为个别的case牺牲整个性能) get获取数据后，业务消费存在瓶颈或者需要多进程/多线程消费时，可以不停的轮询get数据，不停的往后发送任务，提高并行化. (作者在实际业务中的一个case：业务数据消费需要跨中美网络，所以一次操作基本在200ms以上，为了减少延迟，所以需要实施并行化) 流式api设计：\n 每次get操作都会在meta中产生一个mark，mark标记会递增，保证运行过程中mark的唯一性 每次的get操作，都会在上一次的mark操作记录的cursor继续往后取，如果mark不存在，则在last ack cursor继续往后取 进行ack时，需要按照mark的顺序进行数序ack，不能跳跃ack. ack会删除当前的mark标记，并将对应的mark位置更新为last ack cusor 一旦出现异常情况，客户端可发起rollback情况，重新置位：删除所有的mark, 清理get请求位置，下次请求会从last ack cursor继续往后取 数据对象格式 Entry Header logfileName [binlog文件名] logfileOffset [binlog position] executeTime [binlog里记录变更发生的时间戳] schemaName [数据库实例] tableName [表名] eventType [insert/update/delete类型] entryType [事务头BEGIN/事务尾END/数据ROWDATA] storeValue [byte数据,可展开，对应的类型为RowChange] RowChange isDdl\t[是否是ddl变更操作，比如create table/drop table] sql\t[具体的ddl sql] rowDatas\t[具体insert/update/delete的变更数据，可为多条，1个binlog event事件可对应多条变更，比如批处理] beforeColumns [Column类型的数组] afterColumns [Column类型的数组] Column index\t[column序号] sqlType\t[jdbc type] name\t[column name] isKey\t[是否为主键] updated\t[是否发生过变更] isNull\t[值是否为null] value\t[具体的内容，注意为文本] 说明：\n 可以提供数据库变更前和变更后的字段内容，针对binlog中没有的name,isKey等信息进行补全 可以提供ddl的变更语句 3.cannel 源码 3.1 canal启动 public void start() { super.start(); if (!embeddedServer.isStart()) { embeddedServer.start(); } //1.创建canal server this.bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool())); bootstrap.setOption(\u0026quot;child.keepAlive\u0026quot;, true); bootstrap.setOption(\u0026quot;child.tcpNoDelay\u0026quot;, true); //2.构造对应的pipeline bootstrap.setPipelineFactory(() -\u0026gt; { ChannelPipeline pipelines = Channels.pipeline(); pipelines.addLast(FixedHeaderFrameDecoder.class.getName(), new FixedHeaderFrameDecoder()); // support to maintain child socket channel. pipelines.addLast(HandshakeInitializationHandler.class.getName(), new HandshakeInitializationHandler(childGroups)); pipelines.addLast(ClientAuthenticationHandler.class.getName(), new ClientAuthenticationHandler(embeddedServer)); //会话处理 SessionHandler sessionHandler = new SessionHandler(embeddedServer); pipelines.addLast(SessionHandler.class.getName(), sessionHandler); return pipelines; }); //3.启动 默认监听1111端口 if (StringUtils.isNotEmpty(ip)) { this.serverChannel = bootstrap.bind(new InetSocketAddress(this.ip, this.port)); } else { this.serverChannel = bootstrap.bind(new InetSocketAddress(this.port)); } } public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception { ChannelBuffer buffer = (ChannelBuffer) e.getMessage(); Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array()); ClientIdentity clientIdentity = null; switch (packet.getType()) { case SUBSCRIPTION: break; case UNSUBSCRIPTION: break; case GET: break; case CLIENTACK: break; case CLIENTROLLBACK: break; default: break; } } 3.2 client代码 3.2.1 订阅数据-socket public static void main(String args[]) { // 创建链接 CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(AddressUtils.getHostIp(),11111), \u0026quot;example\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;\u0026quot;); int batchSize = 1000; try { connector.connect(); connector.subscribe(\u0026quot;.*\\\\..*\u0026quot;); connector.rollback(); while (isRunning) { // 获取指定数量的数据 Message message = connector.getWithoutAck(batchSize); long batchId = message.getId(); int size = message.getEntries().size(); if(size \u0026gt; 0){ printEntry(batchId,message.getEntries()); } // 提交确认 connector.ack(batchId); // 处理失败, 回滚数据 // connector.rollback(batchId); } } finally { connector.disconnect(); } } private static void printEntry(long batchId,List\u0026lt;Entry\u0026gt; entrys) { for (Entry entry : entrys) { if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) { continue; } //数据反序列化 RowChange rowChage = RowChange.parseFrom(entry.getStoreValue()); EventType eventType = rowChage.getEventType(); for (RowData rowData : rowChage.getRowDatasList()) { if (eventType == EventType.DELETE) { printColumn(rowData.getBeforeColumnsList()); } else if (eventType == EventType.INSERT) { printColumn(rowData.getAfterColumnsList()); } else { System.out.println(\u0026quot;-------\u0026amp;gt; before\u0026quot;); printColumn(rowData.getBeforeColumnsList()); System.out.println(\u0026quot;-------\u0026amp;gt; after\u0026quot;); printColumn(rowData.getAfterColumnsList()); } } } } private static void printColumn(List\u0026lt;Column\u0026gt; columns) { for (Column column : columns) { System.out.println(column.getName() + \u0026quot; : \u0026quot; + column.getValue() + \u0026quot; update=\u0026quot; + column.getUpdated()); } } 3.2.2 连接canal server private InetSocketAddress doConnect() throws CanalClientException { try { channel = SocketChannel.open(); channel.socket().setSoTimeout(soTimeout); SocketAddress address = getAddress(); if (address == null) { address = getNextAddress(); } //1.连接 server channel.connect(address); //读channel readableChannel = Channels.newChannel(channel.socket().getInputStream()); //写channel writableChannel = Channels.newChannel(channel.socket().getOutputStream()); //2.握手 Packet p = Packet.parseFrom(readNextPacket()); if (p.getVersion() != 1) { throw new CanalClientException(\u0026quot;unsupported version at this client.\u0026quot;); } if (p.getType() != PacketType.HANDSHAKE) { throw new CanalClientException(\u0026quot;expect handshake but found other type.\u0026quot;); } Handshake handshake = Handshake.parseFrom(p.getBody()); supportedCompressions.add(handshake.getSupportedCompressions()); // ByteString seed = handshake.getSeeds(); // seed for auth String newPasswd = password; if (password != null) { // encode passwd newPasswd = SecurityUtil.byte2HexStr(SecurityUtil.scramble411(password.getBytes(), seed.toByteArray())); } ClientAuth ca = ClientAuth.newBuilder() .setUsername(username != null ? username : \u0026quot;\u0026quot;) .setPassword(ByteString.copyFromUtf8(newPasswd != null ? newPasswd : \u0026quot;\u0026quot;)) .setNetReadTimeout(idleTimeout) .setNetWriteTimeout(idleTimeout) .build(); //3.鉴权客户端 writeWithHeader(Packet.newBuilder() .setType(PacketType.CLIENTAUTHENTICATION) .setBody(ca.toByteString()) .build() .toByteArray()); //4.连接成确认 Packet ack = Packet.parseFrom(readNextPacket()); if (ack.getType() != PacketType.ACK) { throw new CanalClientException(\u0026quot;unexpected packet type when ack is expected\u0026quot;); } Ack ackBody = Ack.parseFrom(ack.getBody()); if (ackBody.getErrorCode() \u0026gt; 0) { throw new CanalClientException(\u0026quot;something goes wrong when doing authentication: \u0026quot; + ackBody.getErrorMessage()); } connected = true; return new InetSocketAddress(channel.socket().getLocalAddress(), channel.socket().getLocalPort()); } catch (IOException | NoSuchAlgorithmException e) { throw new CanalClientException(e); } } ","dateformatted":"16, October 2021","dateiso":"2021-10-16T15:42:33Z","ref":"/canal-mysql-binlog%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90/","summary":"\n 1.参考 【alibaba canal】https://github.com/alibaba/canal\n【mysql binlog】https://dev.mysql.com/doc/refman/8.0/en/binary-log.html\n【mysql event】https://dev.mysql.com/doc/internals/en/event-meanings.html\n【mysqlbinlog 命令】https://dev.mysql.com/doc/refman/8.0/en/mysqlbinlog.html\n2.基本简介 canal [kə\u0026rsquo;næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费\n2.1 mysql主备复制实现 master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）； slave将master的binary log events拷贝到它的中继日志(relay log)； slave重做中继日志中的事件，将改变反映它自己的数据。 2.\n\n","tags":["canal"],"title":"canal-mysql binlog日志解析"},{"content":"一：概要 1.1.参考 二：附录 log pod https://kubernetes.io/docs/concepts/cluster-administration/logging/\napiVersion: v1 kind: Pod metadata: name: counter spec: containers: - name: count image: busybox:1.28 args: [/bin/sh, -c, 'i=0; while true; do echo \u0026quot;$i: $(date)\u0026quot;; i=$((i+1)); sleep 1; done'] ","dateformatted":"16, October 2021","dateiso":"2021-10-16T15:42:33Z","ref":"/k8s/","summary":"\n 一：概要 1.1.参考 二：附录 log pod https://kubernetes.io/docs/concepts/cluster-administration/logging/\napiVersion: v1 kind: Pod metadata: name: counter spec: containers: - name: count image: busybox:1.28 args: [/bin/sh, -c, 'i=0; while true; do echo \u0026quot;$i: $(date)\u0026quot;; i=$((i+1)); sleep 1; done'] \n\n","tags":["go"],"title":"K8S"},{"content":"1.maven-wrapper安装使用 安装 在项目中使用命令安装mvn -N io.takari:maven:0.7.7:wrapper，参考官网 ,如果需要指定maven版本则使用mvn -N io.takari:maven:0.7.7:wrapper -Dmaven=3.5.4,安装完成后，目录如下\nmy-project ├── .mvn │ └── wrapper │ ├── MavenWrapperDownloader.java │ ├── maven-wrapper.jar │ └── maven-wrapper.properties ├── mvnw ├── mvnw.cmd ├── pom.xml └── src ├── main │ ├── java │ └── resources └── test ├── java └── resources 使用 参考mvn命令, 指令切换成mvnw如: linux下 ./mvnw clean install windown下 mvnw.cmd clean install ","dateformatted":"16, October 2021","dateiso":"2021-10-16T15:42:33Z","ref":"/maven-wrapper%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","summary":"\n 1.maven-wrapper安装使用 安装 在项目中使用命令安装mvn -N io.takari:maven:0.7.7:wrapper，参考官网 ,如果需要指定maven版本则使用mvn -N io.takari:maven:0.7.7:wrapper -Dmaven=3.5.4,安装完成后，目录如下\nmy-project ├── .mvn │ └── wrapper │ ├── MavenWrapperDownloader.java │ ├── maven-wrapper.\n\n","tags":["maven"],"title":"maven-wrapper基础使用"},{"content":"1.参考 【mysql8.0手册】https://dev.mysql.com/doc/refman/8.0/en/\n【mysql doc】https://dev.mysql.com/doc/\n【alibaba canal】https://github.com/alibaba/canal\n2.概要 通过本文可以了解主从同步原理，快速搭建一个主从环境,实现复制场景，并且利用canal实现订阅binglog日志，实现跨实例同步。\n中间件版本:\nmysql-8.0.27\ncanal 1.1.5\n3.主从同步 创建容错系统的最常见方法就是冗余，复制模式分普通复制、组复制，普通复制即传统的 MySQL复制 提供了一种简单的源(mater)到副本复制方法,。\nmaster-slave syn MySQL 复制功能允许服务器 -主服务器 - 将所有更改发送到另一台服务器 -从服务器 -从服务器尝试应用所有更改以与主服务器保持同步。复制工作如下：\n 每当 master 的数据库被修改时，更改都会写入一个文件，即所谓的二进制日志或binlog。这是由执行修改数据库的查询的客户端线程完成的。\n master 有一个线程，称为dump thread，它不断读取 master 的 binlog 并将其发送给 slave。\n slave有一个线程，称为IO线程，它接收master的dump线程发送的binlog，并将其写入一个文件： relay log，show variables like \u0026lsquo;%relay%'。\n 从服务器有另一个线程，称为 SQL 线程，它不断读取中继日志并将更改应用到从服务器。\n MySQL 复制功能使用三个主线程实现，一个在源服务器上，两个在副本上：\n 二进制日志转储线程。 当副本连接时，源创建一个线程将二进制日志内容发送到副本。该线程可以SHOW PROCESSLIST在源上的输出中标识为Binlog Dump线程。\n二进制日志转储线程获取源二进制日志的锁，用于读取要发送到副本的每个事件。一旦事件被读取，锁就会被释放，甚至在事件被发送到副本之前。\n 复制 I/O 接收器线程。 当START REPLICA在副本服务器上发出一条语句时，副本会创建一个 I/O（接收器）线程，该线程连接到源并要求它发送记录在其二进制日志中的更新。\n复制接收者线程读取源Binlog Dump线程发送的更新（参见上一项）并将它们复制到包含副本中继日志的本地文件。\n该线程的状态显示 Slave_IO_running在 的输出中 SHOW SLAVE STATUS。\n 复制 SQL 应用程序线程。 副本创建一个 SQL（应用程序）线程来读取由复制接收器线程写入的中继日志并执行其中包含的事务。\n 异步复制 半同步复制 组复制 Mysql集群 InnoDB ReplicaSet 不提供 InnoDB Cluster 提供的所有功能，例如自动故障转移或多主模式。但是您可以手动切换或故障转移到辅助实例，例如在发生故障时。您甚至可以采用现有的复制部署，然后将其作为 InnoDB ReplicaSet 进行管理。\nmysql集群主要基于 MySQL Group Replication构建，提供自动成员管理、容错、自动故障转移等功能。\n4.环境准备 4.1.环境目录结构 ├─mysql-8.0.27-winx64 ├─master │ └─data │ └─my.ini ├─slave_1 │ └─data │ └─my.ini └─slave_2 │ └─data │ └─my.ini └─slave_canal │ ├─bin │ ├─conf │ ├─lib │ ├─logs │ │ ├─canal │ │ └─example │ └─plugin 4.2.安装mysql 下载https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.27-winx64.zip\n4.2.1.master 1).配置my.ini [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [mysqld] # 设置3307端口 port = 3307 # 设置mysql的安装目录 basedir=E:/db/mysql_cluster/mysql-8.0.27-winx64 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 datadir=E:/db/mysql_cluster/master/data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB explicit_defaults_for_timestamp=true log-error=E:/db/mysql_cluster/master/error.log pid-file=E:/db/mysql_cluster/master/mysql.pid socket =E:/db/mysql_cluster/master/mysql.socket # master配置 server-id = 1 log_bin = E:/db/mysql_cluster/master/bin.log max_binlog_size = 20M slow_query_log = 1 #(可选配置）要同步的数据库名，要同步多个数据库，就多加几个replicate-db-db=数据库名 binlog-do-db=test #（可选配置）要忽略的数据库 binlog-ignore-db=mysql binlog-ignore-db=sys binlog-ignore-db=information_schema binlog-ignore-db=performance_schema 2).安装mysql 1.创建配置文件 2.cmd初始化 \u0026gt;\u0026gt;E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysqld --defaults-file=E:/db/mysql_cluster/master/my.ini --initialize --basedir=E:/db/mysql_cluster/mysql-8.0.27-winx64 --datadir=E:/db/mysql_cluster/master/data 3.cmd运行 \u0026gt;\u0026gt;E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysqld --defaults-file=E:/db/mysql_cluster/master/my.ini 4.修改密码 查看 mster/error.log 临时密码，连接mysql修改root密码 \u0026gt;\u0026gt;E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysql -h localhost -P 3307 -u root -p \u0026gt;\u0026gt;use mysql; \u0026gt;\u0026gt;alter user 'root'@'localhost' identified with mysql_native_password by '123456'; \u0026gt;\u0026gt;flush privileges; \u0026gt;\u0026gt;exit; 3).配置slave用户 创建slaveuser，允许从slave节点连接复制binlog。\n授予所有权限GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' \nmysql\u0026gt;CREATE USER slaveuser@'%' IDENTIFIED WITH mysql_native_password BY '123456'; mysql\u0026gt;grant replication slave on *.* to slaveuser@'%'; mysql\u0026gt;GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slaveuser'@'%'; mysql\u0026gt;flush privileges; mysql\u0026gt;show grants for slaveuser@'%'; 4).查看master状态 mysql\u0026gt; show master status； 4.2.2.slave 参考 https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html slave配置参数\n1).配置my.ini [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [mysqld] # 设置 3308 端口 port = 3308 # 设置mysql的安装目录 basedir=E:/db/mysql_cluster/mysql-8.0.27-winx64 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 datadir=E:/db/mysql_cluster/slave_1/data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB explicit_defaults_for_timestamp=true log-error=E:/db/mysql_cluster/slave_1/error.log pid-file=E:/db/mysql_cluster/slave_1/mysql.pid socket =E:/db/mysql_cluster/slave_1/mysql.socket # master配置 log_bin = E:/db/mysql_cluster/slave_1/bin.log server-id = 2 read_only = 1 max_binlog_size = 20M slow_query_log = 1 #(可选配置）要同步的数据库名，要同步多个数据库，就多加几个replicate-db-db=数据库名 binlog-do-db=test #（可选配置）要忽略的数据库 binlog-ignore-db=mysql binlog-ignore-db=sys binlog-ignore-db=information_schema binlog-ignore-db=performance_schema 2）.安装mysql 参考maseter\n3).配置slave 参考 master【查看master状态】\n# 配置连接master信息 mysql\u0026gt; CHANGE MASTER TO MASTER_HOST='127.0.0.1', master_port = 3307,MASTER_USER='slaveuser', MASTER_PASSWORD='123456', MASTER_LOG_FILE='bin.000001', MASTER_LOG_POS=1673,master_connect_retry = 15,master_retry_count = 0; mysql\u0026gt; start slave; mysql\u0026gt; show slave status; # 删除slave配置信息 # stop slave; # reset slave all; 创建只读用户，防止用root操作同步库\nCREATE USER 'readuser'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; GRANT SELECT ON *.* TO 'readuser'@'%'; FLUSH PRIVILEGES; 4).查看master状态 mysql\u0026gt; show master status； 4.3 测试 在master执行一下语句，查看slave库是否同步。\nCREATE DATABASE IF NOT EXISTS test DEFAULT CHARSET utf8 COLLATE utf8_general_ci;` create table t_data ( id bigint(20) not null auto_increment comment '主键', name varchar(32) comment '名称', create_time datetime default CURRENT_TIMESTAMP comment '创建时间', update_time datetime default CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP comment '更新时间', primary key (id) ) ENGINE=InnoDB COMMENT='测试表'; insert into t_data(name) values(1); 5.开启GTID 全局事务标识符 (GTID) 是在源服务器（源）上创建并与提交的每个事务相关联的唯一标识符。此标识符不仅对于它起源的服务器是唯一的，而且对于给定复制拓扑中的所有服务器也是唯一的。\n从MySQL5.6开始增加了强大的GTID（Global Transaction ID，全局事务ID）这个特性，用来强化数据库的主备一致性， 故障恢复， 以及容错能力。用于取代过去传统的主从复制（即：基于binlog和position的异步复制）。\n借助GTID，在发生主备切换的情况下，MySQL的其他slave可以自动在新主上找到正确的复制位置，这大大简化了复杂复制拓扑下集群的维护，也减少了人为设置复制position发生误操作的风险。另外，基于GTID的复制可以忽略已经执行过的事务，减少了数据发生不一致的风险。\n参考：https://dev.mysql.com/doc/refman/8.0/en/replication-mode-change-online-enable-gtids.html\n1.修改master、slave 节点my.conf or my.ini # GTID gtid_mode=ON enforce_gtid_consistency=ON 2.设置salve节点 mysql\u0026gt; E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysql -h localhost -P 3308 -u root -p mysql\u0026gt; STOP SLAVE ; mysql\u0026gt; CHANGE MASTER TO MASTER_HOST='127.0.0.1', master_port = 3307,MASTER_USER='slaveuser', MASTER_PASSWORD='123456',MASTER_AUTO_POSITION = 1; mysql\u0026gt; START SLAVE ; Or from MySQL 8.0.22 / 8.0.23: STOP REPLICA ; CHANGE REPLICATION SOURCE TO MASTER_HOST='127.0.0.1', master_port = 3307,MASTER_USER='slaveuser', MASTER_PASSWORD='123456',SOURCE_AUTO_POSITION = 1; START REPLICA ; 3.查看状态 show slave status \\G; show variables like 'gtid_%'; 6.canal slave 6.1下载 canal https://github.com/alibaba/canal/releases\n6.2 配置 1）确认mysql配置 [mysqld] log-bin=mysql-bin #添加这一行就ok binlog-format=ROW #选择row模式 mysql\u0026gt; show variables like 'binlog_format'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | binlog_format | ROW | +---------------+-------+ mysql\u0026gt; show variables like 'log_bin'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | log_bin | ON | +---------------+-------+ 2）解压到目录./slave_canal 3) 修改配置 slave_canal/conf/example/instance.properties # 基础配置 canal.port = 11111 #端口 canal.serverMode = tcp # canal client的模式: tcp kafka rocketMQ # 配置destinations canal.destinations = instance_1 # 指定实例 canal.conf.dir = ../conf # 实例配置目录 canal.auto.scan = true # 自动扫描实列目录,实现实列动态加载、移除 canal.auto.scan.interval = 5 canal.auto.reset.latest.pos.mode = false canal.instance.tsdb.spring.xml = classpath:spring/tsdb/h2-tsdb.xml canal.instance.global.mode = spring canal.instance.global.lazy = false canal.instance.global.manager.address = ${canal.admin.manager} canal.instance.global.spring.xml = classpath:spring/file-instance.xml 4) 修改配置 slave_canal/conf/instance_1/instance.properties canal.instance.master.address=127.0.0.1:3307 #指向mysql master配置 canal.instance.dbUsername=slaveuser # 拥有主从复制、连接权限的用户 canal.instance.dbPassword=123456 # 对应dbUsername的密码 5) 启动 slave_canal、bin/startup.bat slave_canal/logs/canal/canal.log slave_canal/logs/instance_1/instance_1.log 5.1 canal客户端测试 see https://github.com/alibaba/canal.git\n运行 com.alibaba.otter.canal.example.BaseCanalClientTest.main 在master节点执行 insert,可以看到bingnlog消息\n在master节点执行 update,可以看到bingnlog消息\n7.问题 7.1.Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event\u0026rsquo;s master log FIRST, end_log_pos 429, Error_code: MY-001032 在从库删除数据后，出现主从同步问题 1)stop slave; 2)找出被删除的记录，重新插入从库 E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysqlbinlog --no-defaults --base64-output=decode-rows -v bin.000001 \u0026gt;bin.sql or E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysqlbinlog --no-defaults --base64-output=DECODE-ROWS -v bin.000001 3)start slave; 7.2.client does not support authentication protocol requested by server consider upgrading mysql client 创建用户时指定mysql_native_password ， mysql8之后,加密规则是caching_sha2_password。\nCREATE USER slaveuser@'%' IDENTIFIED WITH mysql_native_password BY '123456';\n7.3.Access denied; you need (at least one of) the SUPER, REPLICATION CLIENT privilege(s) 为用户增加 REPLICATION CLIENT 权限\nGRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO '用户名'@'%';\n8.备查命令 8.1.查看从节点数量 show slave hosts; select * from information_schema.processlist as p where p.command = 'Binlog Dump'; 8.2.查看版本 select version();\nSELECT * FROM information_schema.plugins; SELECT @@innodb_version;\n8.2.mysqlbinlog 查看binlog信息 mysqlbinlog -v --base64-output=DECODE-ROWS ./bin.000001\n查看binglog文件 SHOW BINARY LOGS\n9.数据参考: 1.机器信息DB型(内存(12*32G)384G硬盘2*480G(s4500)SSD+8*960G(s4500)SSD)\nshow variables like '%binlog%'; 1\tbinlog_cache_size\t1048576 2\tbinlog_checksum\tNONE 3\tbinlog_direct_non_transactional_updates\tOFF 4\tbinlog_error_action\tABORT_SERVER 5\tbinlog_format\tROW 6\tbinlog_group_commit_sync_delay\t0 7\tbinlog_group_commit_sync_no_delay_count\t0 8\tbinlog_gtid_simple_recovery\tON 9\tbinlog_max_flush_queue_time\t0 10\tbinlog_order_commits\tON 11\tbinlog_row_image\tFULL 12\tbinlog_rows_query_log_events\tOFF 13\tbinlog_skip_flush_commands\tOFF 14\tbinlog_space_limit\t0 15\tbinlog_stmt_cache_size\t32768 16\tbinlog_transaction_dependency_history_size\t25000 17\tbinlog_transaction_dependency_tracking\tCOMMIT_ORDER 18\tencrypt_binlog\tOFF 19\thave_backup_safe_binlog_info\tYES 20\tinnodb_api_enable_binlog\tOFF 21\tinnodb_locks_unsafe_for_binlog\tOFF 22\tlog_statements_unsafe_for_binlog\tON 23\tmax_binlog_cache_size\t18446744073709547520 24\tmax_binlog_files\t0 25\tmax_binlog_size\t1073741824 26\tmax_binlog_stmt_cache_size\t18446744073709547520 27\tsync_binlog\t1 show variables like '%relay%'; 1\tmax_relay_log_size\t0 2\trelay_log\trelay-bin 3\trelay_log_basename\t/data/mysql_3306/relay-bin 4\trelay_log_index\t/data/mysql_3306/relay-bin.index 5\trelay_log_info_file\trelay-log.info 6\trelay_log_info_repository\tTABLE 7\trelay_log_purge\tON 8\trelay_log_recovery\tON 9\trelay_log_space_limit\t0 10\tsync_relay_log\t10000 11\tsync_relay_log_info\t10000 ","dateformatted":"16, October 2021","dateiso":"2021-10-16T15:42:33Z","ref":"/mysql-master-slave/","summary":"\n 1.参考 【mysql8.0手册】https://dev.mysql.com/doc/refman/8.0/en/\n【mysql doc】https://dev.mysql.com/doc/\n【alibaba canal】https://github.com/alibaba/canal\n2.概要 通过本文可以了解主从同步原理，快速搭建一个主从环境,实现复制场景，并且利用canal实现订阅binglog日志，实现跨实例同步。\n中间件版本:\nmysql-8.0.27\ncanal 1.1.5\n3.主从同步 创建容错系统的最常见方法就是冗余，复制模式分普通复制、组复制，普通复制即传统的 MySQL复制 提供了一种简单的源(mater)到副本复制方法,。\nmaster-slave syn MySQL 复制功能允许服务器 -主服务器 - 将所有更改发送到另一台服务器 -从服务器 -从服务器尝试应用所有更改以与主服务器保持同步。复制工作如下：\n\n","tags":["mysql"],"title":"mysql master-slave"},{"content":"","dateformatted":"16, October 2021","dateiso":"2021-10-16T15:42:33Z","ref":"/sonarqube%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","summary":"\n \n\n","tags":["工具"],"title":"sonarqube基础使用"},{"content":"1.概述 Yarn是您的代码的包管理器，yarn和npm的对比\n 速度\nnpm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。\n 安装版本统一\n 更简洁的输出\n 参考：\nhttps://classic.yarnpkg.com yarn官网\n2.基础配置 使用安装包安装\nhttps://github.com/yarnpkg/yarn/releases 下载路径\n使用npm安装\nnpm install --g yarn \nwindow下 配置文件路径 C:\\Users\\Administrator\\.yarnrc\n2.1.修改缓存路径 #修改yarn 缓存位置 yarn config set cache-folder \u0026ldquo;你的磁盘路径\u0026rdquo; #这里是我的路径 yarn config set cache-folder \u0026ldquo;D:\\Software\\yarn\\cache\u0026rdquo;\n2.2.修改包源 yarn config set registry https://registry.npm.taobao.org/\n2.3.yarn 全局安装位置 yarn config set global-folder \u0026quot;D:\\yarnData\\global\u0026quot;\n2.4.改变yarn bin位置 yarn config set prefix D:\\yarnData\\global\\bin\n3.yarn版本号 yarn的包遵守 semver，即语义化版本。 SemVer 是一套语义化版本控制的约定，定义的格式为 X.Y.Z（主版本号.次版本号.修订号）： X.主版本号：进行不向下兼容的修改时，递增主版本号 Y.次版本号: 做了向下兼容的新增功能或修改 Z.修订号：做了向下兼容的问题修复 yarn 中依赖版本范围的表示方法有以下几种： 1. 通过比较器 表示\t含义描述 \u0026lt;2.0.0\t任何小于 2.0.0 的版本 \u0026lt;=3.1.4\t任何小于或等于 3.1.4 的版本 \u0026gt;0.4.2\t任何大于 0.4.2 的版本 \u0026gt;=2.7.1\t任何大于或等于 2.7.1 的版本 =4.6.6\t任何等于 4.6.6 的版本 \u0026gt;=2.0.0 \u0026lt;3.1.4\t交集，大于或等于 2.0.0 并小于 3.1.4 \u0026lt;2.0.0 || \u0026gt;3.1.4\t并集 小于 2.0.0 或者大于 3.1.4 如果没有指定运算符，默认为 = 2. 通过连字符 表示\t含义描述 2.0.0 - 3.1.4\t\u0026gt;=2.0.0 \u0026lt;=3.1.4 0.4 - 2\t\u0026gt;=0.4.0 \u0026lt;=2.0.0 版本号中缺少的那些部分会用数字 0 填充。 3. X范围 字符 X、x 或者 * 都可以作为通配符，用于填充部分或全部版本号。 被省略的那部分版本号默认为 x 范围。 表示\t含义描述 *\t\u0026gt;=0.0.0 (任意版本) 2.x\t\u0026gt;=2.0.0 \u0026lt;3.0.0（匹配主要版本） 3.1.x\t\u0026gt; = 3.1.0 \u0026lt; 3.2.0（匹配主要和次要版本） ``（空字符串）\t* 或 \u0026gt; = 0.0.0 2\t2.x.x 或 \u0026gt; = 2.0.0 \u0026lt; 3.0.0 3.1\t3.1.x 或 \u0026gt; = 3.1.0 \u0026lt; 3.2.0 4. ～ 字符范围 同时使用字符 ~ 和次版本号，表明允许 修订号 变更。同时使用字符 ~ 和主版本号，表明允许 次版本 号变更。 表示\t含义描述 ~3.1.4\t\u0026gt;=3.1.4 \u0026lt;3.2.0 ~3.1\t3.1.x 或 \u0026gt; = 3.1.0 \u0026lt; 3.2.0 ~3\t3.x 或 \u0026gt; = 3.0.0 \u0026lt; 4.0.0 5. ^ 字符范围 字符 ^ 表明不会修改版本号中的第一个非零数字，3.1.4 里的 3 或者 0.4.2 里的 4。版本号中缺少的部分将被 0 填充，且在匹配时这些位置允许改变。 表示\t含义描述 ^3.1.4\t\u0026gt;=3.1.4 \u0026lt;4.0.0 ^0.4.2\t\u0026gt;=0.4.2 \u0026lt;0.5.0 ^0.0.2\t\u0026gt;=0.0.2 \u0026lt;0.0.3 使用 yarn add [package-name] 命令安装依赖，默认使用的是 ^ 范围。 需要注意的是，如果一个比较器包含有预发布标签的版本，它将只匹配有相同 major.minor.patch 的版本。 例如 \u0026gt;=3.1.4-beta.2，可以匹配 3.1.4-beta.3，但不会匹配 3.1.5-beta.3 版本。 3.yarn依赖类型 dependences 代码运行时所需要的依赖，比如vue，vue-router。 devDependences 开发依赖，就是那些只在开发过程中需要，而运行时不需要的依赖，比如babel，webpack。 peerDependences 同伴依赖，它用来告知宿主环境需要什么依赖以及依赖的版本范围。如果宿主环境没有对应版本的依赖，在安装依赖时会报出警告。比如包 eslint-plugin-import 中有依赖： \u0026quot;peerDependencies\u0026quot;: { \u0026quot;eslint\u0026quot;: \u0026quot;2.x - 5.x\u0026quot; }, optionalDependencies 可选依赖，这种依赖即便安装失败，Yarn也会认为整个依赖安装过程是成功的。可选依赖适用于那些即便没有成功安装可选依赖，也有后备方案的情况。 bundledDependencies 打包依赖，在发布包时，这个数组里的包都会被打包打包到最终的发布包里，需要注意 bundledDependencies 中的包必须是在devDependencies或dependencies声明过的。 4.yarn 包缓存 yarn 会将安装过的包缓存下来，这样再次安装相同包的时候，就不需要再去下载，而是直接从缓存文件中直接copy进来。\n可以通过命令 yarn cache dir 查看yarn的全局缓存目录。我的缓存目录在 /Library/Caches/Yarn/v1 下。\n可以看出，yarn 会将不通版本解压后的包存放在不同目录下，目录以\nnpm-[package name]-[version]-[shasum]`\n来命名。shasum 即上文中 registry 获取的 dist.shasum。\n我们可以通过命令查看已经缓存过的包。\nyarn cache list 列出已缓存的每个包\nyarn cache list \u0026ndash;pattern 列出匹配指定模式的已缓存的包\n例如执行 yarn cache list \u0026ndash;pattern vue\n5.yarn install过程 首次执行 yarn install 安装，会按照 package.json 中的语义化版本，去向 registry 进行查询，并获取到符合版本规则的最新的依赖包进行下载，并构建构建依赖关系树。 比如在 package.json 中指定 vue 的版本为 ^2.0.0，就会获取符合 2.x.x 的最高版本的包。然后自动生成 yarn.lock 文件，并生成缓存。\n之后再执行 yarn install，会对比 package.json 中依赖版本范围和 yarn.lock 中版本号是否匹配。\n 版本号匹配，会根据 yarn.lock 中的 resolved 字段去查看缓存， 如果有缓存，直接copy，没有缓存则按照 resolved 字段的url去下载包。 版本号不匹配，根据 package.json 中的版本范围去 registry 查询，下载符合版本规则最新的包，并更新至 yarn.lock 中。 6.yarn.lock yarn.lock 中会准确的存储每个依赖的具体版本信息，以保证在不同机器安装可以得到相同的结果。 下面以@babel/code-frame为例，看看yarn.lock 中会记录哪些信息。 1. 第一行 \u0026quot;@babel/code-frame@7.0.0-beta.54\u0026quot; 包的name和语义化版本号，这些都来自package.json中的定义。 2. version 字段，记录的是一个确切的版本。 3. resolved 字段记录的是包的URL地址。其中hash值，即上文的 dist.shasum。 4. dependencies 字段记录的是当前包的依赖，即当前包在 package.json 的 dependencies 字段中的所有依赖。 Yarn 在安装期间，只会使用当前项目的 yarn.lock 文件（即 顶级 yarn.lock 文件），会忽略任何依赖里面的 yarn.lock 文件。在顶级 yarn.lock 中包含需要锁定的整个依赖树里全部包版本的所有信息。 yarn.lock文件是在安装期间，由 Yarn 自动生成的，并且由yarn来管理，不应该手动去更改，更不应该删除yarn.lock文件，且要提交到版本控制系统中，以免因为不同机器安装的包版本不一致引发问题。 7.模块扁平化 上面提到，在安装依赖时，会解析依赖构建出依赖关系树。 比如我项目的首层依赖(即当前项目的dependence和devDependences中的依赖，不包括依赖的依赖)中有A，B，C三个包，A 和 B包同时依赖了相同版本范围的D包。那么这部分的依赖关系树是这样的： ├── A │ └── D ├── B │ └── D ├── C 如果按照这样的依赖关系树直接安装的话，D模块会在A包和B包的 node_modules中都安装，这样会导致模块冗余。 为了保证依赖关系树中没有大量重复模块，yarn在安装时会做dedupe（去重）操作，它会遍历所有节点，逐个将模块放在根节点下面，也就是当前项目的 node-modules 中。当发现有相同的模块时，会判断当前模块指定的 semver 版本范围是否交集，如果有，则只保留兼容版本，如果没有则在当前的包的 node-modules 下安装。 所以上面的说的情况，最终安装完成是下面这样的，A，B，C，D包都会安装在第一层 node-modules 下。 ├── A ├── B ├── C ├── D 如果A包和B包依赖的是不兼容的版本，假设A包依赖的是D@1版本的包，B包依赖的是D@2版本。则最终安装的结果如下： ├── A ├── B │ └── D@2 ├── C ├── D@1 当代码中 require 或 import 某个模块时，会从当前 package 的 node-modules 里中开始找，找不到就到当前package的上一层 node-modules 里找，这样一直找到全局的node_modules。 所以上面的安装的树结构，可以保证每个 package 都能获取到所需要版本的包。 8.基本命令 1.查看配置 yarn --version yarn global bin 查看bin路径 yarn global dir 查看安装路径 2.显示当前依赖 yarn list 列出所有依赖 yarn list --depth=0 列出所有依赖,并指定深度 yarn list --pattern gulp yarn list --pattern \u0026quot;gulp|grunt\u0026quot; yarn list --pattern \u0026quot;gulp|grunt\u0026quot; --depth=1 3.查看配置 yarn config get init-license 获取配置 yarn config delete test-key 删除配置 yarn config list 显示当前配置 yarn config set init-license BSD-2-Clause 设置配置 查看当前使用的镜像源 yarn config get registry 修改镜像源（以修改成淘宝源为例） yarn config set registry https://registry.npm.taobao.org/ 4.基础使用 新项目初始化 yarn init 添加依赖关系 yarn add [package] yarn add [package]@[version] yarn add [package]@[tag] 将依赖关系添加到不同类别的依赖项 添加到devDependencies，peerDependencies和optionalDependencies分别为： yarn add [package] --dev yarn add [package] --peer yarn add [package] --optional 升级依赖项 yarn upgrade [package] yarn upgrade [package]@[version] yarn upgrade [package]@[tag] 删除依赖项 yarn remove [package] 安装项目的所有依赖项 yarn 或 yarn install 执行package.json文件中定义scripts yarn run build/test -o --watch 5.项目文件 package.json：这包含您的包的所有当前依赖项。 yarn.lock：这存储了包的每个依赖项的确切版本。 6.其他命令 yarn versions 查看所有包的版本信息 7. yarn install 安装依赖 yarn install / yarn 在本地 node_modules 目录安装 package.json 里列出的所有依赖 yarn install --force 重新拉取所有包，即使之前已经安装的（所以以后别在删除node-modules了...） yarn install --modules-folder \u0026lt;path\u0026gt; 为 node_modules 目录指定另一位置，代替默认的 ./node_modules yarn install --no-lockfile 不读取或生成 yarn.lock 文件 yarn install --production[=true|false] / --production / --prod 只安装 dependence下的包，不安装 devDependencies 的包 8. yarn add yarn add package-name 会安装 latest 最新版本。 yarn add \u0026lt;package...\u0026gt; 安装包到dependencies中 yarn add \u0026lt;package...\u0026gt; [--dev/-D] 用 --dev 或 -D 安装包到 devDependencies yarn add \u0026lt;package...\u0026gt; [--peer/-P] 用 --peer 或者 -P 安装包到 peerDependencies yarn add \u0026lt;package...\u0026gt; [--optional/-O] 用 --optional 或者 -O 安装包到 optionalDependencies yarn add \u0026lt;package...\u0026gt; [--exact/-E] 用 --exact 或者 -E 会安装包的精确版本。默认是安装包的主要版本里的最新版本。 比如说， yarn add foo@1.2.3 会接受 1.9.1 版，但是 yarn add foo@1.2.3 --exact 只会接受 1.2.3 版。 yarn add \u0026lt;package...\u0026gt; [--tilde/-T] 用 --tilde 或者 -T 来安装包的次要版本里的最新版。 默认是安装包的主要版本里的最新版本。 比如说，yarn add foo@1.2.3 --tilde 会接受 1.2.9，但不接受 1.3.0。 9. 其他常用命令 yarn list 查询当前工作文件夹所有的依赖 yarn info \u0026lt;package\u0026gt; [\u0026lt;field\u0026gt;] 查看包信息，可以查看特定 yarn remove \u0026lt;package...\u0026gt; 从依赖里移除名包，同时更新你 package.json 和 yarn.lock 文件。 yarn \u0026lt;script\u0026gt; [\u0026lt;args\u0026gt;] 执行用户自定义的脚本 10. 详细日志模式 运行yarn命令时，增加参数 --verbose，这对排查错误时很有帮助 yarn \u0026lt;command\u0026gt; --verbose 9.问题 yarn The platform \u0026ldquo;win32\u0026rdquo; is incompatible with this module yarn config set ignore-engines true\n","dateformatted":"27, May 2021","dateiso":"2021-05-27T09:46:19+08:00","ref":"/yarn%E7%9B%B8%E5%85%B3/","summary":"\n 1.概述 Yarn是您的代码的包管理器，yarn和npm的对比\n 速度\nnpm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。\n 安装版本统一\n 更简洁的输出\n 参考：\n\n","tags":["yarn"],"title":"Yarn相关"},{"content":"相关链接 https://github.com/golang 源码 https://golang.org/ref/mod 官方文档 https://golang.org/doc/code.html#Workspaces http://www.flysnow.org/categories/Golang/ go专栏 https://golanglibs.com/top 流行的GO应用和GO库 https://gitee.com/pengzhile/ide-eval-resetterv GoLand试用更新插件 一：读书笔记 Limbo语言被认为是Go语言的前身,Limbo语言中继承了众多优秀的特性。包括肯·汤普逊在内的Plan 9项目原班人马加入了Google。在Google，他们创造了Go语言，Google是Go语言的主推。\n学习书籍\n《GO并发编程实战 第2版》《Go****语言核心编程》《Go语言高级编程》《Go Web编程》\n初识GO语言 1.Go语言最主要的特性  自动垃圾回收  更丰富的内置类型  函数多返回值  错误处理  匿名函数和闭包  类型和接口  并发编程  反射  语言交互性 Go语言的main()函数不能带参数，也不能定义返回值。命令行传入的参数在os.Args变量中保存。如果需要支持命令行开关，可使用flag包。 Go程序的代码注释与C++保持一致： /* 块注释 */ // 行注释 不得包含在源代码文件中没有用到的包，否则Go编译器会报编译错误。 强制左花括号{的放置位置,如果把左花括号{另起一行放置，这样做的结果是Go编译器报告编译错。 Go程序并不要求开发者在每个语句后面加上分号表示语句结束。 一个常规的函数定义包含以下部分： func 函数名(参数列表)(返回值列表) { // 函数体 } 2.编译程序 Go命令行工具只是一个源代码管理工具，或者说是一个前端。真正的Go编译器和链接器被Go命令行工具隐藏在后面，我们可以直接使用它们： $ 6g helloworld.go $ 6l helloworld.6 $ ./6.out Hello, world. 你好，世界！ 6g和6l是64位版本的Go编译器和链接器，对应的32位版本工具为8g和8l。Go还有另外一个 GCC版本的编译器，名为 gccgo。 构建 GOPATH和PATH环境变量一样，也可以接受多个路径，并且路径和路径之间用冒号分割 go build calc gdb calc go test simplemath 3.开发工具  文本编辑工具gedit（Linux）/Notepad++（Windows）/Fraise（Mac OS X）；  安装了GoClipse插件的Eclipse，集成性做得很好；  Vim/Emacs，万能开发工具；  LiteIDE，一款专为Go语言开发的集成开发环境  goland 非免费  VScode\n顺序编程 1. 变量申明 var v1 int var v2 string var v3 [10]int // 数组 var v4 []int // 数组切片 var v5 struct { f int } var v6 *int // 指针 var v7 map[string]int // map，key为string类型，value为int类型 var v8 func(a int) int var ( v1 int v2 string ) 变量声明语句不需要使用分号作为结束符。 2. 变量初始化 var v1 int = 10 // 正确的使用方式1 var v2 = 10 // 正确的使用方式2，编译器可以自动推导出v2的类型 v3 := 10 // 正确的使用方式3，编译器可以自动推导出v3的类型 出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误 func GetName() (firstName, lastName, nickName string) { return \u0026quot;May\u0026quot;, \u0026quot;Chan\u0026quot;, \u0026quot;Chibi Maruko\u0026quot; } 若只想获得nickName，则函数调用语句可以用如下方式编写： _, _, nickName := GetName() 这种用法可以让代码非常清晰 二.基本命令 Go Module gomod 包源码和链接库保存在 $GOPATH/pkg/mod 目录下。\n go list -u -m all 查看所有依赖 go mod tidy 移除不需要的依赖 go mod edit -fmt 格式化go.mod文件 go mod edit --require=rsc.io/quote@v3.1.0 更新 rsc.io/quote 到 v3.1.0 版 GO安装 1. MSI installer(https://golang.org/dl/) Open the MSI file and follow the prompts to install the Go tools. By default, the installer puts the Go distribution in c:\\Go. The installer should put the c:\\Go\\bin directory in your PATH environment variable. You may need to restart any open command prompts for the change to take effect. Setting environment variables under Windows Under Windows, you may set environment variables through the \u0026quot;Environment Variables\u0026quot; button on the \u0026quot;Advanced\u0026quot; tab of the \u0026quot;System\u0026quot; control panel. Some versions of Windows provide this control panel through the \u0026quot;Advanced System Settings\u0026quot; option inside the \u0026quot;System\u0026quot; control panel. 2. linux下安装 tar -C /usr/local -xzf go.tar.gz Add /usr/local/go/bin to the PATH environment variable. You can do this by adding this line to your /etc/profile(for a system-wide installation) or $HOME/.profile: export PATH=$PATH:/usr/local/go/bin 3. 自定义安装 The Go binary distributions assume they will be installed in /usr/local/go (or c:\\Go under Windows), but it is possible to install the Go tools to a different location. In this case you must set the GOROOT environment variable to point to the directory in which it was installed. For example, if you installed Go to your home directory you should add commands like the following to $HOME/.profile: export GOROOT=$HOME/go1.X export PATH=$PATH:$GOROOT/bin 4. 测试安装情况 Check that Go is installed correctly by setting up a workspace and building a simple program, as follows. Create your workspace directory, %USERPROFILE%\\go. (If you'd like to use a different directory, you will need to set the GOPATH environment variable; see How to Write Go Code for details.) Next, make the directory src/hello inside your workspace, and in that directory create a file named hello.go that looks like: package main import \u0026quot;fmt\u0026quot; func main() { fmt.Printf(\u0026quot;hello, world\\n\u0026quot;) } Then build it with the go tool: C:\\\u0026gt; cd %USERPROFILE%\\go\\src\\hello C:\\Users\\Gopher\\go\\src\\hello\u0026gt; go build The command above will build an executable named hello.exe in the directory alongside your source code. Execute it to see the greeting: C:\\Users\\Gopher\\go\\src\\hello\u0026gt; hello hello, world If you see the \u0026quot;hello, world\u0026quot; message then your Go installation is working. You can run go install to install the binary into your workspace's bin directory or go clean to remove it. Before rushing off to write Go code please read the How to Write Go Code document, which describes some essential concepts about using the Go tools. 5. 删除go 直接删除go的安装目录. /usr/local/go under Linux, Mac OS X, and FreeBSD c:\\Go under Windows. 删除环境变量配置 Under Linux and FreeBSD you should edit /etc/profile or $HOME/.profile. Mac OS X you should remove the /etc/paths.d/go file. Windows users should read the section about setting environment variables under Windows. GOPATH 与GOROOT GOROOT 指定Go的二进制编译包安装路径，假设你把Go安装在 /usr/local/go (或者Window是 c:\\Go)目录下。当然你也可以安装在其他目录下，不过这时候你就需要设置GOROOT环境变量了。 http://golang.org/doc/install#install 例如，你如果安装Go在你的/usr/local/go目录下，你应该$HOME/.profile文件增加下面设置。 export GOROOT=/usr/local/go export GOPATH=$PATH:$GOROOT/bin 执行：source .bash_profile (即时生效) GOPATH GOPATH的作用是告诉Go命令和其他相关工具，在哪里去找到安装在你系统上的Go包。 GOPATH是一个路径的列表，一个典型的GOPATH设置如下，类似PATH的设置，Win下用分号分割： GOPATH=/home/user/ext:/home/user/mygo 每一个列表中的路径是一个工作区的位置。每个工作区都有源文件、相关包的对象、执行文件。http://golang.org/doc/code.html 下面是一个建立工作区的步骤： 创建 $HOME/mygo 目录和作为源代码的 src 目录。 $ mkdir -p $HOME/mygo/src # create a place to put source code 下一步就是设置 GOPATH，另外你应该把 这个目录下的bin目录放在 PATH 环境变量，这样你就可以直接在命令行执行而不用给出完整目录。 export GOPATH=$HOME/mygo export PATH=$PATH:$HOME/mygo/bin GOPATH 必须设置编译和安装包，即使用标准的Go目录树，类似如下： GOPATH=/home/user/gocode /home/user/gocode/ src/ foo/ bar/ (go code in package bar) x.go quux/ (go code in package main) y.go bin/ quux (installed command) pkg/ linux_amd64/ foo/ bar.a (installed package object) 三.问题 1.go: github.com/BurntSushi/toml@v0.3.1: Get \u0026ldquo;https://proxy.golang.org/github.com/%21burnt%21sushi/toml/@v/v0.3.1.mod\u0026quot;: dial tcp 172.217.160.81:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. 设置国内代理地址go env -w GOPROXY=https://goproxy.cn\n","dateformatted":"25, May 2021","dateiso":"2021-05-25T09:34:28+08:00","ref":"/go%E5%AD%A6%E4%B9%A0/","summary":"\n 相关链接 https://github.com/golang 源码 https://golang.org/ref/mod 官方文档 https://golang.org/doc/code.html#Workspaces http://www.flysnow.org/categories/Golang/ go专栏 https://golanglibs.com/top 流行的GO应用和GO库 https://gitee.com/pengzhile/ide-eval-resetterv GoLand试用更新插件 一：读书笔记 Limbo语言被认为是Go语言的前身,Limbo语言中继承了众多优秀的特性。包括肯·汤普逊在内的Plan 9项目原班人马加入了Google。在Google，他们创造了Go语言，Google是Go语言的主推。\n学习书籍\n《GO并发编程实战 第2版》《Go****语言核心编程》《Go语言高级编程》《Go Web编程》\n初识GO语言 1.\n\n","tags":["GO"],"title":"GO学习"},{"content":"概要： 了解hugo基本使用，通过hugo搭建个人blog\n参考 【hugo 】https://gohugo.io/\n【函数】https://gohugo.io/functions/\n【变量】https://gohugo.io/variables/\n【github集成】https://github.com/peaceiris/actions-gh-pages\n【参考例子】https://github.com/henriksommerfeld/blog-hugo\n【hugo theme】https://themes.gohugo.io/hugo-clarity/\n1.hugo结构说明 # 站点结构 ├── archetypes # 原型 ├── config.toml # 站点配置 ├── content # 站点内容目录 ├── data # 数据模板 ├── layouts # 站点布局模板 ├── static # 静态内容 └── themes # 内容目录 content └── post ├── first-post │ ├── images │ │ ├── a.jpg │ │ ├── b.jpg │ │ └── c.jpg │ ├── index.md (root of page bundle) │ ├── latest.html │ ├── manual.json │ ├── notice.md │ ├── office.mp3 │ ├── pocket.mp4 │ ├── rating.pdf │ └── safety.txt └── second-post └── index.md (root of page bundle # 文章描述 categories = [\u0026#34;目录1\u0026#34;, \u0026#34;目录2\u0026#34;] date = \u0026#34;日期+时间\u0026#34; description = \u0026#34;描述\u0026#34; slug = \u0026#34;spf13-vim-3-0-release-and-new-website\u0026#34; tags = [\u0026#34;标签1\u0026#34;, \u0026#34;标签2\u0026#34;] title = \u0026#34;标题\u0026#34; 2.基本使用 # window版本下载`https://github.com/gohugoio/hugo/releases/download/v0.83.1/hugo_extended_0.83.1_Windows-64bit.zip` # 配置环境变量 path /hugo_path/ # 创建站点 hugo new site quickstart cd quickstart # 添加主题/展示模板 git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo theme = \\\u0026#34;ananke\\\u0026#34; \u0026gt;\u0026gt; config.toml # 新建文章 hugo new posts/my-first-post.md # 发布预览 hugo server -D #默认输出静态文件到./public目录下，或者使用参数指定public目录路径(-d/--destination flag to change it, or set publishdir in the config file). 访问 http://localhost:1313 # 发布静态文件到github 上传public下的文件到 `https://github.com/username/username.github.io` 访问 `https://username.github.io` 集成github pages [源] hugo repository:qiaomingzi/limz-blog-hugo\n[目标] gitpages repository: qiaomingzi/qiaomingzi.github.io\n[1]生成密钥key\nssh-keygen -t rsa -b 4096 -C \u0026quot;github邮箱\u0026quot; -f gh-pages -N \u0026quot;\u0026quot; [2]配置limz-blog-hugo/setting/Deploy keys新增公钥 key:刚才生成的公钥(gh-pages.pub)\n[3]配置qiaomingzi.github.io/setting/Secrets新增密钥 name:ACTIONS_DEPLOY_KEY value:刚才生成的密钥(gh-pages)\n[4]创建文件limz-blog-hugo/.github/workflows/gh-pages.yml\nname: github pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 - name: Setup Node uses: actions/setup-node@v2.1.2 with: node-version: '12.x' - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.83.1' - name: Cache dependencies uses: actions/cache@v2 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- - run: npm run install:prod - run: npm run build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # github_token: ${{ secrets.GITHUB_TOKEN }} external_repository: qiaomingzi/qiaomingzi.github.io publish_branch: master # default: gh-pages publish_dir: ./public [5]limz-blog-hugo/Actions查看或触发发布\ngit push 触发发布，可以在github上查看发布结果\n3.hugo命令 hugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at https://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: check Contains some verification checks config Print the site configuration convert Convert your content to different formats env Print Hugo version and environment info gen A collection of several useful generators. help Help about any command import Import your site from others. list Listing out various types of content new Create new content for your site server A high performance webserver version Print the version number of Hugo Flags: -b, --baseURL string hostname (and path) to the root, e.g. https://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/ --cleanDestinationDir remove files from destination not found in static directories --config string config file (default is path/config.yaml|json|toml) --configDir string config dir (default \u0026quot;config\u0026quot;) -c, --contentDir string filesystem path to content directory --debug debug output -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date and author info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo --i18n-warnings print missing translations --ignoreCache ignores the cache directory -l, --layoutDir string filesystem path to layout directory --log enable Logging --logFile string log File path (if set, logging enabled automatically) --minify minify any supported output format (HTML, XML etc.) --noChmod don't sync permission mode of files --noTimes don't sync modification time of files --path-warnings print warnings on duplicate target paths etc. --quiet build in quiet mode --renderToMemory render to memory (only useful for benchmark testing) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMetrics -t, --theme strings themes to use (located in /themes/THEMENAME/) --themesDir string filesystem path to themes directory --trace file write trace to file (not useful in general) -v, --verbose verbose output --verboseLog verbose logging -w, --watch watch filesystem for changes and recreate as needed Use \u0026quot;hugo [command] --help\u0026quot; for more information about a command. 4.问题 1.ERROR 2021/05/08 14:30:50 TOCSS: failed to transform \u0026ldquo;styles/print-bundle.scss\u0026rdquo; (text/x-scss). Check your Hugo installation; you need the extended version to build SCSS/SASS. 确认下载的hugo版本呢是hugo_extend版本 而不是标准版本\n2.Hugo - Failed to find a valid digest in the \u0026lsquo;integrity\u0026rsquo; attribute for resource I replaced:\nintegrity=\u0026ldquo;J6YEe5hjKuk/TENUR7jEMr6VNR4lwN8iVpSGj1g8MU4=\u0026rdquo;\nwith:\nintegrity=\u0026quot;\u0026quot;\nin the css tag of every single index.html file.\nThis worked, although I found a solution to do this automatically and skip the error in the first place.\nSolution(!) - Update: It looks like the head.html file under the assets folder has the following structure:\n{{- $stylesheet := (resources.Match \u0026quot;css/*.css\u0026quot;) | resources.Concat \u0026quot;assets/css/stylesheet.css\u0026quot; | minify | fingerprint -}} \u0026lt;link href=\u0026quot;{{ $stylesheet.Permalink }}\u0026quot; integrity=\u0026quot;{{ $stylesheet.Data.Integrity }}\u0026quot; rel=\u0026quot;preload stylesheet\u0026quot; as=\u0026quot;style\u0026quot;\u0026gt; blog-hugo blog-hugo\\layouts\\partials\\head.html\nhugo-clarity hugo-clarity\\layouts\\partials\\math.html themes\\hugo-clarity\\layouts_default\\baseof.html\n","dateformatted":"7, May 2021","dateiso":"2021-05-07T17:03:36+08:00","ref":"/hugo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"\n 概要： 了解hugo基本使用，通过hugo搭建个人blog\n参考 【hugo 】https://gohugo.io/\n【函数】https://gohugo.io/functions/\n【变量】https://gohugo.io/variables/\n【github集成】https://github.com/peaceiris/actions-gh-pages\n【参考例子】https://github.com/henriksommerfeld/blog-hugo\n【hugo theme】https://themes.gohugo.io/hugo-clarity/\n1.hugo结构说明 # 站点结构 ├── archetypes # 原型 ├── config.toml # 站点配置 ├── content # 站点内容目录 ├── data # 数据模板 ├── layouts # 站点布局模板 ├── static # 静态内容 └── themes # 内容目录 content └── post ├── first-post │ ├── images │ │ ├── a.\n\n","tags":null,"title":"Hugo基本使用"},{"content":"目录 跳过目录\n 本文目标 如何使用本教程 正则表达式到底是什么东西？ 入门 测试正则表达式 元字符 字符转义 重复 字符类 分枝条件 反义 分组 后向引用 零宽断言 负向零宽断言 注释 贪婪与懒惰 处理选项 平衡组/递归匹配 还有些什么东西没提到 联系作者 网上的资源及本文参考文献 更新纪录 本文目标 30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。\n如何使用本教程 最重要的是——请给我30分钟，如果你没有使用正则表达式的经验，请不要试图在30秒内入门——除非你是超人 :)\n别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有你想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。\n除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？\n清除格式 文本格式约定：专业术语 元字符/语法格式 正则表达式 正则表达式中的一部分(用于分析) 对其进行匹配的源字符串 对正则表达式或其中一部分的说明\n隐藏边注 本文右边有一些注释，主要是用来提供一些相关信息，或者给没有程序员背景的读者解释一些基本概念，通常可以忽略。\n正则表达式到底是什么东西？ 字符是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。字符串是0个或更多个字符的序列。文本也就是文字，字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。\n在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n很可能你使用过Windows/Dos下用于文件查找的通配符(wildcard)，也就是和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像010-12345678或0376-7654321)。\n入门 学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。\n假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。\n这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。\n不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\\bhi\\b。\n\\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。\n如果需要更精确的说法，\\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\\w。\n假如你要找的是hi后面不远处跟着一个Lucy，你应该用\\bhi\\b.*\\bLucy\\b。\n这里，.是另一个元字符，匹配除了换行符以外的任意字符。同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.连在一起就意味着任意数量的不包含换行的字符。现在\\bhi\\b.\\bLucy\\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。\n换行符就是'\\n',ASCII编码为10(十六进制0x0A)的字符。\n如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：\n0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。\n这里的\\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。\n为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\\d{2}-\\d{8}。 这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)。\n测试正则表达式 其它可用的测试工具:\n RegexBuddy Javascript正则表达式在线测试工具 如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。\n不同的环境下正则表达式的一些细节是不相同的，本教程介绍的是微软 .Net Framework 4.0 下正则表达式的行为，所以，我向你推荐我编写的.Net下的工具 正则表达式测试器。请参考该页面的说明来安装和运行该软件。\n下面是Regex Tester运行时的截图：\n元字符 现在你已经知道几个很有用的元字符了，如\\b,.,*，还有\\d.正则表达式里还有更多的元字符，比如\\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\\w匹配字母或数字或下划线或汉字等。\n对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。\n下面来看看更多的例子：\n\\ba\\w*\\b匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w*)，最后是单词结束处(\\b)。\n好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)\n\\d+匹配1个或更多连续的数字。这里的+是和类似的元字符，不同的是匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。\n\\b\\w{6}\\b 匹配刚好6个字符的单词。\n 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。\n元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$。\n这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。\n因为使用了^和$，所以输入的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。\n和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。\n字符转义 如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用.和*。当然，要查找\\本身，你也得用\\.\n例如：unibetter.com匹配unibetter.com，C:\\Windows匹配C:\\Windows。\n重复 你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：\n 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 下面是一些使用重复的例子：\nWindows\\d+匹配Windows后面跟1个或更多数字\n^\\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)\n字符类 要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？\n很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。\n我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。\n下面是一个更复杂的表达式：(?0\\d{2}[) -]?\\d{8}。\n“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。\n这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。\n分枝条件 不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：\n0\\d{2}-\\d{8}|0\\d{3}-\\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。\n(0\\d{2})[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\n\\d{5}-\\d{4}|\\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。\n分组 我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。\n(\\d{1,3}.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。\nIP地址中每个数字都不能大于255，大家千万不要被《24》第三季的编剧给忽悠了……\n不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。\n理解这个表达式的关键是理解2[0-4]\\d|25[0-5]|[01]?\\d\\d?，这里我就不细说了，你自己应该能分析得出来它的意义。\n反义 有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：\n 代码/语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 例子：\\S+匹配不包含空白符的字符串。\n\u0026lt;a[^\u0026gt;]+\u0026gt;匹配用尖括号括起来的以a开头的字符串。\n后向引用 使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。\n呃……其实,组号分配还不像我刚说得那么简单：\n 分组0对应整个正则表达式 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权． 后向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。难以理解？请看示例：\n\\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。\n你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\\w+)(或者把尖括号换成\u0026rsquo;也行：(?\u0026lsquo;Word\u0026rsquo;\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k,所以上一个例子也可以写成这样：\\b(?\\w+)\\b\\s+\\k\\b。\n使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：\n 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?\u0026lsquo;name\u0026rsquo;exp) (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 (?\u0026lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?\u0026lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？\n零宽断言 地球人，是不是觉得这些术语名称太复杂，太难记了？我也有同感。知道有这么一种东西就行了，它叫什么，随它去吧！人若无名，便可专心练剑；物若无名，便可随意取舍……\n接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：\n断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。\n(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I\u0026rsquo;m singing while you\u0026rsquo;re dancing.时，它会匹配sing和danc。\n(?\u0026lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?\u0026lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。\n假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?\u0026lt;=\\d)\\d{3})+\\b，用它对1234567890进行查找时结果是234567890。\n下面这个例子同时使用了这两种断言：(?\u0026lt;=\\s)\\d+(?=\\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。\n负向零宽断言 前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词\u0026ndash;它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：\n\\b\\wq[^u]\\w\\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w*\\b将会匹配下一个单词，于是\\b\\w*q[^u]\\w*\\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不**消费**任何字符。现在，我们可以这样来解决这个问题：\\b\\w*q(?!u)\\w*\\b。\n零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。\n同理，我们可以用(?\u0026lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?\u0026lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字。\n请详细分析表达式(?\u0026lt;=\u0026lt;(\\w+)\u0026gt;).*(?=\u0026lt;/\\1\u0026gt;)，这个表达式最能表现零宽断言的真正用途。\n一个更复杂的例子：(?\u0026lt;=\u0026lt;(\\w+)\u0026gt;).(?=\u0026lt;/\\1\u0026gt;)匹配不包含属性的简单HTML标签内里的内容。(?\u0026lt;=\u0026lt;(\\w+)\u0026gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是)，然后是.(任意的字符串),最后是一个后缀(?=\u0026lt;/\\1\u0026gt;)。注意后缀里的/，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的(\\w+)匹配的内容，这样如果前缀实际上是的话，后缀就是了。整个表达式匹配的是和之间的内容(再次提醒，不包括前缀和后缀本身)。\n注释 小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|250-5|[01]?\\d\\d?(?#0-199)。\n要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：\n (?\u0026lt;= # 断言要匹配的文本的前缀 \u0026lt;(\\w+)\u0026gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签) ) # 前缀结束 .* # 匹配任意文本 (?= # 断言要匹配的文本的后缀 \u0026lt;\\/\\1\u0026gt; # 查找尖括号括起来的内容：前面是一个\u0026quot;/\u0026quot;，后面是先前捕获的标签 ) # 后缀结束 贪婪与懒惰 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。\n有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：\na.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。\n为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。\n 代码/语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 处理选项 在C#中，你可以使用Regex(String, RegexOptions)构造函数来设置正则表达式的处理选项。如：Regex regex = new Regex(@\u0026quot;\\ba\\w{6}\\b\u0026quot;, RegexOptions.IgnoreCase);\n上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：\n 名称 说明 IgnoreCase(忽略大小写) 匹配时不区分大小写。 Multiline(多行模式) 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\\n之前的位置以及字符串结束前的位置.) Singleline(单行模式) 更改.的含义，使它与每一个字符匹配（包括换行符\\n）。 IgnorePatternWhitespace(忽略空白) 忽略表达式中的非转义空白并启用由#标记的注释。 ExplicitCapture(显式捕获) 仅捕获已被显式命名的组。 一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。\n平衡组/递归匹配 这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。\n有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用(.+)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？\n为了避免(和(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx \u0026lt;aa aa\u0026gt; yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？\n这里需要用到以下的语法构造：\n (?\u0026lsquo;group\u0026rsquo;) 把捕获的内容命名为group,并压入堆栈(Stack) (?'-group\u0026rsquo;) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败 (?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分 (?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败 如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个\u0026quot;group\u0026quot;，第二个就是从黑板上擦掉一个\u0026quot;group\u0026quot;，第三个就是看黑板上写的还有没有\u0026quot;group\u0026quot;，如果有就继续匹配yes部分，否则就匹配no部分。\n我们需要做的是每碰到了左括号，就在压入一个\u0026quot;Open\u0026quot;,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。\n\u0026lt; #最外层的左括号 [^\u0026lt;\u0026gt;]* #最外层的左括号后面的不是括号的内容 ( ( (?'Open'\u0026lt;) #碰到了左括号，在黑板上写一个\u0026quot;Open\u0026quot; [^\u0026lt;\u0026gt;]* #匹配左括号后面的不是括号的内容 )+ ( (?'-Open'\u0026gt;) #碰到了右括号，擦掉一个\u0026quot;Open\u0026quot; [^\u0026lt;\u0026gt;]* #匹配右括号后面不是括号的内容 )+ )* (?(Open)(?!)) #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的\u0026quot;Open\u0026quot;；如果还有，则匹配失败 \u0026gt; #最外层的右括号 平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的标签：\u0026lt;div[^\u0026gt;]\u0026gt;[^\u0026lt;\u0026gt;](((?\u0026lsquo;Open\u0026rsquo;\u0026lt;div[^\u0026gt;]\u0026gt;)[^\u0026lt;\u0026gt;])+((?'-Open')[^\u0026lt;\u0026gt;])+)(?(Open)(?!)).\n还有些什么东西没提到 上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们\u0026ndash;当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.net下正则表达式详细的文档。\n这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看关于正则表达式语言元素的MSDN在线文档。\n 代码/语法 说明 \\a 报警字符(打印它的效果是电脑嘀一声) \\b 通常是单词分界位置，但如果在字符类里使用代表退格 \\t 制表符，Tab \\r 回车 \\v 竖向制表符 \\f 换页符 \\n 换行符 \\e Escape \\0nn ASCII代码中八进制代码为nn的字符 \\xnn ASCII代码中十六进制代码为nn的字符 \\unnnn Unicode代码中十六进制代码为nnnn的字符 \\cN ASCII控制字符。比如\\cC代表Ctrl+C \\A 字符串开头(类似^，但不受处理多行选项的影响) \\Z 字符串结尾或行尾(不受处理多行选项的影响) \\z 字符串结尾(类似$，但不受处理多行选项的影响) \\G 当前搜索的开头 \\p{name} Unicode中命名为name的字符类，例如\\p{IsGreek} (?\u0026gt;exp) 贪婪子表达式 (?-exp) 平衡组 (?im-nsx:exp) 在子表达式exp中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 (?(exp)yes|no) 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no (?(exp)yes) 同上，只是使用空表达式作为no (?(name)yes|no) 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no (?(name)yes) 同上，只是使用空表达式作为no 网上的资源及本文参考文献\n 微软的正则表达式教程 System.Text.RegularExpressions.Regex类(MSDN) 专业的正则表达式教学网站(英文) 关于.Net下的平衡组的详细讨论（英文） Mastering Regular Expressions (Second Edition) ","dateformatted":"28, September 2017","dateiso":"2017-09-28T15:42:33Z","ref":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F30%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","summary":"\n 目录 跳过目录\n 本文目标 如何使用本教程 正则表达式到底是什么东西？ 入门 测试正则表达式 元字符 字符转义 重复 字符类 分枝条件 反义 分组 后向引用 零宽断言 负向零宽断言 注释 贪婪与懒惰 处理选项 平衡组/递归匹配 还有些什么东西没提到 联系作者 网上的资源及本文参考文献 更新纪录 本文目标 30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。\n\n","tags":["软文收集"],"title":"正则表达式30分钟入门教程"},{"content":"图片嵌入 使用URL链接的形式插入图片：\n![image][url_to_image]1 这样做一个明显的麻烦之处在于处理图片与Markdown文档的一致性上。如果我们要拷贝文档，或者图片遭到误删/云端链接失效，就会变得不便。最让我们省心的方法便是将图片直接放到文档内部。\n一个将图片嵌入文档中的方法是使用base64编码。步骤比较简单：\n 将图片或截图保存在本地； 使用在线工具将图片转码至base64编码；(link1, link2)； 在文档中插入编码： ![image][data:image/png;base64, ......]1 当然base64编码一般很长，直接将编码放入段落内部会影响正常编辑。通常的做法是将base64编码定义到一个中间变量中，将编码本体放到文档末：\n![image][tmp] your document here ... [tmp]:data:image/png;base64, ......1234 使用该技巧的时候需要注意，并不是所有的Markdown编辑器都支持这种方法。而且一些Markdown编辑器只支持特定的图片格式。如有道云笔记只支持png格式的图片编码。需要在保存图片文件的时候加以注意。\n","dateformatted":"21, September 2017","dateiso":"2017-09-21T15:42:33Z","ref":"/markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"\n 图片嵌入 使用URL链接的形式插入图片：\n![image][url_to_image]1 这样做一个明显的麻烦之处在于处理图片与Markdown文档的一致性上。如果我们要拷贝文档，或者图片遭到误删/云端链接失效，就会变得不便。最让我们省心的方法便是将图片直接放到文档内部。\n一个将图片嵌入文档中的方法是使用base64编码。步骤比较简单：\n 将图片或截图保存在本地； 使用在线工具将图片转码至base64编码；(link1, link2)； 在文档中插入编码： ![image][data:image/png;base64, ......]1 当然base64编码一般很长，直接将编码放入段落内部会影响正常编辑。通常的做法是将base64编码定义到一个中间变量中，将编码本体放到文档末：\n![image][tmp] your document here ... [tmp]:data:image/png;base64, .\n\n","tags":null,"title":"Markdown基本使用"},{"content":"开源监控软件对比 Cacti**（英文含义仙人掌）** 是一套基于PHP、MySQL、SNMP和RRDtool开发的网络流量监测图形分析工具，它通过snmpget来获取数据使用RRDtool绘图，简化RRDtool使用。提供了非常强大的数据和用户管理功能，可以指定每一个用户能查看树状结构、主机设备以及任何一张图，还可以与LDAP结合进行用户认证，同时也能自定义模板。在历史数据展示监控方面，其功能相当不错。\nCacti通过添加模板，使不同设备的监控添加具有可复用性，并且具备可自定义绘图的功能，具有强大的运算能力（数据的叠加功能）\n nagios Nagios是一款开源的免费网络监视工具，能有效监控Windows、Linux和Unix的主机状态，交换机路由器等网络设置，打印机等。\nNagios 可以监控的功能有： 1、监控网络服务（SMTP、POP3、HTTP、NNTP、PING等）； 2、监控主机资源（处理器负荷、磁盘利用率等）； 3、简单地插件设计使得用户可以方便地扩展自己服务的检测方法； 4、并行服务检查机制； 5、具备定义网络分层结构的能力，用\u0026quot;parent\u0026quot;主机定义来表达网络主机间的关系，这种关系可被用来发现和明晰主机宕机或不可达状态； 6、当服务或主机问题产生与解决时将告警发送给联系人（通过EMail、短信、用户定义方式）； 7、具备定义事件句柄功能，它可以在主机或服务的事件发生时获取更多问题定位； 8、自动的日志回滚； 9、可以支持并实现对主机的冗余监控； 10、可选的WEB界面用于查看当前的网络状态、通知和故障历史、日志文件等；\n Ganglia 是一个跨平台的、可扩展的、高性能的分布式监控系统，如集群和网格。它基于分层设计，使用广泛的技术，用RRDtool存储数据。具有可视化界面，适合对集群系统的自动化监控。其精心设计的数据结构和算法使得监控端到被监控端的连接开销非常低。目前已经有成千上万的集群正在使用这个监控系统，可以轻松的处理2000个节点的集群环境。\nGanglia的强大在于：ganglia服务端能够通过一台客户端收集到同一个网段的所有客户端的数据，ganglia集群服务端能够通过一台服务端收集到它下属的所有客户端数据。\n Zabbix 是一个基于web界面的分布式监控系统，支持多种采集方式采集客户端，有专用的Agent代理，也支持SNMP、IPMI、JMX、Telnet、SSH等多种协议，它将采集到的数据存放到数据库，然后对其进行分析整理，达到条件触发告警。其灵活的扩展性和丰富的功能是其他监控系统所不能比的。\n\n结论：\n从以上各种监控系统的对比来看，Zabbix都是具有优势的，其丰富的功能、可扩展的能力、二次开发的能力和简单易用的特点，读者只要稍加学习，即可构建自己的监控系统。\nZabbix 选择zabbix的理由： - 安装与配置简单，学习成本低 - 支持多语言（包括中文） - 免费开源\n- 数据采集到数据库，可二次分析监控数据的。 - 自动发现服务器与网络设备 - 分布式监视以及WEB集中管理功能 - 可以无agent监视 - 用户安全认证和柔软的授权方式 - 通过WEB界面设置或查看监视结果 - email等通知功能 等等\n组成： zabbix server：可以通过SNMP、zabbixagent、ping、端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux, Solaris, HP-UX, AIX, Free BSD, Open BSD, OS X等平台之上。\nzabbix agent（可选组件）：安装在被监视的目标服务器上，它主要完成对硬件信息或与操作系统有关的内存，CPU等信息的收集。\n生命周期 \n目前推荐使用Zabbix2.2\n安装 准备： epel源、mysql已安装(yum install mysql-server)、zabbix官方仓库（http://repo.zabbix.com/）\n 安装epel源 # wget –O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo\n安装Zabbix官方源码： #rpm -ivh http://repo.zabbix.com/zabbix/2.2/rhel/6/x86_64/zabbix-release-2.2-1.el6.noarch.rpm\n安装zabbix server： \\3. 安装依赖包yum install -y OpenIPMI\n \\4. yum install -y zabbix-server zabbix-server-mysql\n\n创建数据库 \nmysql\u0026gt; create database zabbix; mysql\u0026gt; grant all on zabbix.* to zabbix@localhost identified by \u0026quot;zabbix_pass\u0026quot;; # mysql -uzabbix -pzabbix_pass -hlocalhost zabbix # 测试 # rpm -ql zabbix-server-mysql 导入server端数据表（注意顺序）： # mysql -uzabbix -pzabbix_pass -hlocalhost zabbix \u0026lt;/usr/share/doc/zabbix-server-mysql-2.2.11/create/schema.sql \u0026lt;--导入数据结构 #mysql -uzabbix -pzabbix_pass -hlocalhost zabbix \u0026lt;/usr/share/doc/zabbix-server-mysql-2.2.11/create/images.sql \u0026lt;--导入图片 # mysql -uzabbix -pzabbix_pass -hlocalhost zabbix \u0026lt;/usr/share/doc/zabbix-server-mysql-2.2.11/create/data.sql \u0026lt;--导入数据 \n修改配置文件 # vim /etc/zabbix/zabbix_server.conf \u0026lt;\u0026ndash;增加zabbix使用数据库的密码 [root@zabbix-server ~]# egrep -v \u0026ldquo;^#|^$\u0026rdquo; /etc/zabbix/zabbix_server.conf\nLogFile=/var/log/zabbix/zabbix_server.log\nLogFileSize=0\nPidFile=/var/run/zabbix/zabbix_server.pid\nDBHost=localhost\nDBName=zabbix\nDBUser=zabbix\nDBPassword=zabbix_pass ** \u0026lt;\u0026ndash;需修改同数据库设置**\nDBSocket=/tmp/mysql.sock\nSNMPTrapperFile=/var/log/snmptt/snmptt.log\nAlertScriptsPath=/usr/lib/zabbix/alertscripts\nExternalScripts=/usr/lib/zabbix/externalscripts\n启动zabbix server： #service zabbix-server start\n# netstat -ntlpu|grep 10051 ß检查启动状态\n# chkconfig zabbix-server on ß添加开机启动\nserver端安装zabbix web： \\1. # yum install zabbix-web zabbix-web-mysql\n\n默认安装了httpd服务，启动httpd\n# chkconfig httpd on ß添加开机启动\n\\2. 访问http://ip/zabbix进入安装\n\n==\u0026gt;解决：修改时区 # vim /etc/httpd/conf.d/zabbix.conf\n\n 登录默认用户admin 密码：zabbix\n 修改字体\n vim /usr/share/zabbix/include/locales.inc.php\nyum -y install wqy-microhei-fonts ß安装中文字体集\nrm -f /etc/alternatives/zabbix-web-font #删除原有字体连接文件\nln -s /usr/share/fonts/wqy-microhei/wqy-microhei.ttc /etc/alternatives/zabbix-web-font\n安装agent 客户端和服务端都安装\n\\1. # yum install -y zabbix-agent\n\n# vim /etc/zabbix/zabbix_agentd.conf //修改被动模式IP为zabbix server ip\n\n注：（一个Agent是可以同时向多个服务器端发送数据，多个Ip用逗号隔开）\nServer：被动模式，允许哪台服务器连接Agent。\nServerActive：主动模式，向哪台服务器传送数据。\n# /etc/init.d/zabbix-agent start //启动agent\n# netstat -lntp |grep 10050 //验证端口\n如果提示不能正常运行，分别检查zabbix_server.conf中的各项配置文件、Selinux、Iptables等。配置文件请检查以下文件的正确配置参数。\n1./etc/zabbix/zabbix_server.conf中的参数。\n# DBHost=localhost ß数据库的IP(域名)地址\nDBName=zabbix ß数据库的名称\nDBUser=zabbix ß数据库的用户\nDBPassword=zabbix ß数据库的密码\n2./etc/zabbix/web/zabbix.conf.php中的配置。\n[root@linux-node1 ~]# cat /etc/zabbix/web/zabbix.conf.php\n监控流程 \nZabbix-Get使用 Zabbix-Get是Zabbix中的一个程序，用于Zabbix-Server到Zabbix-Agent的数据获取，通常可以用来检测验证Agent的配置是否正确。\n用法：zabbix_get [-hV] -s [-p ] [-I ] -k -s：远程Zabbix-Agent的IP地址或者是主机名。\n-p：远程Zabbix-Agent的端口。\n-l：本机出去的IP地址，用于一台机器中又多个网卡的情况。\n-k：获取远程Zabbix-Agent数据所使用的Key。\n实现监控cpu（zabbix server主机上操作） # yum install -y zabbix-get //安装zabbix-get工具\n# zabbix_get -s 192.168.3.113 -k system.cpu.util[,user]\n\nAgent数据采集方式：passive、active\nOther Agent：SNMP、IPMI、Java Gateway\n","dateformatted":"18, September 2017","dateiso":"2017-09-18T15:42:33Z","ref":"/%E5%BC%80%E6%BA%90%E7%9B%91%E6%8E%A7%E8%BD%AF%E4%BB%B6%E5%AF%B9%E6%AF%94_zabbix/","summary":"\n 开源监控软件对比 Cacti**（英文含义仙人掌）** 是一套基于PHP、MySQL、SNMP和RRDtool开发的网络流量监测图形分析工具，它通过snmpget来获取数据使用RRDtool绘图，简化RRDtool使用。提供了非常强大的数据和用户管理功能，可以指定每一个用户能查看树状结构、主机设备以及任何一张图，还可以与LDAP结合进行用户认证，同时也能自定义模板。在历史数据展示监控方面，其功能相当不错。\nCacti通过添加模板，使不同设备的监控添加具有可复用性，并且具备可自定义绘图的功能，具有强大的运算能力（数据的叠加功能）\n nagios Nagios是一款开源的免费网络监视工具，能有效监控Windows、Linux和Unix的主机状态，交换机路由器等网络设置，打印机等。\nNagios 可以监控的功能有： 1、监控网络服务（SMTP、POP3、HTTP、NNTP、PING等）； 2、监控主机资源（处理器负荷、磁盘利用率等）； 3、简单地插件设计使得用户可以方便地扩展自己服务的检测方法； 4、并行服务检查机制； 5、具备定义网络分层结构的能力，用\u0026quot;parent\u0026quot;主机定义来表达网络主机间的关系，这种关系可被用来发现和明晰主机宕机或不可达状态； 6、当服务或主机问题产生与解决时将告警发送给联系人（通过EMail、短信、用户定义方式）； 7、具备定义事件句柄功能，它可以在主机或服务的事件发生时获取更多问题定位； 8、自动的日志回滚； 9、可以支持并实现对主机的冗余监控； 10、可选的WEB界面用于查看当前的网络状态、通知和故障历史、日志文件等；\n\n","tags":["软文收集","zabbix"],"title":"开源监控软件对比_zabbix"},{"content":"博客工具\n概述 Hugo Hexo Jekyll 博客工具\nHexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n安装hexo 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：\n Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。\n Mac 用户\n您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -\u0026gt; Download -\u0026gt; Command Line Tools -\u0026gt; Install 安装命令行工具。\n 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Windows 用户\n由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。\n 安装 Node.js 安装 Node.js 的最佳方式是使用 nvm。\ncURL:\n$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget:\n$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。\n$ nvm install stable 或者您也可以下载 安装程序 来安装。\n Windows 用户\n对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。 另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。\n 安装 Hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n$ npm install -g hexo-cli 变量 全局变量 变量\t描述 site\t网站变量 page\t针对该页面的内容以及 front-matter 所设定的变量。 config\t网站配置 theme\t主题配置。继承自网站配置。 _ (单下划线)\tLodash 函数库 path\t当前页面的路径（不含根路径） url\t当前页面的完整网址 env\t环境变量\n网站变量 变量\t描述 site.posts\t所有文章 site.pages\t所有分页 site.categories\t所有分类 site.tags\t所有标签\n页面变量 页面（page）\n变量\t描述 page.title\t页面标题 page.date\t页面建立日期（Moment.js 对象） page.updated\t页面更新日期（Moment.js 对象） page.comments\t留言是否开启 page.layout\t布局名称 page.content\t页面的完整内容 page.excerpt\t页面摘要 page.more\t除了页面摘要的其余内容 page.source\t页面原始路径 page.full_source\t页面的完整原始路径 page.path\t页面网址（不含根路径）。我们通常在主题中使用 url_for(page.path)。 page.permalink\t页面的完整网址 page.prev\t上一个页面。如果此为第一个页面则为 null。 page.next\t下一个页面。如果此为最后一个页面则为 null。 page.raw\t文章的原始内容 page.photos\t文章的照片（用于相簿） page.link\t文章的外部链接（用于链接文章）\n文章 (post): 和 page 布局类似，但是添加了下列变量。\n变量\t描述 page.published\t如果该文章已发布则为True page.categories\t该文章的所有分类 page.tags\t该文章的所有标签\n首页（index）\n变量\t描述 page.per_page\t每页显示的文章数量 page.total\t总文章数 page.current\t目前页数 page.current_url\t目前分页的网址 page.posts\t本页文章 page.prev\t上一页的页数。如果此页是第一页的话则为 0。 page.prev_link\t上一页的网址。如果此页是第一页的话则为 \u0026lsquo;'。 page.next\t下一页的页数。如果此页是最后一页的话则为 0。 page.next_link\t下一页的网址。如果此页是最后一页的话则为 \u0026lsquo;'。 page.path\t当前页面的路径（不含根目录）。我们通常在主题中使用 url_for(page.path)。\n归档 (archive)：与 index 布局相同，但新增以下变量。\n变量\t描述 page.archive\t等于 true page.year\t年份归档 (4位) page.month\t月份归档 (没有前导零的2位数)\n分类 (category)：与 index 布局相同，但新增以下变量。\n变量\t描述 page.category\t分类名称 标签 (tag)：与 index 布局相同，但新增以下变量。\n变量\t描述 page.tag\t标签名称\n新建页面 （以添加关于页为例）： hexo new page about 编辑生成的 about/index.md 文件，设置布局为 page: title: about layout: page\n插件使用 hexo-asset-image Give asset image in hexo a absolutely path automatically\n安装\nnpm install hexo-asset-image \u0026ndash;save\n例子\nMacGesture2-Publish ├── apppicker.jpg ├── logo.jpg └── rules.jpg MacGesture2-Publish.md\nMake sure post_asset_folder: true in your _config.yml.\n利用markdown标签\nJust use ![logo](logo.jpg) to insert logo.jpg.\n利用标签引用\n{% asset_path slug %} {% asset_img slug [title] %} {% asset_link slug [title] %}\nhexo-tag-html5 Adding embedded html5 video to hexo\n{% html5video %} {% asset_path big-buck-bunny_trailer.webm %} {% endhtml5video %}\nUsage: With no args, the defaults are used: width = \u0026lsquo;100%\u0026rsquo; height = \u0026lsquo;250px\u0026rsquo; codec = \u0026lsquo;video/webm\u0026rsquo;\n{% html5video %} {% asset_path big-buck-bunny_trailer.webm %} {% endhtml5video %}\nor with args:\n{% html5video \u0026lsquo;100%\u0026rsquo; \u0026lsquo;250px\u0026rsquo; \u0026lsquo;video/mp4\u0026rsquo; %} {% asset_path big-buck-bunny_trailer.webm %} {% endhtml5video %}\nAdd hexo-tag-html5 to your _config.yml file including all the other packages you\u0026rsquo;re using. (Once you include one, you will need to include them all, grab the list from you package.json)\nExample: plugins: [hexo-tag-html5, hexo-deployer-git, hexo-server, hexo-generator-index, hexo-generator-archive, hexo-generator-category, hexo-generator-json-content, hexo-generator-tag, hexo-renderer-ejs, hexo-renderer-marked, hexo-renderer-stylus, hexo-tag-bootstrap, hexo-tag-fontawesome, hexo-tag-leaflet]\n","dateformatted":"16, September 2017","dateiso":"2017-09-16T15:42:33Z","ref":"/hexo%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","summary":"\n 博客工具\n概述 Hugo Hexo Jekyll 博客工具\nHexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n安装hexo 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：\n Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n\n","tags":["hexo"],"title":"Hexo基础使用"},{"content":"1.alibaba 1.1.https://github.com/alibaba/canal.git canal [kə\u0026rsquo;næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费\n工作原理\n canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议 MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal ) canal 解析 binary log 对象(原始为 byte 流) 谷歌的TensorFlow可以说是当今最受欢迎的开源深度学习框架，可用于各类深度学习相关的任务中。TensorFlow = Tensor + Flow，Tensor就是张量，代表N维数组；Flow即流，代表基于数据流图的计算。\n2.google 2.1 https://github.com/rstudio/tensorflow TensorFlow是目前深度学习的主流框架，其主要特性如下所述。\n TensorFlow支持Python、JavaScript、C ++、Java、Go、C＃、Julia和R等多种编程语言。 TensorFlow不仅拥有强大的计算集群，还可以在iOS和Android等移动平台上运行模型。 TensorFlow编程入门难度较大。初学者需要仔细考虑神经网络的架构，正确评估输入和输出数据的维度和数量。 TensorFlow使用静态计算图进行操作。也就是说，我们需要先定义图形，然后运行计算，如果我们需要对架构进行更改，则需要重新训练模型。选择这样的方法是为了提高效率，但是许多现代神经网络工具已经能够在学习过程中改进，并且不会显著降低学习速度。在这方面，TensorFlow的主要竞争对手是PyTorch。 其他深度学习项目参考\n https://github.com/keras-team/keras https://github.com/BVLC/caffe https://github.com/pytorch/pytorch https://github.com/Theano/Theano https://github.com/Microsoft/CNTK https://github.com/apache/incubator-mxnet https://github.com/PaddlePaddle/Paddle/ https://github.com/eclipse/deeplearning4j https://github.com/onnx/onnx\n 3.linkedin 3.1 https://github.com/linkedin onecall\n4.go microservices 4.1.Istio 项目简介：Istio是由Google、IBM和Lyft开源的微服务管理、保护和监控框架。使用istio可以很简单的创建具有负载均衡、服务间认证、监控等功能的服务网络，而不需要对服务的代码进行任何修改。\n仓库地址：https://github.com/istio/istio（30.1K）\n官方文档地址：https://istio.io/latest/docs/\n2.Go-kit 项目简介：Go-kit 是一个 Go 语言的分布式开发包，用于开发微服务。\n仓库地址：https://github.com/go-kit/kit/（22.9K）\n官方文档地址：https://gokit.io/\n3.Go-micro 项目简介：Micro是一个专注于简化分布式系统开发的微服务生态系统。可插拔的插件化设计，提供强大的可插拔的架构来保证基础组件可以被灵活替换。\n仓库地址：GitHub - asim/go-micro: A Go microservices framework（18.1K）\n官方文档地址：https://go-micro.dev/\n中文文档：https://www.kancloud.cn/linimbus/go-micro/529015\n4.Kratos 项目简介：哔哩哔哩(B站)开源的一套Go微服务框架，包含大量微服务相关框架及工具。\n仓库地址：https://github.com/go-kratos/kratos（17.4K）\n官方文档地址：https://go-kratos.dev/docs/\n5.Go-zero 项目简介：go-zero 是一个集成了各种工程实践的 web 和 rpc 框架。\n仓库地址：https://github.com/tal-tech/go-zero（16.9K）\n6.Goa 项目简介：Goa 是一款用 Go 用于构建微服务的框架，采用独特的设计优先的方法\n仓库地址：https://github.com/goadesign/goa（4.6K）\n官方文档地址：https://goa.design/\n7.Dubbo-go 项目简介：阿里，由Apache 软件基金会官方发布Go 语言加入 Dubbo 生态，架构是基于dubbo的extension模块和分层的代码设计，主要解决 Go 项目与 Java \u0026amp; Dubbo 项目的互通问题，同时也为 Go 项目提供了一种 RPC 与微服务\n仓库地址：https://github.com/apache/dubbo-go（4K）\n官方文档地址：https://dubbogo.github.io/dubbo-go-website/zh-cn/\n8.CloudWeGo-Kitex 项目简介：字节跳动，KiteX 自 2020.04 正式发布以来，公司内部服务数量 8k+，QPS 过亿。KiteX 是字节跳动框架组研发的下一代高性能、强可扩展性的 Go RPC 框架。除具备丰富的服务治理特性外，相比其他框架还有以下特点：集成了自研的网络库 Netpoll；支持多消息协议（Thrift、Protobuf）和多交互方式（Ping-Pong、Oneway、 Streaming）；提供了更加灵活可扩展的代码生成器。\n仓库地址：https://github.com/cloudwego/kitex（4K）\n官方文档地址：https://www.cloudwego.io/zh/docs/overview/\n9.Jupiter 项目简介：斗鱼开源的一套微服务治理框架，提供丰富的后台功能，管理应用的资源、配置，应用的性能、配置等可视化。\n仓库地址：https://github.com/douyu/jupiter\n官方文档地址：http://jupiter.douyu.com/（3.7K）\n10.Tars-go 项目简介：腾讯，Tarsgo是基于Golang编程语言使用Tars协议的高性能RPC框架\n仓库地址：https://github.com/TarsCloud/TarsGo（3K）\n官方文档地址：https://tarscloud.github.io/TarsDocs/SUMMARY.html#TarsGo\n11.北极星-polaris-go 北极星是腾讯开源的服务发现和治理中心，致力于解决分布式或者微服务架构中的服务可见、故障容错、流量控制和安全问题。 仓库地址：https://github.com/polarismesh/polaris\n其他 https://github.com/saucxs/watermark-dom 一款居于dom水印插件\nhttps://github.com/gohugoio/hugo 一款快速静态站点生成器,基于GO开发\n待整理 https://github.com/shadowsocks https://github.com/PingPlusPlus https://thinkjs.org/zh-cn/doc/3.0/controller.html#toc-7d3 https://github.com/Tencent https://github.com/Meituan-Dianping https://github.com/dianping https://github.com/dcloudio https://github.com/didi https://algorithm-visualizer.org/ https://github.com/yuuwill https://github.com/LibreOffice https://gitee.com/gvp https://github.com/iqiyi https://github.com/rancher https://www.gitbook.com/@skyao https://github.com/waylau/books-collection https://github.com/twbs https://github.com/sonatype https://chromium.googlesource.com/v8/v8.git https://github.com/antvis https://github.com/o2team https://github.com/JetBrains https://github.com/tencentyun https://github.com/OpenTSDB https://github.com/fex-team https://github.com/sofastack https://github.com/seata https://github.com/sohutv https://github.com/open-falcon-archive https://github.com/Netflix https://github.com/renrenio\n","dateformatted":"16, September 2017","dateiso":"2017-09-16T15:42:33Z","ref":"/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%B4%A2%E5%BC%95/","summary":"\n 1.alibaba 1.1.https://github.com/alibaba/canal.git canal [kə\u0026rsquo;næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费\n工作原理\n canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议 MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal ) canal 解析 binary log 对象(原始为 byte 流) 谷歌的TensorFlow可以说是当今最受欢迎的开源深度学习框架，可用于各类深度学习相关的任务中。TensorFlow = Tensor + Flow，Tensor就是张量，代表N维数组；Flow即流，代表基于数据流图的计算。\n\n","tags":["git"],"title":"开源项目索引"},{"content":"","dateformatted":"5, September 2017","dateiso":"2017-09-05T07:43:59+02:00","ref":"/kortkommandon-windows7/","summary":"\n \n\n","tags":null,"title":"Kortkommandon Windows 7"},{"content":"划分音节的五个步骤 音节简介\n开音节是以发音的元音a，e，i，o，u结尾的单词，或辅音+不发音e音节。r除外。开音节在和后面有辅音连续时很容易犯错，如，I like Bob，这句如果不懂得E是不发音的那句子就会读错。\n以一个或几个辅音字母（r除外）结尾而中间只有一个元音音素的音节，称为闭音节。例：map，desk，dog，pig\n注：在闭音节中，元音字母不发“字母”本身的音。重读的闭音节中元音字母读作短元音。\n重读闭音节是指在一个音节中，以辅音因素结尾的而且是重读音节的音节。重读闭音节中元音字母不是发它本身的字母音，而是发短元音，要注意其三要素\n（1）一个元音字母后跟一个或几个辅音字母，他们组成的音节必须是重读音节，如：apple。\n（2）以一个辅音字母结尾，如：fish。\n（3）元音字母发短元音。\n1.一个单词中有几个发音的元音字母，就有几个音节。\n2.两个元音间有两个辅音，则辅音分开，一边一个。\n3.两个元音间只有一个辅音，该辅音划分到后一个音节。\n4.字母组合要划分到同一个音节。\n5.词尾不发音的e不构成音节。\n6.两个元音字母在一起，一般为字母组合，发一个元音、构成一个音节。\n步骤：从后往前找到元音：单词中有多个元音时，方法都一样。\n元音往前找辅音。元音找到辅音，形成拼音，算一个音节。\n元音找不到辅音，自行发音，形成一个音节。\n辅音分配给念起来顺的音节；\n元音的前后最多三个辅音str-ai-ght。\n1音节划分步骤 1、找到元音：单词中有多个元音时，方法都一样。\n2、元音往前找辅音。\n3、元音找到辅音，形成拼音，算一个音节。\n4、元音找不到辅音，自行发音，形成一个音节。\n5、辅音分配给念起来顺的音节；元音的前后最多三个辅音str-ai-ght。\n2音节划分口诀 一靠后，二分手，多个中间偏左右，\n组合字母算一个，常见组合要遵守。\n词尾看e加音节，发音不发分两种，\n双字相连不连手，听音验证最后头。\n3判断开音节还是闭音节 （1）两元音字母之间如有两个辅音字母，则中间分开，一边一个。如mat－ter，mem－ber，win-dow，doc－tor，sup-per，lit－tle等。这样一分，第一个音节是以辅音字母结尾的，它就是重读闭音节，元音字母读短元音。\n（2）两元音字母中间有一辅音字母，该辅音字母划归后一音节。如basic，region，open，human等。这样一分，头一个音节是以元音字母结尾的，它是重读开音节，元音字母读其字母音。但是，双音节词中，重读开音节中的元音字母有不少仍读短元音。如second，present，ever，hover，modern，proper等。第二音节中有／i／时，第一音节中的a，e，i，o大多读短元音。如spanish，habit，mes-sage，city，system，profit等。\n（3）第一音节如是r音节或其他元音字母组合，其读音方法和单音节词基本一样，如army，merit，circle，order，purple，awful，autumn等。但也有读短元音的，如knowledge，nourish等。\n（4）非重读音节中的元音字母a，e，o，u，及字母组合ar，er，or，ure等一般读为／+／，如about，silent，atom，supply，radar，supper，doctor等。i，y及字母组合ay，ey一般读作／i／，如acid，thirty，Sunday，valley。a，e也可读作人／i／，如comrade，before等。o在词尾时仍读字母音。如hero，Negro等。\n","dateformatted":"1, January 0001","dateiso":"0001-01-01T00:00:00Z","ref":"/","summary":"\n 划分音节的五个步骤 音节简介\n开音节是以发音的元音a，e，i，o，u结尾的单词，或辅音+不发音e音节。r除外。开音节在和后面有辅音连续时很容易犯错，如，I like Bob，这句如果不懂得E是不发音的那句子就会读错。\n以一个或几个辅音字母（r除外）结尾而中间只有一个元音音素的音节，称为闭音节。例：map，desk，dog，pig\n注：在闭音节中，元音字母不发“字母”本身的音。重读的闭音节中元音字母读作短元音。\n重读闭音节是指在一个音节中，以辅音因素结尾的而且是重读音节的音节。重读闭音节中元音字母不是发它本身的字母音，而是发短元音，要注意其三要素\n（1）一个元音字母后跟一个或几个辅音字母，他们组成的音节必须是重读音节，如：apple。\n（2）以一个辅音字母结尾，如：fish。\n（3）元音字母发短元音。\n1.一个单词中有几个发音的元音字母，就有几个音节。\n2.两个元音间有两个辅音，则辅音分开，一边一个。\n3.两个元音间只有一个辅音，该辅音划分到后一个音节。\n4.字母组合要划分到同一个音节。\n5.词尾不发音的e不构成音节。\n6.两个元音字母在一起，一般为字母组合，发一个元音、构成一个音节。\n步骤：从后往前找到元音：单词中有多个元音时，方法都一样。\n元音往前找辅音。元音找到辅音，形成拼音，算一个音节。\n元音找不到辅音，自行发音，形成一个音节。\n\n","tags":null,"title":""}]