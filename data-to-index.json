[{"content":"一：参考 [算法心得] http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogIEEE64Float\n[运算符优先级] https://tool.oschina.net/commons?type=6\n[位运算技巧] https://www.zhihu.com/question/38206659\n[思考题解法] https://www.iteye.com/blog/yacare-1969931\n二：概要 通过本文可以让我们温习下位运算、进制转换，为写出更精良的代码奠定理论基础。现在我们从一个题目说开去：\n问：如何载预计有10亿个int的数据中，剔除其中重复的数据并排序输出?\n分析：首先要进行排序、排重必须得把相关数据加载到内存中，那么要用哪种数据结构来存储呢?\n10 0000 0000 = 10^9\nint[10^9] 需要内存 10^9 * 4(B) =\u0026gt; ((10^9 * 4)/1000 * 1000)(M) =\u0026gt; 4000M =\u0026gt; 4GB\n对于普通32位最大理论内存为4G的PC来说，这个计算资源是无法实现需求的，那么有没有更好的解决方法呢？在此之前先做些知识点温故。\n三：知识点回顾 1.java基本类型 Data Type Default Value Default size range range value boolean false 1 bit char \u0026lsquo;\\u0000\u0026rsquo; 2 byte \u0026lsquo;\\u0000\u0026rsquo;~'\\uFFFF' byte 0 1 byte -2^7~2^7-1 -128~127 short 0 2 byte -2^15~2^15-1 -32768~32767 int 0 4 byte -2^31~2^31-1 0x80000000~0x7fffffff long 0L 8 byte -2^63~2^63-1 float 0.0f 4 byte double 0.0d 8 byte 2.进制 **二进制：**由0，1组成，运算规律是逢二进一，计算机只能识别二进制表示的数据；\n**八进制：**由0、1、2、3、4、5、6、7组成，运算规律是逢八进一；用前导0区别，例如 012；\n**十进制：**由0，1，2、3、4、5、6、7、8、9组成，运算规律是逢十进一；例如 12；\n**十六进制：**由数字0～9以及字母A (10)，B (11)，C (12)，D (13)，E (14)，F (15)组成,大小写均可，运算规律是逢十六进一；例如 0XC；\n2.1 十进制转二进制 除2取余倒排，每发生一次除必须要有一个余数，必须除倒商是0的时候，最后把所得的余数倒排。\n2.2 二进制转十进制 按位乘权相加\n2.3 十进制转八进制 10进制数转换成8进制的方法，和转换为2进制的方法类似，唯一变化：将图1中的基数由2变成8，然后依次计算。\n2.4 八进制转十进制 可参考图2中二进制的计算过程: 进制数第1位的权值为8的0次方，第2位权值为8的1次方，第3位权值为8的2次方，依次计算，公式：第N位 * 8的N-1次方，结果再相加便是最后结果。\n2.5 十进制转十六进制: 10进制数转换成16进制的方法，和转换为2进制的方法类似，唯一变化：将图1中的基数由2变成16，然后依次计算。\n2.6 十六进制转十进制: 第0位的权值为16的0次方，第1位的权值为16的1次方，第2位的权值为16的2次方，依次计算，公式：第N位 * 16的N-1次方，结果再相加便是最后结果。\n2.7 二进制与八进制的转换 1）二进制转八进制，3位二进制位压缩为1位，\n2）八进制转二进制，1位展开为3位\n3）可先转换为十进制在转换为二进制或者八进制\n2.8 二进制与十六进制的转换 1）二进制转十六进制，4位二进制位压缩为1位，\n2）十六进制转二进制，1位展开为4位\n3）可先转换为十进制在转换为二进制或者十六进制\n2.9 八进制与十六进制的转换 可先转换为十进制在转换为十六进制或者八进制\n3.进制存储单位 在计算机的二进制数系统中，位简记为bit，也称为比特，是数据存储的最小单位，每个二进制数字0或1就是一个位(bit)，也就是一比特；也可以把二进制中的0和1看做开关中的“开”和“关”，1表示“开”，0表示“关”。\n8 bit（位）= 1B，也就是一个字节（Byte），然而1KB却不等于1000B，下面是详细的计算规则：\n1B（byte，字节）= 8 bit；\n1KB（Kilobyte，千字节）= 1024B = 2^10 B；\n1MB（Megabyte，兆字节，百万字节，简称“兆”）= 1024KB = 2^20 B；\n1GB（Gigabyte，吉字节，十亿字节，又称“千兆”）= 1024MB = 2^30 B；\n1TB（Terabyte，万亿字节，太字节）= 1024GB = 2^40 B；\n1PB（Petabyte，千万亿字节，拍字节）= 1024TB = 2^50 B；\n4.原码、反码和补码 在计算机内，有符号数（这里的符号指的是正负符号，有符号数指的就是正负数）有3种表示法：原码、反码和补码，所有数据的运算都是采用补码进行的：\n1). 正数的原码，反码，补码都相同；\n2). 负数的有些不同，详情如下：\n**原码：**根据二进制定点表示法，二进制最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。\n**反码：**负数的反码是对其原码逐位取反（0变1，1变0），但符号位除外。\n**补码：**负数的补码是在其反码的末位加1（逢二进一）。\n需要注意的是：求反码的时候，最高位（符号位）是不能被改变的， 正数的符号位是0，负数的符号位是1。\n例子：分别求出5和-5的原码、反码和补码\n5.位运算 位运算只能整型或者字符型，计算时将非二进制转成二进制后在进行按位运算，按位运算不产生进位、借位，最后在还原成十进制。\n5.1 运算符 5.1.1 位运算符 运算符 描述 运算规则 \u0026amp; 按位与 两个位都为1时，结果才为11\u0026amp;1=1 1\u0026amp;0=0 0\u0026amp;1=0 0\u0026amp;0=0 | 按位或 两个位都为0时，结果才为01|1=1 1|0=1 0|1=1 0|0=0 ^ 按位异或 两个位相同为0，相异为11^1=0 1^0=1 0^1=1 0^0=0 ~ 按位取反 0变1，1变0,属于单目运算符 \u0026laquo; 左移 各二进位全部左移若干位，高位丢弃，低位补0 \u0026raquo; 右移 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） 5.1.2 复合赋值运算符 \u0026amp;= 例：a\u0026amp;=b 相当于 a=a\u0026amp;b |= 例：a|=b 相当于 a=a|b \u0026gt;\u0026gt;= 例：a\u0026gt;\u0026gt;=b 相当于 a=a\u0026gt;\u0026gt;b \u0026lt;\u0026lt;= 例：a\u0026lt;\u0026lt;=b 相当于 a=a\u0026lt;\u0026lt;b ^= 例：a^=b 相当于 a=a^b += 例：a+=b 相当于 a=a+b -= 例：a-=b 相当于 a=a-b *= 例：a*=b 相当于 a=a*b /= 例：a/=b 相当于 a=a/b %= 例：a%=b 相当于 a=a%b 5.1.3 逻辑运算符 逻辑运算符有短路现象，\u0026amp;\u0026amp; 如果第一个数为0则会短路第2个结果为0，||如果第一个数非0短路第2个结果为1\n 运算符 含义 效 果 \u0026amp;\u0026amp; 与 将两个表达式连接成一个。两个表达式必须都为 true，整个表达式才为 true || 或 将两个表达式连接成一个。必须有一个或两个表达式为 true，才能使整个表达式为 true。只要其中有一个为 true，那么另外一个就变得无关紧要 ！ 非 反转一个表达式的“真相”。它使一个表达式从 true 变成了 false，或者从 false 变成了 true 5.2 按位运算 计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。\n5.2.1 \u0026amp; 按位与运算 ​ 1 0 0 1 1 \u0026amp; 1 1 0 0 1 ------------------------------ ​ 1 0 0 0 1\n全1为1，有0为0，也叫按位乘\n主要作用：\n1）清零\n如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。\n2）取一个数的指定位\n比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X\u0026amp;Y=0000 1110）即可得到X的指定位。\n3）判断奇偶\n只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a \u0026amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。\n5.2.2 | 按位或运算 ​ 1 0 0 1 1 | 1 1 0 0 1 ------------------------------ ​ 1 1 0 1 1\n有1为1，全0为0，也叫按位加。注意：负数按补码形式参加按位或运算。\n主要作用：置1操作\n5.2.3 ^ 按位异或运算 ​ 1 0 0 1 1 ^ 1 1 0 0 1 ----------------------------- ​ 0 1 0 1 0\n相异为1，相同为0\n异或的几条性质:\n 1、交换律 2、结合律 (a^b)^c == a^(b^c) 3、对于任何数x，都有 x^x=0，x^0=x 4、自反性: a^b^b=a^0=a; 异或运算的用途：\n1）翻转指定位\n比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。\n2）与0相异或值不变\n例如：1010 1110 ^ 0000 0000 = 1010 1110\n3）交换两个数\nvoid Swap(int \u0026amp;a, int \u0026amp;b){ if (a != b){ a ^= b; b ^= a; a ^= b; } } 5.2.4 ~ 按位取反运算 ~ 1 0 0 1 1 ----------------------------- 0 1 1 0 0\n对于一个数按位取反得到的值为该数+1后在乘以-1\n**技巧：(该数+1) * (-1) **\n异或运算的用途：\n1）使一个数的最低位为零\n使a的最低位为0，可以表示为：a \u0026amp; ~1。~1的值为 1111 1111 1111 1110，再按\u0026quot;与\u0026quot;运算，最低位一定为0。因为\u0026quot; ~\u0026ldquo;运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。\n5.2.5 \u0026laquo; 按位左移运算 int a = 8; a \u0026lt;\u0026lt; 3; 移位前：0000 0000 0000 0000 0000 0000 0000 1000 移位后：0000 0000 0000 0000 0000 0000 0100 0000 主要作用：将二进制位按位依序左移n位\n对于一个十进制数左移n位后得到的值为该数乘以2^n的积。\n5.2.6 \u0026raquo; 按位右移运算 向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，如\nunsigned int a = 8; a \u0026gt;\u0026gt; 3; 移位前：0000 0000 0000 0000 0000 0000 0000 1000 移位后：0000 0000 0000 0000 0000 0000 0000 0001 int a = -8; a \u0026gt;\u0026gt; 3; 移位前：1111 1111 1111 1111 1111 1111 1111 1000 移位前：1111 1111 1111 1111 1111 1111 1111 1111 主要作用：将二进制位按位依序右移n位\n对于一个十进制数，若该数为负数 并且 不能被2^n整除，则得到的数为商加-1。\n正数||(负数 \u0026amp;\u0026amp; 能被2^n整除)则结果为=\u0026gt; 数/2^n (负数 \u0026amp;\u0026amp; 不能被2^n整除)则结果为=\u0026gt;数/2^n+(-1)\n5.3 位运算技巧 1、 a \u0026amp; a = a a | a = a a ^ a = 0 2、 a \u0026amp; 0 = 0 a | 0 = a a ^ 0 = a 3、 a | ( a \u0026amp; b ) = a a \u0026amp; ( a | b ) = a 4、交换值 a ^= b; b ^= a; a ^= b; 5、判断奇偶(取出最后一位) a \u0026amp; 1 等价于 a % 2(结果等于,位运算效率高) 6、比较两值是否相等 a ^ b ==0 7、i+1位 置1 a |=1\u0026lt;\u0026lt;i 8、i+1位 置0 a \u0026amp;=~(1\u0026lt;\u0026lt;i) 9、取出i+1位(联系第5点) a \u0026amp; (1\u0026lt;\u0026lt;i) 10、在对应i+1位，插入b的对应位； a |=1\u0026lt;\u0026lt;i; （a的bit位置1） a \u0026amp; (b \u0026amp; 1\u0026lt;\u0026lt;i) （与b的bit位相与） 11、删除最后的1； a \u0026amp; (a-1) 12、负数 -a = ~a+1 13、仅保留最后一个1; a\u0026amp;(-a) 14、得到全1 ~0 15、保留最后i-1位； a \u0026amp; ((1\u0026lt;\u0026lt;i)-1) 16、清零最后i-1位； a \u0026amp; ~((1\u0026lt;\u0026lt;i)-1) 17、判断最高位是否为1 a\u0026amp;lt;0 18、得到最高位的1； a = a |(a\u0026gt;\u0026gt;1); a = a |(a\u0026gt;\u0026gt;2); a = a |(a\u0026gt;\u0026gt;4); a = a |(a\u0026gt;\u0026gt;8); a = a |(a\u0026gt;\u0026gt;16); return (a+1)\u0026gt;\u0026gt;1; 四：问题解答 对于概要的问题，有没有更好的方式来解决呢，答案是肯定的。\n计算机中最小的存储单位是bit，它的值只有两个0或1，假如刚好有10亿个int的数据，那么我们是否可以构造出10个bit,然后以我们想象中的方式从左到右平铺开来，然后把这10亿个int的数据从小到大一一对应到这些bit中，如果数值存在则标记为1，那么所需空间为10^9位，换算成10^9/8/1000/1000 约为125M，\n由于两位bit可以表示4位数即2^2，那么对于4个byte能表示的数据量为2^32个(bit)，2^32 bit =2^32 / 2^3(byte) = 2^29 byte= 512M；int数据范围为【-2^31,2^31-1】即[-21,4748,3648 ~ 21,4748,3648-1]\n那么把10亿个数据平铺开的效果如下：\n那么可以得出\n long bitIndex = 任意int数 + (1l \u0026laquo; 31); 得出数字在理论bit数组中的位置int byteIndex = bitIndex / 8; 得出数字在真实byte[]数组的位置int innerByteIndex = bitIndex % 8; 得出数字在真实byte[byteIndex]中8个位置中的哪个位置byteData[index] = (byte) (byteData[byteIndex ] | (1 \u0026lt; innerByteIndex)); 将定位到的innerByteIndex位置如果为0设置为1\n 那么可以得出\n int bitIndex = 任意int数; 得出数字在理论bit数组中的位置int byteIndex = bitIndex / 8; 得出数字在真实byte[]数组的位置int innerByteIndex = bitIndex % 8; 得出数字在真实byte[byteIndex]中8个位置中的哪个位置byteData[index] = (byte) (byteData[byteIndex ] | (1 \u0026lt; innerByteIndex)); 将定位到的innerByteIndex位置如果为0设置为1\n 一下为有符号int的场景测试代码\nimport java.util.Random; public class BigDataSort { //数据容量 private final int CAPACITY = 1 000 000 000; // 定义一个byte数组缓存所有的数据 private byte[] byteData = new byte[1 \u0026lt;\u0026lt; 29]; public static void main(String[] args) { BigDataSort ms = new BigDataSort(); Random random = new Random(); for (int i = 0; i \u0026lt; CAPACITY; i++) { int num = random.nextInt(); System.out.println(\u0026quot;读取了第 \u0026quot; + (i + 1) + \u0026quot;\\t个数: \u0026quot; + num); ms.setNumBit(num); } ms.output(); } /** * 读取数据，并将对应数数据的 到对应的bit中，并返回byte数组 * @param num 读取的数据 */ private void setNumBit(int num) { //获取num数据对应bit数组（虚拟）的索引 long bitIndex = num + (1l \u0026lt;\u0026lt; 31); //bit数组（虚拟）在byte数组中的索引 int index = (int) (bitIndex / 8); //bitIndex 在byte[]数组索引index 中的具体位置 int innerIndex = (int) (bitIndex % 8); System.out.println(\u0026quot;byte[\u0026quot; + index + \u0026quot;] 中的索引：\u0026quot; + innerIndex); byteData[index] = (byte) (byteData[index] | (1 \u0026lt;\u0026lt; innerIndex)); return; } /** * 输出数组中的数据 */ private void output() { int count = 0; for (int i = 0; i \u0026lt; byteData.length; i++) { for (int j = 0; j \u0026lt; 8; j++) { //判断是否对应的bit位为1则输出原始数据 if (!(((byteData[i]) \u0026amp; (1 \u0026lt;\u0026lt; j)) == 0)) { count++; int number = (int) ((((long) i * 8 + j) - (1l \u0026lt;\u0026lt; 31))); System.out.println(\u0026quot;取出的第 \u0026quot; + count + \u0026quot;\\t个数: \u0026quot; + number); } } } } } 五：java无符号处理 java unsigned表示 // java 中没有 unsigned，所以为了实现 unsigned，需要使用比原本类型更大的类型，通过位运算获取其 unsigned 的值 // unsigned byte \u0026amp; short -\u0026gt; int，unsigned int -\u0026gt; long private static int getUnsignedByte(byte b) { return b \u0026amp; 0x0FF; } private static int getUnsignedShort(short data) { return data \u0026amp; 0x0FFFF; } private static long getUnsignedInt(int data) { // data \u0026amp; 0xFFFFFFFF 和 data \u0026amp; 0xFFFFFFFFL 结果是不同的，需要注意，有可能与 JDK 版本有关 return data \u0026amp; 0xFFFFFFFFL; } short、int 和 long 转 bytes import java.nio.ByteBuffer; import java.nio.ByteOrder; ByteOrder order = ByteOrder.LITTLE_ENDIAN; // long long l = 2147483648L; byte[] bytes = ByteBuffer.allocate(8).order(order).putLong(l).array(); long data = ByteBuffer.wrap(bytes, 0, bytes.length).order(order).getLong(); // int int i = 123456; byte[] bytes = ByteBuffer.allocate(4).order(order).putInt(i).array(); int data = ByteBuffer.wrap(bytes, 0, bytes.length).order(order).getInt(); // short short s = 32767; byte[] bytes = ByteBuffer.allocate(2).order(order).putShort(s).array(); int data = ByteBuffer.wrap(bytes, 0, bytes.length).order(order).getShort(); String转Byte import java.nio.charset.Charset; Charset charset = Charset.forName(\u0026quot;UTF-8\u0026quot;); String data = \u0026quot;abc\u0026quot;; byte[] bytes = data.getBytes(charset); String newData = new String(bytes, 0, bytes.length, charset); ","dateformatted":"16, March 2022","dateiso":"2022-03-16T15:42:33Z","ref":"/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"\n 一：参考 [算法心得] http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogIEEE64Float\n[运算符优先级] https://tool.oschina.net/commons?type=6\n[位运算技巧] https://www.zhihu.com/question/38206659\n[思考题解法] https://www.iteye.com/blog/yacare-1969931\n二：概要 通过本文可以让我们温习下位运算、进制转换，为写出更精良的代码奠定理论基础。现在我们从一个题目说开去：\n问：如何载预计有10亿个int的数据中，剔除其中重复的数据并排序输出?\n分析：首先要进行排序、排重必须得把相关数据加载到内存中，那么要用哪种数据结构来存储呢?\n10 0000 0000 = 10^9\nint[10^9] 需要内存 10^9 * 4(B) =\u0026gt; ((10^9 * 4)/1000 * 1000)(M) =\u0026gt; 4000M =\u0026gt; 4GB\n\n","tags":["java","基础"],"title":"位运算基础知识"},{"content":"1.参考 【alibaba canal】https://github.com/alibaba/canal\n【mysql binlog】https://dev.mysql.com/doc/refman/8.0/en/binary-log.html\n【mysql event】https://dev.mysql.com/doc/internals/en/event-meanings.html\n【mysqlbinlog 命令】https://dev.mysql.com/doc/refman/8.0/en/mysqlbinlog.html\n2.基本简介 canal [kə\u0026rsquo;næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费\n2.1 mysql主备复制实现 master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）； slave将master的binary log events拷贝到它的中继日志(relay log)； slave重做中继日志中的事件，将改变反映它自己的数据。 2.2 mysql binglog 数据包格式 mysql 事件体目前有一下版本\n v1：在 MySQL 3.23 中使用\n+=====================================+ | event | timestamp 0 : 4 | | header +----------------------------+ | | type_code 4 : 1 | | +----------------------------+ | | server_id 5 : 4 | | +----------------------------+ | | event_length 9 : 4 | +=====================================+ | event | fixed part 13 : y | | data +----------------------------+ | | variable part | +=====================================+ 标头长度 = 13 字节 数据长度 = (event_length - 13) 字节 y 特定于事件类型。 v3：在 MySQL 4.0.2 到 4.1 中使用\n+=====================================+ | event | timestamp 0 : 4 | | header +----------------------------+ | | type_code 4 : 1 | | +----------------------------+ | | server_id 5 : 4 | | +----------------------------+ | | event_length 9 : 4 | | +----------------------------+ | | next_position 13 : 4 | | +----------------------------+ | | flags 17 : 2 | +=====================================+ | event | fixed part 19 : y | | data +----------------------------+ | | variable part | +=====================================+ 标头长度 = 19 字节 数据长度 = (event_length - 19) 字节 y 特定于事件类型。 v4：用于 MySQL 5.0 及更高版本\n+=====================================+ | event | timestamp 0 : 4 | | header +----------------------------+ | | type_code 4 : 1 | | +----------------------------+ | | server_id 5 : 4 | | +----------------------------+ | | event_length 9 : 4 | | +----------------------------+ | | next_position 13 : 4 | | +----------------------------+ | | flags 17 : 2 | | +----------------------------+ | | extra_headers 19 : x-19 | +=====================================+ | event | fixed part x : y | | data +----------------------------+ | | variable part | +=====================================+ 标头长度 = x 字节 数据长度 = (event_length - x) 字节 固定数据长度 = y 字节可变数据长度 = (event_length - (x + y)) 字节 2.2 canal工作原理 canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议 mysql master收到dump请求，开始推送binary log给slave(也就是canal) canal解析binary log对象(原始为byte流) 2.3 canal架构 说明：\n server代表一个canal运行实例，对应于一个jvm instance对应于一个数据队列 （1个server对应1..n个instance) instance模块：\n eventParser (数据源接入，模拟slave协议和master进行交互，协议解析)\n eventSink (Parser和Store链接器，进行数据过滤，加工，分发的工作)\n eventStore (数据存储)\n metaManager (增量订阅\u0026amp;消费信息管理器)\n canal-instance instance代表了一个实际运行的数据队列，包括了EventPaser,EventSink,EventStore等组件。\n抽象了CanalInstanceGenerator，主要是考虑配置的管理方式：\n manager方式： 和你自己的内部web console/manager系统进行对接。(目前主要是公司内部使用) spring方式：基于spring xml + properties进行定义，构建spring配置. canal-event-parser 整个parser过程大致可分为几步：\n Connection获取上一次解析成功的位置 (如果第一次启动，则获取初始指定的位置或者是当前数据库的binlog位点) Connection建立链接，发送BINLOG_DUMP指令 // 0. write command number // 1. write 4 bytes bin-log position to start at // 2. write 2 bytes bin-log flags // 3. write 4 bytes server id of the slave // 4. write bin-log file name Mysql开始推送Binaly Log 接收到的Binaly Log的通过Binlog parser进行协议解析，补充一些特定信息 // 补充字段名字，字段类型，主键信息，unsigned类型处理 传递给EventSink模块进行数据存储，是一个阻塞操作，直到存储成功 存储成功后，定时记录Binaly Log位置 canal-event-sink 说明：\n 数据过滤：支持通配符的过滤模式，表名，字段内容等 数据路由/分发：解决1:n (1个parser对应多个store的模式) 数据归并：解决n:1 (多个parser对应1个store) 数据加工：在进入store之前进行额外的处理，比如join 数据1:n业务\n 为了合理的利用数据库资源， 一般常见的业务都是按照schema进行隔离，然后在mysql上层或者dao这一层面上，进行一个数据源路由，屏蔽数据库物理位置对开发的影响，阿里系主要是通过cobar/tddl来解决数据源路由问题。\n 所以，一般一个数据库实例上，会部署多个schema，每个schema会有由1个或者多个业务方关注\n 数据n:1业务\n 同样，当一个业务的数据规模达到一定的量级后，必然会涉及到水平拆分和垂直拆分的问题，针对这些拆分的数据需要处理时，就需要链接多个store进行处理，消费的位点就会变成多份，而且数据消费的进度无法得到尽可能有序的保证。\n 所以，在一定业务场景下，需要将拆分后的增量数据进行归并处理，比如按照时间戳/全局id进行排序归并.\n canal-event-store 目前仅实现了Memory内存模式，后续计划增加本地file存储，mixed混合模式 借鉴了Disruptor的RingBuffer的实现思路 RingBuffer设计：\n定义了3个cursor\n Put : Sink模块进行数据存储的最后一次写入位置 Get : 数据订阅获取的最后一次提取位置 Ack : 数据消费成功的最后一次消费位置 借鉴Disruptor的RingBuffer的实现，将RingBuffer拉直来看： 实现说明：\n Put/Get/Ack cursor用于递增，采用long型存储 buffer的get操作，通过取余或者与操作。(与操作： cusor \u0026amp; (size - 1) , size需要为2的指数，效率比较高) 2.4 canal HA设计 canal的ha分为两部分，canal server和canal client分别有对应的ha实现\n canal server: 为了减少对mysql dump的请求，不同server上的instance要求同一时间只能有一个处于running，其他的处于standby状态. canal client: 为了保证有序性，一份instance同一时间只能由一个canal client进行get/ack/rollback操作，否则客户端接收无法保证有序。 整个HA机制的控制主要是依赖了zookeeper的几个特性，watcher和EPHEMERAL节点(和session生命周期绑定)。\n大致步骤：\n canal server要启动某个canal instance时都先向zookeeper进行一次尝试启动判断 (实现：创建EPHEMERAL节点，谁创建成功就允许谁启动) 创建zookeeper节点成功后，对应的canal server就启动对应的canal instance，没有创建成功的canal instance就会处于standby状态 一旦zookeeper发现canal server A创建的节点消失后，立即通知其他的canal server再次进行步骤1的操作，重新选出一个canal server启动instance. canal client每次进行connect时，会首先向zookeeper询问当前是谁启动了canal instance，然后和其建立链接，一旦链接不可用，会重新尝试connect. Canal Client的方式和canal server方式类似，也是利用zookeeper的抢占EPHEMERAL节点的方式进行控制.\n2.5 canal client client-server交互 get/ack/rollback协议介绍：\n Message getWithoutAck(int batchSize)，允许指定batchSize，一次可以获取多条，每次返回的对象为Message，包含的内容为： a. batch id 唯一标识 b. entries 具体的数据对象，对应的数据对象格式：EntryProtocol.proto void rollback(long batchId)，顾命思议，回滚上次的get请求，重新获取数据。基于get获取的batchId进行提交，避免误操作 void ack(long batchId)，顾命思议，确认已经消费成功，通知server删除数据。基于get获取的batchId进行提交，避免误操作 canal的get/ack/rollback协议和常规的jms协议有所不同，允许get/ack异步处理，比如可以连续调用get多次，后续异步按顺序提交ack/rollback，项目中称之为流式api.\n流式api设计的好处：\n get/ack异步化，减少因ack带来的网络延迟和操作成本 (99%的状态都是处于正常状态，异常的rollback属于个别情况，没必要为个别的case牺牲整个性能) get获取数据后，业务消费存在瓶颈或者需要多进程/多线程消费时，可以不停的轮询get数据，不停的往后发送任务，提高并行化. (作者在实际业务中的一个case：业务数据消费需要跨中美网络，所以一次操作基本在200ms以上，为了减少延迟，所以需要实施并行化) 流式api设计：\n 每次get操作都会在meta中产生一个mark，mark标记会递增，保证运行过程中mark的唯一性 每次的get操作，都会在上一次的mark操作记录的cursor继续往后取，如果mark不存在，则在last ack cursor继续往后取 进行ack时，需要按照mark的顺序进行数序ack，不能跳跃ack. ack会删除当前的mark标记，并将对应的mark位置更新为last ack cusor 一旦出现异常情况，客户端可发起rollback情况，重新置位：删除所有的mark, 清理get请求位置，下次请求会从last ack cursor继续往后取 数据对象格式 Entry Header logfileName [binlog文件名] logfileOffset [binlog position] executeTime [binlog里记录变更发生的时间戳] schemaName [数据库实例] tableName [表名] eventType [insert/update/delete类型] entryType [事务头BEGIN/事务尾END/数据ROWDATA] storeValue [byte数据,可展开，对应的类型为RowChange] RowChange isDdl\t[是否是ddl变更操作，比如create table/drop table] sql\t[具体的ddl sql] rowDatas\t[具体insert/update/delete的变更数据，可为多条，1个binlog event事件可对应多条变更，比如批处理] beforeColumns [Column类型的数组] afterColumns [Column类型的数组] Column index\t[column序号] sqlType\t[jdbc type] name\t[column name] isKey\t[是否为主键] updated\t[是否发生过变更] isNull\t[值是否为null] value\t[具体的内容，注意为文本] 说明：\n 可以提供数据库变更前和变更后的字段内容，针对binlog中没有的name,isKey等信息进行补全 可以提供ddl的变更语句 3.cannel 源码 3.1 canal启动 public void start() { super.start(); if (!embeddedServer.isStart()) { embeddedServer.start(); } //1.创建canal server this.bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool())); bootstrap.setOption(\u0026quot;child.keepAlive\u0026quot;, true); bootstrap.setOption(\u0026quot;child.tcpNoDelay\u0026quot;, true); //2.构造对应的pipeline bootstrap.setPipelineFactory(() -\u0026gt; { ChannelPipeline pipelines = Channels.pipeline(); pipelines.addLast(FixedHeaderFrameDecoder.class.getName(), new FixedHeaderFrameDecoder()); // support to maintain child socket channel. pipelines.addLast(HandshakeInitializationHandler.class.getName(), new HandshakeInitializationHandler(childGroups)); pipelines.addLast(ClientAuthenticationHandler.class.getName(), new ClientAuthenticationHandler(embeddedServer)); //会话处理 SessionHandler sessionHandler = new SessionHandler(embeddedServer); pipelines.addLast(SessionHandler.class.getName(), sessionHandler); return pipelines; }); //3.启动 默认监听1111端口 if (StringUtils.isNotEmpty(ip)) { this.serverChannel = bootstrap.bind(new InetSocketAddress(this.ip, this.port)); } else { this.serverChannel = bootstrap.bind(new InetSocketAddress(this.port)); } } public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception { ChannelBuffer buffer = (ChannelBuffer) e.getMessage(); Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array()); ClientIdentity clientIdentity = null; switch (packet.getType()) { case SUBSCRIPTION: break; case UNSUBSCRIPTION: break; case GET: break; case CLIENTACK: break; case CLIENTROLLBACK: break; default: break; } } 3.2 client代码 3.2.1 订阅数据-socket public static void main(String args[]) { // 创建链接 CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(AddressUtils.getHostIp(),11111), \u0026quot;example\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;\u0026quot;); int batchSize = 1000; try { connector.connect(); connector.subscribe(\u0026quot;.*\\\\..*\u0026quot;); connector.rollback(); while (isRunning) { // 获取指定数量的数据 Message message = connector.getWithoutAck(batchSize); long batchId = message.getId(); int size = message.getEntries().size(); if(size \u0026gt; 0){ printEntry(batchId,message.getEntries()); } // 提交确认 connector.ack(batchId); // 处理失败, 回滚数据 // connector.rollback(batchId); } } finally { connector.disconnect(); } } private static void printEntry(long batchId,List\u0026lt;Entry\u0026gt; entrys) { for (Entry entry : entrys) { if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) { continue; } //数据反序列化 RowChange rowChage = RowChange.parseFrom(entry.getStoreValue()); EventType eventType = rowChage.getEventType(); for (RowData rowData : rowChage.getRowDatasList()) { if (eventType == EventType.DELETE) { printColumn(rowData.getBeforeColumnsList()); } else if (eventType == EventType.INSERT) { printColumn(rowData.getAfterColumnsList()); } else { System.out.println(\u0026quot;-------\u0026amp;gt; before\u0026quot;); printColumn(rowData.getBeforeColumnsList()); System.out.println(\u0026quot;-------\u0026amp;gt; after\u0026quot;); printColumn(rowData.getAfterColumnsList()); } } } } private static void printColumn(List\u0026lt;Column\u0026gt; columns) { for (Column column : columns) { System.out.println(column.getName() + \u0026quot; : \u0026quot; + column.getValue() + \u0026quot; update=\u0026quot; + column.getUpdated()); } } 3.2.2 连接canal server private InetSocketAddress doConnect() throws CanalClientException { try { channel = SocketChannel.open(); channel.socket().setSoTimeout(soTimeout); SocketAddress address = getAddress(); if (address == null) { address = getNextAddress(); } //1.连接 server channel.connect(address); //读channel readableChannel = Channels.newChannel(channel.socket().getInputStream()); //写channel writableChannel = Channels.newChannel(channel.socket().getOutputStream()); //2.握手 Packet p = Packet.parseFrom(readNextPacket()); if (p.getVersion() != 1) { throw new CanalClientException(\u0026quot;unsupported version at this client.\u0026quot;); } if (p.getType() != PacketType.HANDSHAKE) { throw new CanalClientException(\u0026quot;expect handshake but found other type.\u0026quot;); } Handshake handshake = Handshake.parseFrom(p.getBody()); supportedCompressions.add(handshake.getSupportedCompressions()); // ByteString seed = handshake.getSeeds(); // seed for auth String newPasswd = password; if (password != null) { // encode passwd newPasswd = SecurityUtil.byte2HexStr(SecurityUtil.scramble411(password.getBytes(), seed.toByteArray())); } ClientAuth ca = ClientAuth.newBuilder() .setUsername(username != null ? username : \u0026quot;\u0026quot;) .setPassword(ByteString.copyFromUtf8(newPasswd != null ? newPasswd : \u0026quot;\u0026quot;)) .setNetReadTimeout(idleTimeout) .setNetWriteTimeout(idleTimeout) .build(); //3.鉴权客户端 writeWithHeader(Packet.newBuilder() .setType(PacketType.CLIENTAUTHENTICATION) .setBody(ca.toByteString()) .build() .toByteArray()); //4.连接成确认 Packet ack = Packet.parseFrom(readNextPacket()); if (ack.getType() != PacketType.ACK) { throw new CanalClientException(\u0026quot;unexpected packet type when ack is expected\u0026quot;); } Ack ackBody = Ack.parseFrom(ack.getBody()); if (ackBody.getErrorCode() \u0026gt; 0) { throw new CanalClientException(\u0026quot;something goes wrong when doing authentication: \u0026quot; + ackBody.getErrorMessage()); } connected = true; return new InetSocketAddress(channel.socket().getLocalAddress(), channel.socket().getLocalPort()); } catch (IOException | NoSuchAlgorithmException e) { throw new CanalClientException(e); } } ","dateformatted":"16, October 2021","dateiso":"2021-10-16T15:42:33Z","ref":"/canal-mysql-binlog%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90/","summary":"\n 1.参考 【alibaba canal】https://github.com/alibaba/canal\n【mysql binlog】https://dev.mysql.com/doc/refman/8.0/en/binary-log.html\n【mysql event】https://dev.mysql.com/doc/internals/en/event-meanings.html\n【mysqlbinlog 命令】https://dev.mysql.com/doc/refman/8.0/en/mysqlbinlog.html\n2.基本简介 canal [kə\u0026rsquo;næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费\n2.1 mysql主备复制实现 master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）； slave将master的binary log events拷贝到它的中继日志(relay log)； slave重做中继日志中的事件，将改变反映它自己的数据。 2.\n\n","tags":["canal"],"title":"canal-mysql binlog日志解析"},{"content":"1.参考 【环境设置】https://www.liwenzhou.com/posts/Go/install_go_dev_old/\n2.基本简介 3.问题 1）Main file has non-main package or doesn\u0026rsquo;t contain main function 如果为程序入口的main方法文件，则包应为package main,注意与目录无关。\n","dateformatted":"16, October 2021","dateiso":"2021-10-16T15:42:33Z","ref":"/go-36%E8%AE%B2/","summary":"\n 1.参考 【环境设置】https://www.liwenzhou.com/posts/Go/install_go_dev_old/\n2.基本简介 3.问题 1）Main file has non-main package or doesn\u0026rsquo;t contain main function 如果为程序入口的main方法文件，则包应为package main,注意与目录无关。\n\n","tags":["canal"],"title":"GO 36讲"},{"content":"1.maven-wrapper安装使用 安装 在项目中使用命令安装mvn -N io.takari:maven:0.7.7:wrapper，参考官网 ,如果需要指定maven版本则使用mvn -N io.takari:maven:0.7.7:wrapper -Dmaven=3.5.4,安装完成后，目录如下\nmy-project ├── .mvn │ └── wrapper │ ├── MavenWrapperDownloader.java │ ├── maven-wrapper.jar │ └── maven-wrapper.properties ├── mvnw ├── mvnw.cmd ├── pom.xml └── src ├── main │ ├── java │ └── resources └── test ├── java └── resources 使用 参考mvn命令, 指令切换成mvnw如: linux下 ./mvnw clean install windown下 mvnw.cmd clean install ","dateformatted":"16, October 2021","dateiso":"2021-10-16T15:42:33Z","ref":"/maven-wrapper%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","summary":"\n 1.maven-wrapper安装使用 安装 在项目中使用命令安装mvn -N io.takari:maven:0.7.7:wrapper，参考官网 ,如果需要指定maven版本则使用mvn -N io.takari:maven:0.7.7:wrapper -Dmaven=3.5.4,安装完成后，目录如下\nmy-project ├── .mvn │ └── wrapper │ ├── MavenWrapperDownloader.java │ ├── maven-wrapper.\n\n","tags":["maven"],"title":"maven-wrapper基础使用"},{"content":"1.参考 【mysql8.0手册】https://dev.mysql.com/doc/refman/8.0/en/\n【mysql doc】https://dev.mysql.com/doc/\n【alibaba canal】https://github.com/alibaba/canal\n2.概要 通过本文可以了解主从同步原理，快速搭建一个主从环境,实现复制场景，并且利用canal实现订阅binglog日志，实现跨实例同步。\n中间件版本:\nmysql-8.0.27\ncanal 1.1.5\n3.主从同步 创建容错系统的最常见方法就是冗余，复制模式分普通复制、组复制，普通复制即传统的 MySQL复制 提供了一种简单的源(mater)到副本复制方法,。\nmaster-slave syn MySQL 复制功能允许服务器 -主服务器 - 将所有更改发送到另一台服务器 -从服务器 -从服务器尝试应用所有更改以与主服务器保持同步。复制工作如下：\n 每当 master 的数据库被修改时，更改都会写入一个文件，即所谓的二进制日志或binlog。这是由执行修改数据库的查询的客户端线程完成的。\n master 有一个线程，称为dump thread，它不断读取 master 的 binlog 并将其发送给 slave。\n slave有一个线程，称为IO线程，它接收master的dump线程发送的binlog，并将其写入一个文件： relay log，show variables like \u0026lsquo;%relay%'。\n 从服务器有另一个线程，称为 SQL 线程，它不断读取中继日志并将更改应用到从服务器。\n MySQL 复制功能使用三个主线程实现，一个在源服务器上，两个在副本上：\n 二进制日志转储线程。 当副本连接时，源创建一个线程将二进制日志内容发送到副本。该线程可以SHOW PROCESSLIST在源上的输出中标识为Binlog Dump线程。\n二进制日志转储线程获取源二进制日志的锁，用于读取要发送到副本的每个事件。一旦事件被读取，锁就会被释放，甚至在事件被发送到副本之前。\n 复制 I/O 接收器线程。 当START REPLICA在副本服务器上发出一条语句时，副本会创建一个 I/O（接收器）线程，该线程连接到源并要求它发送记录在其二进制日志中的更新。\n复制接收者线程读取源Binlog Dump线程发送的更新（参见上一项）并将它们复制到包含副本中继日志的本地文件。\n该线程的状态显示 Slave_IO_running在 的输出中 SHOW SLAVE STATUS。\n 复制 SQL 应用程序线程。 副本创建一个 SQL（应用程序）线程来读取由复制接收器线程写入的中继日志并执行其中包含的事务。\n 异步复制 半同步复制 组复制 Mysql集群 InnoDB ReplicaSet 不提供 InnoDB Cluster 提供的所有功能，例如自动故障转移或多主模式。但是您可以手动切换或故障转移到辅助实例，例如在发生故障时。您甚至可以采用现有的复制部署，然后将其作为 InnoDB ReplicaSet 进行管理。\nmysql集群主要基于 MySQL Group Replication构建，提供自动成员管理、容错、自动故障转移等功能。\n4.环境准备 4.1.环境目录结构 ├─mysql-8.0.27-winx64 ├─master │ └─data │ └─my.ini ├─slave_1 │ └─data │ └─my.ini └─slave_2 │ └─data │ └─my.ini └─slave_canal │ ├─bin │ ├─conf │ ├─lib │ ├─logs │ │ ├─canal │ │ └─example │ └─plugin 4.2.安装mysql 下载https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.27-winx64.zip\n4.2.1.master 1).配置my.ini [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [mysqld] # 设置3307端口 port = 3307 # 设置mysql的安装目录 basedir=E:/db/mysql_cluster/mysql-8.0.27-winx64 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 datadir=E:/db/mysql_cluster/master/data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB explicit_defaults_for_timestamp=true log-error=E:/db/mysql_cluster/master/error.log pid-file=E:/db/mysql_cluster/master/mysql.pid socket =E:/db/mysql_cluster/master/mysql.socket # master配置 server-id = 1 log_bin = E:/db/mysql_cluster/master/bin.log max_binlog_size = 20M slow_query_log = 1 #(可选配置）要同步的数据库名，要同步多个数据库，就多加几个replicate-db-db=数据库名 binlog-do-db=test #（可选配置）要忽略的数据库 binlog-ignore-db=mysql binlog-ignore-db=sys binlog-ignore-db=information_schema binlog-ignore-db=performance_schema 2).安装mysql 1.创建配置文件 2.cmd初始化 \u0026gt;\u0026gt;E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysqld --defaults-file=E:/db/mysql_cluster/master/my.ini --initialize --basedir=E:/db/mysql_cluster/mysql-8.0.27-winx64 --datadir=E:/db/mysql_cluster/master/data 3.cmd运行 \u0026gt;\u0026gt;E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysqld --defaults-file=E:/db/mysql_cluster/master/my.ini 4.修改密码 查看 mster/error.log 临时密码，连接mysql修改root密码 \u0026gt;\u0026gt;E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysql -h localhost -P 3307 -u root -p \u0026gt;\u0026gt;use mysql; \u0026gt;\u0026gt;alter user 'root'@'localhost' identified with mysql_native_password by '123456'; \u0026gt;\u0026gt;flush privileges; \u0026gt;\u0026gt;exit; 3).配置slave用户 创建slaveuser，允许从slave节点连接复制binlog。\n授予所有权限GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' \nmysql\u0026gt;CREATE USER slaveuser@'%' IDENTIFIED WITH mysql_native_password BY '123456'; mysql\u0026gt;grant replication slave on *.* to slaveuser@'%'; mysql\u0026gt;GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slaveuser'@'%'; mysql\u0026gt;flush privileges; mysql\u0026gt;show grants for slaveuser@'%'; 4).查看master状态 mysql\u0026gt; show master status； 4.2.2.slave 参考 https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html slave配置参数\n1).配置my.ini [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [mysqld] # 设置 3308 端口 port = 3308 # 设置mysql的安装目录 basedir=E:/db/mysql_cluster/mysql-8.0.27-winx64 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 datadir=E:/db/mysql_cluster/slave_1/data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB explicit_defaults_for_timestamp=true log-error=E:/db/mysql_cluster/slave_1/error.log pid-file=E:/db/mysql_cluster/slave_1/mysql.pid socket =E:/db/mysql_cluster/slave_1/mysql.socket # master配置 log_bin = E:/db/mysql_cluster/slave_1/bin.log server-id = 2 read_only = 1 max_binlog_size = 20M slow_query_log = 1 #(可选配置）要同步的数据库名，要同步多个数据库，就多加几个replicate-db-db=数据库名 binlog-do-db=test #（可选配置）要忽略的数据库 binlog-ignore-db=mysql binlog-ignore-db=sys binlog-ignore-db=information_schema binlog-ignore-db=performance_schema 2）.安装mysql 参考maseter\n3).配置slave 参考 master【查看master状态】\n# 配置连接master信息 mysql\u0026gt; CHANGE MASTER TO MASTER_HOST='127.0.0.1', master_port = 3307,MASTER_USER='slaveuser', MASTER_PASSWORD='123456', MASTER_LOG_FILE='bin.000001', MASTER_LOG_POS=1673,master_connect_retry = 15,master_retry_count = 0; mysql\u0026gt; start slave; mysql\u0026gt; show slave status; # 删除slave配置信息 # stop slave; # reset slave all; 创建只读用户，防止用root操作同步库\nCREATE USER 'readuser'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; GRANT SELECT ON *.* TO 'readuser'@'%'; FLUSH PRIVILEGES; 4).查看master状态 mysql\u0026gt; show master status； 4.3 测试 在master执行一下语句，查看slave库是否同步。\nCREATE DATABASE IF NOT EXISTS test DEFAULT CHARSET utf8 COLLATE utf8_general_ci;` create table t_data ( id bigint(20) not null auto_increment comment '主键', name varchar(32) comment '名称', create_time datetime default CURRENT_TIMESTAMP comment '创建时间', update_time datetime default CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP comment '更新时间', primary key (id) ) ENGINE=InnoDB COMMENT='测试表'; insert into t_data(name) values(1); 5.开启GTID 全局事务标识符 (GTID) 是在源服务器（源）上创建并与提交的每个事务相关联的唯一标识符。此标识符不仅对于它起源的服务器是唯一的，而且对于给定复制拓扑中的所有服务器也是唯一的。\n从MySQL5.6开始增加了强大的GTID（Global Transaction ID，全局事务ID）这个特性，用来强化数据库的主备一致性， 故障恢复， 以及容错能力。用于取代过去传统的主从复制（即：基于binlog和position的异步复制）。\n借助GTID，在发生主备切换的情况下，MySQL的其他slave可以自动在新主上找到正确的复制位置，这大大简化了复杂复制拓扑下集群的维护，也减少了人为设置复制position发生误操作的风险。另外，基于GTID的复制可以忽略已经执行过的事务，减少了数据发生不一致的风险。\n参考：https://dev.mysql.com/doc/refman/8.0/en/replication-mode-change-online-enable-gtids.html\n1.修改master、slave 节点my.conf or my.ini # GTID gtid_mode=ON enforce_gtid_consistency=ON 2.设置salve节点 mysql\u0026gt; E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysql -h localhost -P 3308 -u root -p mysql\u0026gt; STOP SLAVE ; mysql\u0026gt; CHANGE MASTER TO MASTER_HOST='127.0.0.1', master_port = 3307,MASTER_USER='slaveuser', MASTER_PASSWORD='123456',MASTER_AUTO_POSITION = 1; mysql\u0026gt; START SLAVE ; Or from MySQL 8.0.22 / 8.0.23: STOP REPLICA ; CHANGE REPLICATION SOURCE TO MASTER_HOST='127.0.0.1', master_port = 3307,MASTER_USER='slaveuser', MASTER_PASSWORD='123456',SOURCE_AUTO_POSITION = 1; START REPLICA ; 3.查看状态 show slave status \\G; show variables like 'gtid_%'; 6.canal slave 6.1下载 canal https://github.com/alibaba/canal/releases\n6.2 配置 1）确认mysql配置 [mysqld] log-bin=mysql-bin #添加这一行就ok binlog-format=ROW #选择row模式 mysql\u0026gt; show variables like 'binlog_format'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | binlog_format | ROW | +---------------+-------+ mysql\u0026gt; show variables like 'log_bin'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | log_bin | ON | +---------------+-------+ 2）解压到目录./slave_canal 3) 修改配置 slave_canal/conf/example/instance.properties # 基础配置 canal.port = 11111 #端口 canal.serverMode = tcp # canal client的模式: tcp kafka rocketMQ # 配置destinations canal.destinations = instance_1 # 指定实例 canal.conf.dir = ../conf # 实例配置目录 canal.auto.scan = true # 自动扫描实列目录,实现实列动态加载、移除 canal.auto.scan.interval = 5 canal.auto.reset.latest.pos.mode = false canal.instance.tsdb.spring.xml = classpath:spring/tsdb/h2-tsdb.xml canal.instance.global.mode = spring canal.instance.global.lazy = false canal.instance.global.manager.address = ${canal.admin.manager} canal.instance.global.spring.xml = classpath:spring/file-instance.xml 4) 修改配置 slave_canal/conf/instance_1/instance.properties canal.instance.master.address=127.0.0.1:3307 #指向mysql master配置 canal.instance.dbUsername=slaveuser # 拥有主从复制、连接权限的用户 canal.instance.dbPassword=123456 # 对应dbUsername的密码 5) 启动 slave_canal、bin/startup.bat slave_canal/logs/canal/canal.log slave_canal/logs/instance_1/instance_1.log 5.1 canal客户端测试 see https://github.com/alibaba/canal.git\n运行 com.alibaba.otter.canal.example.BaseCanalClientTest.main 在master节点执行 insert,可以看到bingnlog消息\n在master节点执行 update,可以看到bingnlog消息\n7.问题 7.1.Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event\u0026rsquo;s master log FIRST, end_log_pos 429, Error_code: MY-001032 在从库删除数据后，出现主从同步问题 1)stop slave; 2)找出被删除的记录，重新插入从库 E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysqlbinlog --no-defaults --base64-output=decode-rows -v bin.000001 \u0026gt;bin.sql or E:/db/mysql_cluster/mysql-8.0.27-winx64/bin/mysqlbinlog --no-defaults --base64-output=DECODE-ROWS -v bin.000001 3)start slave; 7.2.client does not support authentication protocol requested by server consider upgrading mysql client 创建用户时指定mysql_native_password ， mysql8之后,加密规则是caching_sha2_password。\nCREATE USER slaveuser@'%' IDENTIFIED WITH mysql_native_password BY '123456';\n7.3.Access denied; you need (at least one of) the SUPER, REPLICATION CLIENT privilege(s) 为用户增加 REPLICATION CLIENT 权限\nGRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO '用户名'@'%';\n8.备查命令 8.1.查看从节点数量 show slave hosts; select * from information_schema.processlist as p where p.command = 'Binlog Dump'; 8.2.查看版本 select version();\nSELECT * FROM information_schema.plugins; SELECT @@innodb_version;\n8.2.mysqlbinlog 查看binlog信息 mysqlbinlog -v --base64-output=DECODE-ROWS ./bin.000001\n查看binglog文件 SHOW BINARY LOGS\n9.数据参考: 1.机器信息DB型(内存(12*32G)384G硬盘2*480G(s4500)SSD+8*960G(s4500)SSD)\nshow variables like '%binlog%'; 1\tbinlog_cache_size\t1048576 2\tbinlog_checksum\tNONE 3\tbinlog_direct_non_transactional_updates\tOFF 4\tbinlog_error_action\tABORT_SERVER 5\tbinlog_format\tROW 6\tbinlog_group_commit_sync_delay\t0 7\tbinlog_group_commit_sync_no_delay_count\t0 8\tbinlog_gtid_simple_recovery\tON 9\tbinlog_max_flush_queue_time\t0 10\tbinlog_order_commits\tON 11\tbinlog_row_image\tFULL 12\tbinlog_rows_query_log_events\tOFF 13\tbinlog_skip_flush_commands\tOFF 14\tbinlog_space_limit\t0 15\tbinlog_stmt_cache_size\t32768 16\tbinlog_transaction_dependency_history_size\t25000 17\tbinlog_transaction_dependency_tracking\tCOMMIT_ORDER 18\tencrypt_binlog\tOFF 19\thave_backup_safe_binlog_info\tYES 20\tinnodb_api_enable_binlog\tOFF 21\tinnodb_locks_unsafe_for_binlog\tOFF 22\tlog_statements_unsafe_for_binlog\tON 23\tmax_binlog_cache_size\t18446744073709547520 24\tmax_binlog_files\t0 25\tmax_binlog_size\t1073741824 26\tmax_binlog_stmt_cache_size\t18446744073709547520 27\tsync_binlog\t1 show variables like '%relay%'; 1\tmax_relay_log_size\t0 2\trelay_log\trelay-bin 3\trelay_log_basename\t/data/mysql_3306/relay-bin 4\trelay_log_index\t/data/mysql_3306/relay-bin.index 5\trelay_log_info_file\trelay-log.info 6\trelay_log_info_repository\tTABLE 7\trelay_log_purge\tON 8\trelay_log_recovery\tON 9\trelay_log_space_limit\t0 10\tsync_relay_log\t10000 11\tsync_relay_log_info\t10000 ","dateformatted":"16, October 2021","dateiso":"2021-10-16T15:42:33Z","ref":"/mysql-master-slave/","summary":"\n 1.参考 【mysql8.0手册】https://dev.mysql.com/doc/refman/8.0/en/\n【mysql doc】https://dev.mysql.com/doc/\n【alibaba canal】https://github.com/alibaba/canal\n2.概要 通过本文可以了解主从同步原理，快速搭建一个主从环境,实现复制场景，并且利用canal实现订阅binglog日志，实现跨实例同步。\n中间件版本:\nmysql-8.0.27\ncanal 1.1.5\n3.主从同步 创建容错系统的最常见方法就是冗余，复制模式分普通复制、组复制，普通复制即传统的 MySQL复制 提供了一种简单的源(mater)到副本复制方法,。\nmaster-slave syn MySQL 复制功能允许服务器 -主服务器 - 将所有更改发送到另一台服务器 -从服务器 -从服务器尝试应用所有更改以与主服务器保持同步。复制工作如下：\n\n","tags":["mysql"],"title":"mysql master-slave"},{"content":"","dateformatted":"16, October 2021","dateiso":"2021-10-16T15:42:33Z","ref":"/sonarqube%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","summary":"\n \n\n","tags":["工具"],"title":"sonarqube基础使用"},{"content":"1.概述 Yarn是您的代码的包管理器，yarn和npm的对比\n 速度\nnpm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。\n 安装版本统一\n 更简洁的输出\n 参考：\nhttps://classic.yarnpkg.com yarn官网\n2.基础配置 使用安装包安装\nhttps://github.com/yarnpkg/yarn/releases 下载路径\n使用npm安装\nnpm install --g yarn \nwindow下 配置文件路径 C:\\Users\\Administrator\\.yarnrc\n2.1.修改缓存路径 #修改yarn 缓存位置 yarn config set cache-folder \u0026ldquo;你的磁盘路径\u0026rdquo; #这里是我的路径 yarn config set cache-folder \u0026ldquo;D:\\Software\\yarn\\cache\u0026rdquo;\n2.2.修改包源 yarn config set registry https://registry.npm.taobao.org/\n2.3.yarn 全局安装位置 yarn config set global-folder \u0026quot;D:\\yarnData\\global\u0026quot;\n2.4.改变yarn bin位置 yarn config set prefix D:\\yarnData\\global\\bin\n3.yarn版本号 yarn的包遵守 semver，即语义化版本。 SemVer 是一套语义化版本控制的约定，定义的格式为 X.Y.Z（主版本号.次版本号.修订号）： X.主版本号：进行不向下兼容的修改时，递增主版本号 Y.次版本号: 做了向下兼容的新增功能或修改 Z.修订号：做了向下兼容的问题修复 yarn 中依赖版本范围的表示方法有以下几种： 1. 通过比较器 表示\t含义描述 \u0026lt;2.0.0\t任何小于 2.0.0 的版本 \u0026lt;=3.1.4\t任何小于或等于 3.1.4 的版本 \u0026gt;0.4.2\t任何大于 0.4.2 的版本 \u0026gt;=2.7.1\t任何大于或等于 2.7.1 的版本 =4.6.6\t任何等于 4.6.6 的版本 \u0026gt;=2.0.0 \u0026lt;3.1.4\t交集，大于或等于 2.0.0 并小于 3.1.4 \u0026lt;2.0.0 || \u0026gt;3.1.4\t并集 小于 2.0.0 或者大于 3.1.4 如果没有指定运算符，默认为 = 2. 通过连字符 表示\t含义描述 2.0.0 - 3.1.4\t\u0026gt;=2.0.0 \u0026lt;=3.1.4 0.4 - 2\t\u0026gt;=0.4.0 \u0026lt;=2.0.0 版本号中缺少的那些部分会用数字 0 填充。 3. X范围 字符 X、x 或者 * 都可以作为通配符，用于填充部分或全部版本号。 被省略的那部分版本号默认为 x 范围。 表示\t含义描述 *\t\u0026gt;=0.0.0 (任意版本) 2.x\t\u0026gt;=2.0.0 \u0026lt;3.0.0（匹配主要版本） 3.1.x\t\u0026gt; = 3.1.0 \u0026lt; 3.2.0（匹配主要和次要版本） ``（空字符串）\t* 或 \u0026gt; = 0.0.0 2\t2.x.x 或 \u0026gt; = 2.0.0 \u0026lt; 3.0.0 3.1\t3.1.x 或 \u0026gt; = 3.1.0 \u0026lt; 3.2.0 4. ～ 字符范围 同时使用字符 ~ 和次版本号，表明允许 修订号 变更。同时使用字符 ~ 和主版本号，表明允许 次版本 号变更。 表示\t含义描述 ~3.1.4\t\u0026gt;=3.1.4 \u0026lt;3.2.0 ~3.1\t3.1.x 或 \u0026gt; = 3.1.0 \u0026lt; 3.2.0 ~3\t3.x 或 \u0026gt; = 3.0.0 \u0026lt; 4.0.0 5. ^ 字符范围 字符 ^ 表明不会修改版本号中的第一个非零数字，3.1.4 里的 3 或者 0.4.2 里的 4。版本号中缺少的部分将被 0 填充，且在匹配时这些位置允许改变。 表示\t含义描述 ^3.1.4\t\u0026gt;=3.1.4 \u0026lt;4.0.0 ^0.4.2\t\u0026gt;=0.4.2 \u0026lt;0.5.0 ^0.0.2\t\u0026gt;=0.0.2 \u0026lt;0.0.3 使用 yarn add [package-name] 命令安装依赖，默认使用的是 ^ 范围。 需要注意的是，如果一个比较器包含有预发布标签的版本，它将只匹配有相同 major.minor.patch 的版本。 例如 \u0026gt;=3.1.4-beta.2，可以匹配 3.1.4-beta.3，但不会匹配 3.1.5-beta.3 版本。 3.yarn依赖类型 dependences 代码运行时所需要的依赖，比如vue，vue-router。 devDependences 开发依赖，就是那些只在开发过程中需要，而运行时不需要的依赖，比如babel，webpack。 peerDependences 同伴依赖，它用来告知宿主环境需要什么依赖以及依赖的版本范围。如果宿主环境没有对应版本的依赖，在安装依赖时会报出警告。比如包 eslint-plugin-import 中有依赖： \u0026quot;peerDependencies\u0026quot;: { \u0026quot;eslint\u0026quot;: \u0026quot;2.x - 5.x\u0026quot; }, optionalDependencies 可选依赖，这种依赖即便安装失败，Yarn也会认为整个依赖安装过程是成功的。可选依赖适用于那些即便没有成功安装可选依赖，也有后备方案的情况。 bundledDependencies 打包依赖，在发布包时，这个数组里的包都会被打包打包到最终的发布包里，需要注意 bundledDependencies 中的包必须是在devDependencies或dependencies声明过的。 4.yarn 包缓存 yarn 会将安装过的包缓存下来，这样再次安装相同包的时候，就不需要再去下载，而是直接从缓存文件中直接copy进来。\n可以通过命令 yarn cache dir 查看yarn的全局缓存目录。我的缓存目录在 /Library/Caches/Yarn/v1 下。\n可以看出，yarn 会将不通版本解压后的包存放在不同目录下，目录以\nnpm-[package name]-[version]-[shasum]`\n来命名。shasum 即上文中 registry 获取的 dist.shasum。\n我们可以通过命令查看已经缓存过的包。\nyarn cache list 列出已缓存的每个包\nyarn cache list \u0026ndash;pattern 列出匹配指定模式的已缓存的包\n例如执行 yarn cache list \u0026ndash;pattern vue\n5.yarn install过程 首次执行 yarn install 安装，会按照 package.json 中的语义化版本，去向 registry 进行查询，并获取到符合版本规则的最新的依赖包进行下载，并构建构建依赖关系树。 比如在 package.json 中指定 vue 的版本为 ^2.0.0，就会获取符合 2.x.x 的最高版本的包。然后自动生成 yarn.lock 文件，并生成缓存。\n之后再执行 yarn install，会对比 package.json 中依赖版本范围和 yarn.lock 中版本号是否匹配。\n 版本号匹配，会根据 yarn.lock 中的 resolved 字段去查看缓存， 如果有缓存，直接copy，没有缓存则按照 resolved 字段的url去下载包。 版本号不匹配，根据 package.json 中的版本范围去 registry 查询，下载符合版本规则最新的包，并更新至 yarn.lock 中。 6.yarn.lock yarn.lock 中会准确的存储每个依赖的具体版本信息，以保证在不同机器安装可以得到相同的结果。 下面以@babel/code-frame为例，看看yarn.lock 中会记录哪些信息。 1. 第一行 \u0026quot;@babel/code-frame@7.0.0-beta.54\u0026quot; 包的name和语义化版本号，这些都来自package.json中的定义。 2. version 字段，记录的是一个确切的版本。 3. resolved 字段记录的是包的URL地址。其中hash值，即上文的 dist.shasum。 4. dependencies 字段记录的是当前包的依赖，即当前包在 package.json 的 dependencies 字段中的所有依赖。 Yarn 在安装期间，只会使用当前项目的 yarn.lock 文件（即 顶级 yarn.lock 文件），会忽略任何依赖里面的 yarn.lock 文件。在顶级 yarn.lock 中包含需要锁定的整个依赖树里全部包版本的所有信息。 yarn.lock文件是在安装期间，由 Yarn 自动生成的，并且由yarn来管理，不应该手动去更改，更不应该删除yarn.lock文件，且要提交到版本控制系统中，以免因为不同机器安装的包版本不一致引发问题。 7.模块扁平化 上面提到，在安装依赖时，会解析依赖构建出依赖关系树。 比如我项目的首层依赖(即当前项目的dependence和devDependences中的依赖，不包括依赖的依赖)中有A，B，C三个包，A 和 B包同时依赖了相同版本范围的D包。那么这部分的依赖关系树是这样的： ├── A │ └── D ├── B │ └── D ├── C 如果按照这样的依赖关系树直接安装的话，D模块会在A包和B包的 node_modules中都安装，这样会导致模块冗余。 为了保证依赖关系树中没有大量重复模块，yarn在安装时会做dedupe（去重）操作，它会遍历所有节点，逐个将模块放在根节点下面，也就是当前项目的 node-modules 中。当发现有相同的模块时，会判断当前模块指定的 semver 版本范围是否交集，如果有，则只保留兼容版本，如果没有则在当前的包的 node-modules 下安装。 所以上面的说的情况，最终安装完成是下面这样的，A，B，C，D包都会安装在第一层 node-modules 下。 ├── A ├── B ├── C ├── D 如果A包和B包依赖的是不兼容的版本，假设A包依赖的是D@1版本的包，B包依赖的是D@2版本。则最终安装的结果如下： ├── A ├── B │ └── D@2 ├── C ├── D@1 当代码中 require 或 import 某个模块时，会从当前 package 的 node-modules 里中开始找，找不到就到当前package的上一层 node-modules 里找，这样一直找到全局的node_modules。 所以上面的安装的树结构，可以保证每个 package 都能获取到所需要版本的包。 8.基本命令 1.查看配置 yarn --version yarn global bin 查看bin路径 yarn global dir 查看安装路径 2.显示当前依赖 yarn list 列出所有依赖 yarn list --depth=0 列出所有依赖,并指定深度 yarn list --pattern gulp yarn list --pattern \u0026quot;gulp|grunt\u0026quot; yarn list --pattern \u0026quot;gulp|grunt\u0026quot; --depth=1 3.查看配置 yarn config get init-license 获取配置 yarn config delete test-key 删除配置 yarn config list 显示当前配置 yarn config set init-license BSD-2-Clause 设置配置 查看当前使用的镜像源 yarn config get registry 修改镜像源（以修改成淘宝源为例） yarn config set registry https://registry.npm.taobao.org/ 4.基础使用 新项目初始化 yarn init 添加依赖关系 yarn add [package] yarn add [package]@[version] yarn add [package]@[tag] 将依赖关系添加到不同类别的依赖项 添加到devDependencies，peerDependencies和optionalDependencies分别为： yarn add [package] --dev yarn add [package] --peer yarn add [package] --optional 升级依赖项 yarn upgrade [package] yarn upgrade [package]@[version] yarn upgrade [package]@[tag] 删除依赖项 yarn remove [package] 安装项目的所有依赖项 yarn 或 yarn install 执行package.json文件中定义scripts yarn run build/test -o --watch 5.项目文件 package.json：这包含您的包的所有当前依赖项。 yarn.lock：这存储了包的每个依赖项的确切版本。 6.其他命令 yarn versions 查看所有包的版本信息 7. yarn install 安装依赖 yarn install / yarn 在本地 node_modules 目录安装 package.json 里列出的所有依赖 yarn install --force 重新拉取所有包，即使之前已经安装的（所以以后别在删除node-modules了...） yarn install --modules-folder \u0026lt;path\u0026gt; 为 node_modules 目录指定另一位置，代替默认的 ./node_modules yarn install --no-lockfile 不读取或生成 yarn.lock 文件 yarn install --production[=true|false] / --production / --prod 只安装 dependence下的包，不安装 devDependencies 的包 8. yarn add yarn add package-name 会安装 latest 最新版本。 yarn add \u0026lt;package...\u0026gt; 安装包到dependencies中 yarn add \u0026lt;package...\u0026gt; [--dev/-D] 用 --dev 或 -D 安装包到 devDependencies yarn add \u0026lt;package...\u0026gt; [--peer/-P] 用 --peer 或者 -P 安装包到 peerDependencies yarn add \u0026lt;package...\u0026gt; [--optional/-O] 用 --optional 或者 -O 安装包到 optionalDependencies yarn add \u0026lt;package...\u0026gt; [--exact/-E] 用 --exact 或者 -E 会安装包的精确版本。默认是安装包的主要版本里的最新版本。 比如说， yarn add foo@1.2.3 会接受 1.9.1 版，但是 yarn add foo@1.2.3 --exact 只会接受 1.2.3 版。 yarn add \u0026lt;package...\u0026gt; [--tilde/-T] 用 --tilde 或者 -T 来安装包的次要版本里的最新版。 默认是安装包的主要版本里的最新版本。 比如说，yarn add foo@1.2.3 --tilde 会接受 1.2.9，但不接受 1.3.0。 9. 其他常用命令 yarn list 查询当前工作文件夹所有的依赖 yarn info \u0026lt;package\u0026gt; [\u0026lt;field\u0026gt;] 查看包信息，可以查看特定 yarn remove \u0026lt;package...\u0026gt; 从依赖里移除名包，同时更新你 package.json 和 yarn.lock 文件。 yarn \u0026lt;script\u0026gt; [\u0026lt;args\u0026gt;] 执行用户自定义的脚本 10. 详细日志模式 运行yarn命令时，增加参数 --verbose，这对排查错误时很有帮助 yarn \u0026lt;command\u0026gt; --verbose 9.问题 yarn The platform \u0026ldquo;win32\u0026rdquo; is incompatible with this module yarn config set ignore-engines true\n","dateformatted":"27, May 2021","dateiso":"2021-05-27T09:46:19+08:00","ref":"/yarn%E7%9B%B8%E5%85%B3/","summary":"\n 1.概述 Yarn是您的代码的包管理器，yarn和npm的对比\n 速度\nnpm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。\n 安装版本统一\n 更简洁的输出\n 参考：\n\n","tags":["yarn"],"title":"Yarn相关"},{"content":"相关链接 https://github.com/golang 源码 https://golang.org/ref/mod 官方文档 https://golang.org/doc/code.html#Workspaces http://www.flysnow.org/categories/Golang/ go专栏 https://golanglibs.com/top 流行的GO应用和GO库 https://gitee.com/pengzhile/ide-eval-resetterv GoLand试用更新插件 一：读书笔记 Limbo语言被认为是Go语言的前身,Limbo语言中继承了众多优秀的特性。包括肯·汤普逊在内的Plan 9项目原班人马加入了Google。在Google，他们创造了Go语言，Google是Go语言的主推。\n学习书籍\n《GO并发编程实战 第2版》《Go****语言核心编程》《Go语言高级编程》《Go Web编程》\n初识GO语言 1.Go语言最主要的特性  自动垃圾回收  更丰富的内置类型  函数多返回值  错误处理  匿名函数和闭包  类型和接口  并发编程  反射  语言交互性 Go语言的main()函数不能带参数，也不能定义返回值。命令行传入的参数在os.Args变量中保存。如果需要支持命令行开关，可使用flag包。 Go程序的代码注释与C++保持一致： /* 块注释 */ // 行注释 不得包含在源代码文件中没有用到的包，否则Go编译器会报编译错误。 强制左花括号{的放置位置,如果把左花括号{另起一行放置，这样做的结果是Go编译器报告编译错。 Go程序并不要求开发者在每个语句后面加上分号表示语句结束。 一个常规的函数定义包含以下部分： func 函数名(参数列表)(返回值列表) { // 函数体 } 2.编译程序 Go命令行工具只是一个源代码管理工具，或者说是一个前端。真正的Go编译器和链接器被Go命令行工具隐藏在后面，我们可以直接使用它们： $ 6g helloworld.go $ 6l helloworld.6 $ ./6.out Hello, world. 你好，世界！ 6g和6l是64位版本的Go编译器和链接器，对应的32位版本工具为8g和8l。Go还有另外一个 GCC版本的编译器，名为 gccgo。 构建 GOPATH和PATH环境变量一样，也可以接受多个路径，并且路径和路径之间用冒号分割 go build calc gdb calc go test simplemath 3.开发工具  文本编辑工具gedit（Linux）/Notepad++（Windows）/Fraise（Mac OS X）；  安装了GoClipse插件的Eclipse，集成性做得很好；  Vim/Emacs，万能开发工具；  LiteIDE，一款专为Go语言开发的集成开发环境  goland 非免费  VScode\n顺序编程 1. 变量申明 var v1 int var v2 string var v3 [10]int // 数组 var v4 []int // 数组切片 var v5 struct { f int } var v6 *int // 指针 var v7 map[string]int // map，key为string类型，value为int类型 var v8 func(a int) int var ( v1 int v2 string ) 变量声明语句不需要使用分号作为结束符。 2. 变量初始化 var v1 int = 10 // 正确的使用方式1 var v2 = 10 // 正确的使用方式2，编译器可以自动推导出v2的类型 v3 := 10 // 正确的使用方式3，编译器可以自动推导出v3的类型 出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误 func GetName() (firstName, lastName, nickName string) { return \u0026quot;May\u0026quot;, \u0026quot;Chan\u0026quot;, \u0026quot;Chibi Maruko\u0026quot; } 若只想获得nickName，则函数调用语句可以用如下方式编写： _, _, nickName := GetName() 这种用法可以让代码非常清晰 二.基本命令 Go Module gomod 包源码和链接库保存在 $GOPATH/pkg/mod 目录下。\n go list -u -m all 查看所有依赖 go mod tidy 移除不需要的依赖 go mod edit -fmt 格式化go.mod文件 go mod edit --require=rsc.io/quote@v3.1.0 更新 rsc.io/quote 到 v3.1.0 版 GO安装 1. MSI installer(https://golang.org/dl/) Open the MSI file and follow the prompts to install the Go tools. By default, the installer puts the Go distribution in c:\\Go. The installer should put the c:\\Go\\bin directory in your PATH environment variable. You may need to restart any open command prompts for the change to take effect. Setting environment variables under Windows Under Windows, you may set environment variables through the \u0026quot;Environment Variables\u0026quot; button on the \u0026quot;Advanced\u0026quot; tab of the \u0026quot;System\u0026quot; control panel. Some versions of Windows provide this control panel through the \u0026quot;Advanced System Settings\u0026quot; option inside the \u0026quot;System\u0026quot; control panel. 2. linux下安装 tar -C /usr/local -xzf go.tar.gz Add /usr/local/go/bin to the PATH environment variable. You can do this by adding this line to your /etc/profile(for a system-wide installation) or $HOME/.profile: export PATH=$PATH:/usr/local/go/bin 3. 自定义安装 The Go binary distributions assume they will be installed in /usr/local/go (or c:\\Go under Windows), but it is possible to install the Go tools to a different location. In this case you must set the GOROOT environment variable to point to the directory in which it was installed. For example, if you installed Go to your home directory you should add commands like the following to $HOME/.profile: export GOROOT=$HOME/go1.X export PATH=$PATH:$GOROOT/bin 4. 测试安装情况 Check that Go is installed correctly by setting up a workspace and building a simple program, as follows. Create your workspace directory, %USERPROFILE%\\go. (If you'd like to use a different directory, you will need to set the GOPATH environment variable; see How to Write Go Code for details.) Next, make the directory src/hello inside your workspace, and in that directory create a file named hello.go that looks like: package main import \u0026quot;fmt\u0026quot; func main() { fmt.Printf(\u0026quot;hello, world\\n\u0026quot;) } Then build it with the go tool: C:\\\u0026gt; cd %USERPROFILE%\\go\\src\\hello C:\\Users\\Gopher\\go\\src\\hello\u0026gt; go build The command above will build an executable named hello.exe in the directory alongside your source code. Execute it to see the greeting: C:\\Users\\Gopher\\go\\src\\hello\u0026gt; hello hello, world If you see the \u0026quot;hello, world\u0026quot; message then your Go installation is working. You can run go install to install the binary into your workspace's bin directory or go clean to remove it. Before rushing off to write Go code please read the How to Write Go Code document, which describes some essential concepts about using the Go tools. 5. 删除go 直接删除go的安装目录. /usr/local/go under Linux, Mac OS X, and FreeBSD c:\\Go under Windows. 删除环境变量配置 Under Linux and FreeBSD you should edit /etc/profile or $HOME/.profile. Mac OS X you should remove the /etc/paths.d/go file. Windows users should read the section about setting environment variables under Windows. GOPATH 与GOROOT GOROOT 指定Go的二进制编译包安装路径，假设你把Go安装在 /usr/local/go (或者Window是 c:\\Go)目录下。当然你也可以安装在其他目录下，不过这时候你就需要设置GOROOT环境变量了。 http://golang.org/doc/install#install 例如，你如果安装Go在你的/usr/local/go目录下，你应该$HOME/.profile文件增加下面设置。 export GOROOT=/usr/local/go export GOPATH=$PATH:$GOROOT/bin 执行：source .bash_profile (即时生效) GOPATH GOPATH的作用是告诉Go命令和其他相关工具，在哪里去找到安装在你系统上的Go包。 GOPATH是一个路径的列表，一个典型的GOPATH设置如下，类似PATH的设置，Win下用分号分割： GOPATH=/home/user/ext:/home/user/mygo 每一个列表中的路径是一个工作区的位置。每个工作区都有源文件、相关包的对象、执行文件。http://golang.org/doc/code.html 下面是一个建立工作区的步骤： 创建 $HOME/mygo 目录和作为源代码的 src 目录。 $ mkdir -p $HOME/mygo/src # create a place to put source code 下一步就是设置 GOPATH，另外你应该把 这个目录下的bin目录放在 PATH 环境变量，这样你就可以直接在命令行执行而不用给出完整目录。 export GOPATH=$HOME/mygo export PATH=$PATH:$HOME/mygo/bin GOPATH 必须设置编译和安装包，即使用标准的Go目录树，类似如下： GOPATH=/home/user/gocode /home/user/gocode/ src/ foo/ bar/ (go code in package bar) x.go quux/ (go code in package main) y.go bin/ quux (installed command) pkg/ linux_amd64/ foo/ bar.a (installed package object) 三.问题 1.go: github.com/BurntSushi/toml@v0.3.1: Get \u0026ldquo;https://proxy.golang.org/github.com/%21burnt%21sushi/toml/@v/v0.3.1.mod\u0026quot;: dial tcp 172.217.160.81:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. 设置国内代理地址go env -w GOPROXY=https://goproxy.cn\n","dateformatted":"25, May 2021","dateiso":"2021-05-25T09:34:28+08:00","ref":"/go%E5%AD%A6%E4%B9%A0/","summary":"\n 相关链接 https://github.com/golang 源码 https://golang.org/ref/mod 官方文档 https://golang.org/doc/code.html#Workspaces http://www.flysnow.org/categories/Golang/ go专栏 https://golanglibs.com/top 流行的GO应用和GO库 https://gitee.com/pengzhile/ide-eval-resetterv GoLand试用更新插件 一：读书笔记 Limbo语言被认为是Go语言的前身,Limbo语言中继承了众多优秀的特性。包括肯·汤普逊在内的Plan 9项目原班人马加入了Google。在Google，他们创造了Go语言，Google是Go语言的主推。\n学习书籍\n《GO并发编程实战 第2版》《Go****语言核心编程》《Go语言高级编程》《Go Web编程》\n初识GO语言 1.\n\n","tags":["GO"],"title":"GO学习"},{"content":"概要： 了解hugo基本使用，通过hugo搭建个人blog\n参考 【hugo 】https://gohugo.io/\n【函数】https://gohugo.io/functions/\n【变量】https://gohugo.io/variables/\n【github集成】https://github.com/peaceiris/actions-gh-pages\n【参考例子】https://github.com/henriksommerfeld/blog-hugo\n【hugo theme】https://themes.gohugo.io/hugo-clarity/\n1.hugo结构说明 # 站点结构 ├── archetypes # 原型 ├── config.toml # 站点配置 ├── content # 站点内容目录 ├── data # 数据模板 ├── layouts # 站点布局模板 ├── static # 静态内容 └── themes # 内容目录 content └── post ├── first-post │ ├── images │ │ ├── a.jpg │ │ ├── b.jpg │ │ └── c.jpg │ ├── index.md (root of page bundle) │ ├── latest.html │ ├── manual.json │ ├── notice.md │ ├── office.mp3 │ ├── pocket.mp4 │ ├── rating.pdf │ └── safety.txt └── second-post └── index.md (root of page bundle # 文章描述 categories = [\u0026#34;目录1\u0026#34;, \u0026#34;目录2\u0026#34;] date = \u0026#34;日期+时间\u0026#34; description = \u0026#34;描述\u0026#34; slug = \u0026#34;spf13-vim-3-0-release-and-new-website\u0026#34; tags = [\u0026#34;标签1\u0026#34;, \u0026#34;标签2\u0026#34;] title = \u0026#34;标题\u0026#34; 2.基本使用 # window版本下载`https://github.com/gohugoio/hugo/releases/download/v0.83.1/hugo_extended_0.83.1_Windows-64bit.zip` # 配置环境变量 path /hugo_path/ # 创建站点 hugo new site quickstart cd quickstart # 添加主题/展示模板 git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo theme = \\\u0026#34;ananke\\\u0026#34; \u0026gt;\u0026gt; config.toml # 新建文章 hugo new posts/my-first-post.md # 发布预览 hugo server -D #默认输出静态文件到./public目录下，或者使用参数指定public目录路径(-d/--destination flag to change it, or set publishdir in the config file). 访问 http://localhost:1313 # 发布静态文件到github 上传public下的文件到 `https://github.com/username/username.github.io` 访问 `https://username.github.io` 集成github pages [源] hugo repository:qiaomingzi/limz-blog-hugo\n[目标] gitpages repository: qiaomingzi/qiaomingzi.github.io\n[1]生成密钥key\nssh-keygen -t rsa -b 4096 -C \u0026quot;github邮箱\u0026quot; -f gh-pages -N \u0026quot;\u0026quot; [2]配置limz-blog-hugo/setting/Deploy keys新增公钥 key:刚才生成的公钥(gh-pages.pub)\n[3]配置qiaomingzi.github.io/setting/Secrets新增密钥 name:ACTIONS_DEPLOY_KEY value:刚才生成的密钥(gh-pages)\n[4]创建文件limz-blog-hugo/.github/workflows/gh-pages.yml\nname: github pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 - name: Setup Node uses: actions/setup-node@v2.1.2 with: node-version: '12.x' - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.83.1' - name: Cache dependencies uses: actions/cache@v2 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- - run: npm run install:prod - run: npm run build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} # github_token: ${{ secrets.GITHUB_TOKEN }} external_repository: qiaomingzi/qiaomingzi.github.io publish_branch: master # default: gh-pages publish_dir: ./public [5]limz-blog-hugo/Actions查看或触发发布\ngit push 触发发布，可以在github上查看发布结果\n3.hugo命令 hugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at https://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: check Contains some verification checks config Print the site configuration convert Convert your content to different formats env Print Hugo version and environment info gen A collection of several useful generators. help Help about any command import Import your site from others. list Listing out various types of content new Create new content for your site server A high performance webserver version Print the version number of Hugo Flags: -b, --baseURL string hostname (and path) to the root, e.g. https://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/ --cleanDestinationDir remove files from destination not found in static directories --config string config file (default is path/config.yaml|json|toml) --configDir string config dir (default \u0026quot;config\u0026quot;) -c, --contentDir string filesystem path to content directory --debug debug output -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date and author info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo --i18n-warnings print missing translations --ignoreCache ignores the cache directory -l, --layoutDir string filesystem path to layout directory --log enable Logging --logFile string log File path (if set, logging enabled automatically) --minify minify any supported output format (HTML, XML etc.) --noChmod don't sync permission mode of files --noTimes don't sync modification time of files --path-warnings print warnings on duplicate target paths etc. --quiet build in quiet mode --renderToMemory render to memory (only useful for benchmark testing) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMetrics -t, --theme strings themes to use (located in /themes/THEMENAME/) --themesDir string filesystem path to themes directory --trace file write trace to file (not useful in general) -v, --verbose verbose output --verboseLog verbose logging -w, --watch watch filesystem for changes and recreate as needed Use \u0026quot;hugo [command] --help\u0026quot; for more information about a command. 4.问题 1.ERROR 2021/05/08 14:30:50 TOCSS: failed to transform \u0026ldquo;styles/print-bundle.scss\u0026rdquo; (text/x-scss). Check your Hugo installation; you need the extended version to build SCSS/SASS. 确认下载的hugo版本呢是hugo_extend版本 而不是标准版本\n2.Hugo - Failed to find a valid digest in the \u0026lsquo;integrity\u0026rsquo; attribute for resource I replaced:\nintegrity=\u0026ldquo;J6YEe5hjKuk/TENUR7jEMr6VNR4lwN8iVpSGj1g8MU4=\u0026rdquo;\nwith:\nintegrity=\u0026quot;\u0026quot;\nin the css tag of every single index.html file.\nThis worked, although I found a solution to do this automatically and skip the error in the first place.\nSolution(!) - Update: It looks like the head.html file under the assets folder has the following structure:\n{{- $stylesheet := (resources.Match \u0026quot;css/*.css\u0026quot;) | resources.Concat \u0026quot;assets/css/stylesheet.css\u0026quot; | minify | fingerprint -}} \u0026lt;link href=\u0026quot;{{ $stylesheet.Permalink }}\u0026quot; integrity=\u0026quot;{{ $stylesheet.Data.Integrity }}\u0026quot; rel=\u0026quot;preload stylesheet\u0026quot; as=\u0026quot;style\u0026quot;\u0026gt; blog-hugo blog-hugo\\layouts\\partials\\head.html\nhugo-clarity hugo-clarity\\layouts\\partials\\math.html themes\\hugo-clarity\\layouts_default\\baseof.html\n","dateformatted":"7, May 2021","dateiso":"2021-05-07T17:03:36+08:00","ref":"/hugo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"\n 概要： 了解hugo基本使用，通过hugo搭建个人blog\n参考 【hugo 】https://gohugo.io/\n【函数】https://gohugo.io/functions/\n【变量】https://gohugo.io/variables/\n【github集成】https://github.com/peaceiris/actions-gh-pages\n【参考例子】https://github.com/henriksommerfeld/blog-hugo\n【hugo theme】https://themes.gohugo.io/hugo-clarity/\n1.hugo结构说明 # 站点结构 ├── archetypes # 原型 ├── config.toml # 站点配置 ├── content # 站点内容目录 ├── data # 数据模板 ├── layouts # 站点布局模板 ├── static # 静态内容 └── themes # 内容目录 content └── post ├── first-post │ ├── images │ │ ├── a.\n\n","tags":null,"title":"Hugo基本使用"},{"content":"目录 跳过目录\n 本文目标 如何使用本教程 正则表达式到底是什么东西？ 入门 测试正则表达式 元字符 字符转义 重复 字符类 分枝条件 反义 分组 后向引用 零宽断言 负向零宽断言 注释 贪婪与懒惰 处理选项 平衡组/递归匹配 还有些什么东西没提到 联系作者 网上的资源及本文参考文献 更新纪录 本文目标 30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。\n如何使用本教程 最重要的是——请给我30分钟，如果你没有使用正则表达式的经验，请不要试图在30秒内入门——除非你是超人 :)\n别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有你想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。\n除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？\n清除格式 文本格式约定：专业术语 元字符/语法格式 正则表达式 正则表达式中的一部分(用于分析) 对其进行匹配的源字符串 对正则表达式或其中一部分的说明\n隐藏边注 本文右边有一些注释，主要是用来提供一些相关信息，或者给没有程序员背景的读者解释一些基本概念，通常可以忽略。\n正则表达式到底是什么东西？ 字符是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。字符串是0个或更多个字符的序列。文本也就是文字，字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。\n在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n很可能你使用过Windows/Dos下用于文件查找的通配符(wildcard)，也就是和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像010-12345678或0376-7654321)。\n入门 学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。\n假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。\n这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。\n不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\\bhi\\b。\n\\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。\n如果需要更精确的说法，\\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\\w。\n假如你要找的是hi后面不远处跟着一个Lucy，你应该用\\bhi\\b.*\\bLucy\\b。\n这里，.是另一个元字符，匹配除了换行符以外的任意字符。同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.连在一起就意味着任意数量的不包含换行的字符。现在\\bhi\\b.\\bLucy\\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。\n换行符就是'\\n',ASCII编码为10(十六进制0x0A)的字符。\n如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：\n0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。\n这里的\\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。\n为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\\d{2}-\\d{8}。 这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)。\n测试正则表达式 其它可用的测试工具:\n RegexBuddy Javascript正则表达式在线测试工具 如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。\n不同的环境下正则表达式的一些细节是不相同的，本教程介绍的是微软 .Net Framework 4.0 下正则表达式的行为，所以，我向你推荐我编写的.Net下的工具 正则表达式测试器。请参考该页面的说明来安装和运行该软件。\n下面是Regex Tester运行时的截图：\n元字符 现在你已经知道几个很有用的元字符了，如\\b,.,*，还有\\d.正则表达式里还有更多的元字符，比如\\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\\w匹配字母或数字或下划线或汉字等。\n对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。\n下面来看看更多的例子：\n\\ba\\w*\\b匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w*)，最后是单词结束处(\\b)。\n好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)\n\\d+匹配1个或更多连续的数字。这里的+是和类似的元字符，不同的是匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。\n\\b\\w{6}\\b 匹配刚好6个字符的单词。\n 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。\n元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$。\n这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。\n因为使用了^和$，所以输入的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。\n和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。\n字符转义 如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用.和*。当然，要查找\\本身，你也得用\\.\n例如：unibetter.com匹配unibetter.com，C:\\Windows匹配C:\\Windows。\n重复 你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：\n 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 下面是一些使用重复的例子：\nWindows\\d+匹配Windows后面跟1个或更多数字\n^\\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)\n字符类 要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？\n很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。\n我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。\n下面是一个更复杂的表达式：(?0\\d{2}[) -]?\\d{8}。\n“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。\n这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。\n分枝条件 不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：\n0\\d{2}-\\d{8}|0\\d{3}-\\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。\n(0\\d{2})[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\n\\d{5}-\\d{4}|\\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。\n分组 我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。\n(\\d{1,3}.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。\nIP地址中每个数字都不能大于255，大家千万不要被《24》第三季的编剧给忽悠了……\n不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。\n理解这个表达式的关键是理解2[0-4]\\d|25[0-5]|[01]?\\d\\d?，这里我就不细说了，你自己应该能分析得出来它的意义。\n反义 有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：\n 代码/语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 例子：\\S+匹配不包含空白符的字符串。\n\u0026lt;a[^\u0026gt;]+\u0026gt;匹配用尖括号括起来的以a开头的字符串。\n后向引用 使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。\n呃……其实,组号分配还不像我刚说得那么简单：\n 分组0对应整个正则表达式 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权． 后向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。难以理解？请看示例：\n\\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。\n你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\\w+)(或者把尖括号换成\u0026rsquo;也行：(?\u0026lsquo;Word\u0026rsquo;\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k,所以上一个例子也可以写成这样：\\b(?\\w+)\\b\\s+\\k\\b。\n使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：\n 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?\u0026lsquo;name\u0026rsquo;exp) (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 (?\u0026lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?\u0026lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？\n零宽断言 地球人，是不是觉得这些术语名称太复杂，太难记了？我也有同感。知道有这么一种东西就行了，它叫什么，随它去吧！人若无名，便可专心练剑；物若无名，便可随意取舍……\n接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：\n断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。\n(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I\u0026rsquo;m singing while you\u0026rsquo;re dancing.时，它会匹配sing和danc。\n(?\u0026lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?\u0026lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。\n假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?\u0026lt;=\\d)\\d{3})+\\b，用它对1234567890进行查找时结果是234567890。\n下面这个例子同时使用了这两种断言：(?\u0026lt;=\\s)\\d+(?=\\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。\n负向零宽断言 前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词\u0026ndash;它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：\n\\b\\wq[^u]\\w\\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w*\\b将会匹配下一个单词，于是\\b\\w*q[^u]\\w*\\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不**消费**任何字符。现在，我们可以这样来解决这个问题：\\b\\w*q(?!u)\\w*\\b。\n零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。\n同理，我们可以用(?\u0026lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?\u0026lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字。\n请详细分析表达式(?\u0026lt;=\u0026lt;(\\w+)\u0026gt;).*(?=\u0026lt;/\\1\u0026gt;)，这个表达式最能表现零宽断言的真正用途。\n一个更复杂的例子：(?\u0026lt;=\u0026lt;(\\w+)\u0026gt;).(?=\u0026lt;/\\1\u0026gt;)匹配不包含属性的简单HTML标签内里的内容。(?\u0026lt;=\u0026lt;(\\w+)\u0026gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是)，然后是.(任意的字符串),最后是一个后缀(?=\u0026lt;/\\1\u0026gt;)。注意后缀里的/，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的(\\w+)匹配的内容，这样如果前缀实际上是的话，后缀就是了。整个表达式匹配的是和之间的内容(再次提醒，不包括前缀和后缀本身)。\n注释 小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|250-5|[01]?\\d\\d?(?#0-199)。\n要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：\n (?\u0026lt;= # 断言要匹配的文本的前缀 \u0026lt;(\\w+)\u0026gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签) ) # 前缀结束 .* # 匹配任意文本 (?= # 断言要匹配的文本的后缀 \u0026lt;\\/\\1\u0026gt; # 查找尖括号括起来的内容：前面是一个\u0026quot;/\u0026quot;，后面是先前捕获的标签 ) # 后缀结束 贪婪与懒惰 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。\n有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：\na.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。\n为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。\n 代码/语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 处理选项 在C#中，你可以使用Regex(String, RegexOptions)构造函数来设置正则表达式的处理选项。如：Regex regex = new Regex(@\u0026quot;\\ba\\w{6}\\b\u0026quot;, RegexOptions.IgnoreCase);\n上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：\n 名称 说明 IgnoreCase(忽略大小写) 匹配时不区分大小写。 Multiline(多行模式) 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\\n之前的位置以及字符串结束前的位置.) Singleline(单行模式) 更改.的含义，使它与每一个字符匹配（包括换行符\\n）。 IgnorePatternWhitespace(忽略空白) 忽略表达式中的非转义空白并启用由#标记的注释。 ExplicitCapture(显式捕获) 仅捕获已被显式命名的组。 一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。\n平衡组/递归匹配 这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。\n有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用(.+)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？\n为了避免(和(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx \u0026lt;aa aa\u0026gt; yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？\n这里需要用到以下的语法构造：\n (?\u0026lsquo;group\u0026rsquo;) 把捕获的内容命名为group,并压入堆栈(Stack) (?'-group\u0026rsquo;) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败 (?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分 (?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败 如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个\u0026quot;group\u0026quot;，第二个就是从黑板上擦掉一个\u0026quot;group\u0026quot;，第三个就是看黑板上写的还有没有\u0026quot;group\u0026quot;，如果有就继续匹配yes部分，否则就匹配no部分。\n我们需要做的是每碰到了左括号，就在压入一个\u0026quot;Open\u0026quot;,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。\n\u0026lt; #最外层的左括号 [^\u0026lt;\u0026gt;]* #最外层的左括号后面的不是括号的内容 ( ( (?'Open'\u0026lt;) #碰到了左括号，在黑板上写一个\u0026quot;Open\u0026quot; [^\u0026lt;\u0026gt;]* #匹配左括号后面的不是括号的内容 )+ ( (?'-Open'\u0026gt;) #碰到了右括号，擦掉一个\u0026quot;Open\u0026quot; [^\u0026lt;\u0026gt;]* #匹配右括号后面不是括号的内容 )+ )* (?(Open)(?!)) #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的\u0026quot;Open\u0026quot;；如果还有，则匹配失败 \u0026gt; #最外层的右括号 平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的标签：\u0026lt;div[^\u0026gt;]\u0026gt;[^\u0026lt;\u0026gt;](((?\u0026lsquo;Open\u0026rsquo;\u0026lt;div[^\u0026gt;]\u0026gt;)[^\u0026lt;\u0026gt;])+((?'-Open')[^\u0026lt;\u0026gt;])+)(?(Open)(?!)).\n还有些什么东西没提到 上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们\u0026ndash;当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.net下正则表达式详细的文档。\n这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看关于正则表达式语言元素的MSDN在线文档。\n 代码/语法 说明 \\a 报警字符(打印它的效果是电脑嘀一声) \\b 通常是单词分界位置，但如果在字符类里使用代表退格 \\t 制表符，Tab \\r 回车 \\v 竖向制表符 \\f 换页符 \\n 换行符 \\e Escape \\0nn ASCII代码中八进制代码为nn的字符 \\xnn ASCII代码中十六进制代码为nn的字符 \\unnnn Unicode代码中十六进制代码为nnnn的字符 \\cN ASCII控制字符。比如\\cC代表Ctrl+C \\A 字符串开头(类似^，但不受处理多行选项的影响) \\Z 字符串结尾或行尾(不受处理多行选项的影响) \\z 字符串结尾(类似$，但不受处理多行选项的影响) \\G 当前搜索的开头 \\p{name} Unicode中命名为name的字符类，例如\\p{IsGreek} (?\u0026gt;exp) 贪婪子表达式 (?-exp) 平衡组 (?im-nsx:exp) 在子表达式exp中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 (?(exp)yes|no) 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no (?(exp)yes) 同上，只是使用空表达式作为no (?(name)yes|no) 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no (?(name)yes) 同上，只是使用空表达式作为no 网上的资源及本文参考文献\n 微软的正则表达式教程 System.Text.RegularExpressions.Regex类(MSDN) 专业的正则表达式教学网站(英文) 关于.Net下的平衡组的详细讨论（英文） Mastering Regular Expressions (Second Edition) ","dateformatted":"28, September 2017","dateiso":"2017-09-28T15:42:33Z","ref":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F30%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","summary":"\n 目录 跳过目录\n 本文目标 如何使用本教程 正则表达式到底是什么东西？ 入门 测试正则表达式 元字符 字符转义 重复 字符类 分枝条件 反义 分组 后向引用 零宽断言 负向零宽断言 注释 贪婪与懒惰 处理选项 平衡组/递归匹配 还有些什么东西没提到 联系作者 网上的资源及本文参考文献 更新纪录 本文目标 30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。\n\n","tags":["软文收集"],"title":"正则表达式30分钟入门教程"},{"content":"图片嵌入 使用URL链接的形式插入图片：\n![image][url_to_image]1 这样做一个明显的麻烦之处在于处理图片与Markdown文档的一致性上。如果我们要拷贝文档，或者图片遭到误删/云端链接失效，就会变得不便。最让我们省心的方法便是将图片直接放到文档内部。\n一个将图片嵌入文档中的方法是使用base64编码。步骤比较简单：\n 将图片或截图保存在本地； 使用在线工具将图片转码至base64编码；(link1, link2)； 在文档中插入编码： ![image][data:image/png;base64, ......]1 当然base64编码一般很长，直接将编码放入段落内部会影响正常编辑。通常的做法是将base64编码定义到一个中间变量中，将编码本体放到文档末：\n![image][tmp] your document here ... [tmp]:data:image/png;base64, ......1234 使用该技巧的时候需要注意，并不是所有的Markdown编辑器都支持这种方法。而且一些Markdown编辑器只支持特定的图片格式。如有道云笔记只支持png格式的图片编码。需要在保存图片文件的时候加以注意。\n","dateformatted":"21, September 2017","dateiso":"2017-09-21T15:42:33Z","ref":"/markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"\n 图片嵌入 使用URL链接的形式插入图片：\n![image][url_to_image]1 这样做一个明显的麻烦之处在于处理图片与Markdown文档的一致性上。如果我们要拷贝文档，或者图片遭到误删/云端链接失效，就会变得不便。最让我们省心的方法便是将图片直接放到文档内部。\n一个将图片嵌入文档中的方法是使用base64编码。步骤比较简单：\n 将图片或截图保存在本地； 使用在线工具将图片转码至base64编码；(link1, link2)； 在文档中插入编码： ![image][data:image/png;base64, ......]1 当然base64编码一般很长，直接将编码放入段落内部会影响正常编辑。通常的做法是将base64编码定义到一个中间变量中，将编码本体放到文档末：\n![image][tmp] your document here ... [tmp]:data:image/png;base64, .\n\n","tags":null,"title":"Markdown基本使用"},{"content":"开源监控软件对比 Cacti**（英文含义仙人掌）** 是一套基于PHP、MySQL、SNMP和RRDtool开发的网络流量监测图形分析工具，它通过snmpget来获取数据使用RRDtool绘图，简化RRDtool使用。提供了非常强大的数据和用户管理功能，可以指定每一个用户能查看树状结构、主机设备以及任何一张图，还可以与LDAP结合进行用户认证，同时也能自定义模板。在历史数据展示监控方面，其功能相当不错。\nCacti通过添加模板，使不同设备的监控添加具有可复用性，并且具备可自定义绘图的功能，具有强大的运算能力（数据的叠加功能）\n nagios Nagios是一款开源的免费网络监视工具，能有效监控Windows、Linux和Unix的主机状态，交换机路由器等网络设置，打印机等。\nNagios 可以监控的功能有： 1、监控网络服务（SMTP、POP3、HTTP、NNTP、PING等）； 2、监控主机资源（处理器负荷、磁盘利用率等）； 3、简单地插件设计使得用户可以方便地扩展自己服务的检测方法； 4、并行服务检查机制； 5、具备定义网络分层结构的能力，用\u0026quot;parent\u0026quot;主机定义来表达网络主机间的关系，这种关系可被用来发现和明晰主机宕机或不可达状态； 6、当服务或主机问题产生与解决时将告警发送给联系人（通过EMail、短信、用户定义方式）； 7、具备定义事件句柄功能，它可以在主机或服务的事件发生时获取更多问题定位； 8、自动的日志回滚； 9、可以支持并实现对主机的冗余监控； 10、可选的WEB界面用于查看当前的网络状态、通知和故障历史、日志文件等；\n Ganglia 是一个跨平台的、可扩展的、高性能的分布式监控系统，如集群和网格。它基于分层设计，使用广泛的技术，用RRDtool存储数据。具有可视化界面，适合对集群系统的自动化监控。其精心设计的数据结构和算法使得监控端到被监控端的连接开销非常低。目前已经有成千上万的集群正在使用这个监控系统，可以轻松的处理2000个节点的集群环境。\nGanglia的强大在于：ganglia服务端能够通过一台客户端收集到同一个网段的所有客户端的数据，ganglia集群服务端能够通过一台服务端收集到它下属的所有客户端数据。\n Zabbix 是一个基于web界面的分布式监控系统，支持多种采集方式采集客户端，有专用的Agent代理，也支持SNMP、IPMI、JMX、Telnet、SSH等多种协议，它将采集到的数据存放到数据库，然后对其进行分析整理，达到条件触发告警。其灵活的扩展性和丰富的功能是其他监控系统所不能比的。\n\n结论：\n从以上各种监控系统的对比来看，Zabbix都是具有优势的，其丰富的功能、可扩展的能力、二次开发的能力和简单易用的特点，读者只要稍加学习，即可构建自己的监控系统。\nZabbix 选择zabbix的理由： - 安装与配置简单，学习成本低 - 支持多语言（包括中文） - 免费开源\n- 数据采集到数据库，可二次分析监控数据的。 - 自动发现服务器与网络设备 - 分布式监视以及WEB集中管理功能 - 可以无agent监视 - 用户安全认证和柔软的授权方式 - 通过WEB界面设置或查看监视结果 - email等通知功能 等等\n组成： zabbix server：可以通过SNMP、zabbixagent、ping、端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux, Solaris, HP-UX, AIX, Free BSD, Open BSD, OS X等平台之上。\nzabbix agent（可选组件）：安装在被监视的目标服务器上，它主要完成对硬件信息或与操作系统有关的内存，CPU等信息的收集。\n生命周期 \n目前推荐使用Zabbix2.2\n安装 准备： epel源、mysql已安装(yum install mysql-server)、zabbix官方仓库（http://repo.zabbix.com/）\n 安装epel源 # wget –O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo\n安装Zabbix官方源码： #rpm -ivh http://repo.zabbix.com/zabbix/2.2/rhel/6/x86_64/zabbix-release-2.2-1.el6.noarch.rpm\n安装zabbix server： \\3. 安装依赖包yum install -y OpenIPMI\n \\4. yum install -y zabbix-server zabbix-server-mysql\n\n创建数据库 \nmysql\u0026gt; create database zabbix; mysql\u0026gt; grant all on zabbix.* to zabbix@localhost identified by \u0026quot;zabbix_pass\u0026quot;; # mysql -uzabbix -pzabbix_pass -hlocalhost zabbix # 测试 # rpm -ql zabbix-server-mysql 导入server端数据表（注意顺序）： # mysql -uzabbix -pzabbix_pass -hlocalhost zabbix \u0026lt;/usr/share/doc/zabbix-server-mysql-2.2.11/create/schema.sql \u0026lt;--导入数据结构 #mysql -uzabbix -pzabbix_pass -hlocalhost zabbix \u0026lt;/usr/share/doc/zabbix-server-mysql-2.2.11/create/images.sql \u0026lt;--导入图片 # mysql -uzabbix -pzabbix_pass -hlocalhost zabbix \u0026lt;/usr/share/doc/zabbix-server-mysql-2.2.11/create/data.sql \u0026lt;--导入数据 \n修改配置文件 # vim /etc/zabbix/zabbix_server.conf \u0026lt;\u0026ndash;增加zabbix使用数据库的密码 [root@zabbix-server ~]# egrep -v \u0026ldquo;^#|^$\u0026rdquo; /etc/zabbix/zabbix_server.conf\nLogFile=/var/log/zabbix/zabbix_server.log\nLogFileSize=0\nPidFile=/var/run/zabbix/zabbix_server.pid\nDBHost=localhost\nDBName=zabbix\nDBUser=zabbix\nDBPassword=zabbix_pass ** \u0026lt;\u0026ndash;需修改同数据库设置**\nDBSocket=/tmp/mysql.sock\nSNMPTrapperFile=/var/log/snmptt/snmptt.log\nAlertScriptsPath=/usr/lib/zabbix/alertscripts\nExternalScripts=/usr/lib/zabbix/externalscripts\n启动zabbix server： #service zabbix-server start\n# netstat -ntlpu|grep 10051 ß检查启动状态\n# chkconfig zabbix-server on ß添加开机启动\nserver端安装zabbix web： \\1. # yum install zabbix-web zabbix-web-mysql\n\n默认安装了httpd服务，启动httpd\n# chkconfig httpd on ß添加开机启动\n\\2. 访问http://ip/zabbix进入安装\n\n==\u0026gt;解决：修改时区 # vim /etc/httpd/conf.d/zabbix.conf\n\n 登录默认用户admin 密码：zabbix\n 修改字体\n vim /usr/share/zabbix/include/locales.inc.php\nyum -y install wqy-microhei-fonts ß安装中文字体集\nrm -f /etc/alternatives/zabbix-web-font #删除原有字体连接文件\nln -s /usr/share/fonts/wqy-microhei/wqy-microhei.ttc /etc/alternatives/zabbix-web-font\n安装agent 客户端和服务端都安装\n\\1. # yum install -y zabbix-agent\n\n# vim /etc/zabbix/zabbix_agentd.conf //修改被动模式IP为zabbix server ip\n\n注：（一个Agent是可以同时向多个服务器端发送数据，多个Ip用逗号隔开）\nServer：被动模式，允许哪台服务器连接Agent。\nServerActive：主动模式，向哪台服务器传送数据。\n# /etc/init.d/zabbix-agent start //启动agent\n# netstat -lntp |grep 10050 //验证端口\n如果提示不能正常运行，分别检查zabbix_server.conf中的各项配置文件、Selinux、Iptables等。配置文件请检查以下文件的正确配置参数。\n1./etc/zabbix/zabbix_server.conf中的参数。\n# DBHost=localhost ß数据库的IP(域名)地址\nDBName=zabbix ß数据库的名称\nDBUser=zabbix ß数据库的用户\nDBPassword=zabbix ß数据库的密码\n2./etc/zabbix/web/zabbix.conf.php中的配置。\n[root@linux-node1 ~]# cat /etc/zabbix/web/zabbix.conf.php\n监控流程 \nZabbix-Get使用 Zabbix-Get是Zabbix中的一个程序，用于Zabbix-Server到Zabbix-Agent的数据获取，通常可以用来检测验证Agent的配置是否正确。\n用法：zabbix_get [-hV] -s [-p ] [-I ] -k -s：远程Zabbix-Agent的IP地址或者是主机名。\n-p：远程Zabbix-Agent的端口。\n-l：本机出去的IP地址，用于一台机器中又多个网卡的情况。\n-k：获取远程Zabbix-Agent数据所使用的Key。\n实现监控cpu（zabbix server主机上操作） # yum install -y zabbix-get //安装zabbix-get工具\n# zabbix_get -s 192.168.3.113 -k system.cpu.util[,user]\n\nAgent数据采集方式：passive、active\nOther Agent：SNMP、IPMI、Java Gateway\n","dateformatted":"18, September 2017","dateiso":"2017-09-18T15:42:33Z","ref":"/%E5%BC%80%E6%BA%90%E7%9B%91%E6%8E%A7%E8%BD%AF%E4%BB%B6%E5%AF%B9%E6%AF%94_zabbix/","summary":"\n 开源监控软件对比 Cacti**（英文含义仙人掌）** 是一套基于PHP、MySQL、SNMP和RRDtool开发的网络流量监测图形分析工具，它通过snmpget来获取数据使用RRDtool绘图，简化RRDtool使用。提供了非常强大的数据和用户管理功能，可以指定每一个用户能查看树状结构、主机设备以及任何一张图，还可以与LDAP结合进行用户认证，同时也能自定义模板。在历史数据展示监控方面，其功能相当不错。\nCacti通过添加模板，使不同设备的监控添加具有可复用性，并且具备可自定义绘图的功能，具有强大的运算能力（数据的叠加功能）\n nagios Nagios是一款开源的免费网络监视工具，能有效监控Windows、Linux和Unix的主机状态，交换机路由器等网络设置，打印机等。\nNagios 可以监控的功能有： 1、监控网络服务（SMTP、POP3、HTTP、NNTP、PING等）； 2、监控主机资源（处理器负荷、磁盘利用率等）； 3、简单地插件设计使得用户可以方便地扩展自己服务的检测方法； 4、并行服务检查机制； 5、具备定义网络分层结构的能力，用\u0026quot;parent\u0026quot;主机定义来表达网络主机间的关系，这种关系可被用来发现和明晰主机宕机或不可达状态； 6、当服务或主机问题产生与解决时将告警发送给联系人（通过EMail、短信、用户定义方式）； 7、具备定义事件句柄功能，它可以在主机或服务的事件发生时获取更多问题定位； 8、自动的日志回滚； 9、可以支持并实现对主机的冗余监控； 10、可选的WEB界面用于查看当前的网络状态、通知和故障历史、日志文件等；\n\n","tags":["软文收集","zabbix"],"title":"开源监控软件对比_zabbix"},{"content":"博客工具\n概述 Hugo Hexo Jekyll 博客工具\nHexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n安装hexo 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：\n Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。\n Mac 用户\n您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -\u0026gt; Download -\u0026gt; Command Line Tools -\u0026gt; Install 安装命令行工具。\n 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Windows 用户\n由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。\n 安装 Node.js 安装 Node.js 的最佳方式是使用 nvm。\ncURL:\n$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget:\n$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。\n$ nvm install stable 或者您也可以下载 安装程序 来安装。\n Windows 用户\n对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。 另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。\n 安装 Hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n$ npm install -g hexo-cli 变量 全局变量 变量\t描述 site\t网站变量 page\t针对该页面的内容以及 front-matter 所设定的变量。 config\t网站配置 theme\t主题配置。继承自网站配置。 _ (单下划线)\tLodash 函数库 path\t当前页面的路径（不含根路径） url\t当前页面的完整网址 env\t环境变量\n网站变量 变量\t描述 site.posts\t所有文章 site.pages\t所有分页 site.categories\t所有分类 site.tags\t所有标签\n页面变量 页面（page）\n变量\t描述 page.title\t页面标题 page.date\t页面建立日期（Moment.js 对象） page.updated\t页面更新日期（Moment.js 对象） page.comments\t留言是否开启 page.layout\t布局名称 page.content\t页面的完整内容 page.excerpt\t页面摘要 page.more\t除了页面摘要的其余内容 page.source\t页面原始路径 page.full_source\t页面的完整原始路径 page.path\t页面网址（不含根路径）。我们通常在主题中使用 url_for(page.path)。 page.permalink\t页面的完整网址 page.prev\t上一个页面。如果此为第一个页面则为 null。 page.next\t下一个页面。如果此为最后一个页面则为 null。 page.raw\t文章的原始内容 page.photos\t文章的照片（用于相簿） page.link\t文章的外部链接（用于链接文章）\n文章 (post): 和 page 布局类似，但是添加了下列变量。\n变量\t描述 page.published\t如果该文章已发布则为True page.categories\t该文章的所有分类 page.tags\t该文章的所有标签\n首页（index）\n变量\t描述 page.per_page\t每页显示的文章数量 page.total\t总文章数 page.current\t目前页数 page.current_url\t目前分页的网址 page.posts\t本页文章 page.prev\t上一页的页数。如果此页是第一页的话则为 0。 page.prev_link\t上一页的网址。如果此页是第一页的话则为 \u0026lsquo;'。 page.next\t下一页的页数。如果此页是最后一页的话则为 0。 page.next_link\t下一页的网址。如果此页是最后一页的话则为 \u0026lsquo;'。 page.path\t当前页面的路径（不含根目录）。我们通常在主题中使用 url_for(page.path)。\n归档 (archive)：与 index 布局相同，但新增以下变量。\n变量\t描述 page.archive\t等于 true page.year\t年份归档 (4位) page.month\t月份归档 (没有前导零的2位数)\n分类 (category)：与 index 布局相同，但新增以下变量。\n变量\t描述 page.category\t分类名称 标签 (tag)：与 index 布局相同，但新增以下变量。\n变量\t描述 page.tag\t标签名称\n新建页面 （以添加关于页为例）： hexo new page about 编辑生成的 about/index.md 文件，设置布局为 page: title: about layout: page\n插件使用 hexo-asset-image Give asset image in hexo a absolutely path automatically\n安装\nnpm install hexo-asset-image \u0026ndash;save\n例子\nMacGesture2-Publish ├── apppicker.jpg ├── logo.jpg └── rules.jpg MacGesture2-Publish.md\nMake sure post_asset_folder: true in your _config.yml.\n利用markdown标签\nJust use ![logo](logo.jpg) to insert logo.jpg.\n利用标签引用\n{% asset_path slug %} {% asset_img slug [title] %} {% asset_link slug [title] %}\nhexo-tag-html5 Adding embedded html5 video to hexo\n{% html5video %} {% asset_path big-buck-bunny_trailer.webm %} {% endhtml5video %}\nUsage: With no args, the defaults are used: width = \u0026lsquo;100%\u0026rsquo; height = \u0026lsquo;250px\u0026rsquo; codec = \u0026lsquo;video/webm\u0026rsquo;\n{% html5video %} {% asset_path big-buck-bunny_trailer.webm %} {% endhtml5video %}\nor with args:\n{% html5video \u0026lsquo;100%\u0026rsquo; \u0026lsquo;250px\u0026rsquo; \u0026lsquo;video/mp4\u0026rsquo; %} {% asset_path big-buck-bunny_trailer.webm %} {% endhtml5video %}\nAdd hexo-tag-html5 to your _config.yml file including all the other packages you\u0026rsquo;re using. (Once you include one, you will need to include them all, grab the list from you package.json)\nExample: plugins: [hexo-tag-html5, hexo-deployer-git, hexo-server, hexo-generator-index, hexo-generator-archive, hexo-generator-category, hexo-generator-json-content, hexo-generator-tag, hexo-renderer-ejs, hexo-renderer-marked, hexo-renderer-stylus, hexo-tag-bootstrap, hexo-tag-fontawesome, hexo-tag-leaflet]\n","dateformatted":"16, September 2017","dateiso":"2017-09-16T15:42:33Z","ref":"/hexo%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","summary":"\n 博客工具\n概述 Hugo Hexo Jekyll 博客工具\nHexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n安装hexo 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：\n Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n\n","tags":["hexo"],"title":"Hexo基础使用"},{"content":"1.alibaba 1.1.https://github.com/alibaba/canal.git canal [kə\u0026rsquo;næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费\n工作原理\n canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议 MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal ) canal 解析 binary log 对象(原始为 byte 流) 谷歌的TensorFlow可以说是当今最受欢迎的开源深度学习框架，可用于各类深度学习相关的任务中。TensorFlow = Tensor + Flow，Tensor就是张量，代表N维数组；Flow即流，代表基于数据流图的计算。\n2.google 2.1 https://github.com/rstudio/tensorflow TensorFlow是目前深度学习的主流框架，其主要特性如下所述。\n TensorFlow支持Python、JavaScript、C ++、Java、Go、C＃、Julia和R等多种编程语言。 TensorFlow不仅拥有强大的计算集群，还可以在iOS和Android等移动平台上运行模型。 TensorFlow编程入门难度较大。初学者需要仔细考虑神经网络的架构，正确评估输入和输出数据的维度和数量。 TensorFlow使用静态计算图进行操作。也就是说，我们需要先定义图形，然后运行计算，如果我们需要对架构进行更改，则需要重新训练模型。选择这样的方法是为了提高效率，但是许多现代神经网络工具已经能够在学习过程中改进，并且不会显著降低学习速度。在这方面，TensorFlow的主要竞争对手是PyTorch。 其他深度学习项目参考\n https://github.com/keras-team/keras https://github.com/BVLC/caffe https://github.com/pytorch/pytorch https://github.com/Theano/Theano https://github.com/Microsoft/CNTK https://github.com/apache/incubator-mxnet https://github.com/PaddlePaddle/Paddle/ https://github.com/eclipse/deeplearning4j https://github.com/onnx/onnx\n 3.linkedin 3.1 https://github.com/linkedin onecall\n待整理 https://github.com/shadowsocks https://github.com/PingPlusPlus https://thinkjs.org/zh-cn/doc/3.0/controller.html#toc-7d3 https://github.com/Tencent https://github.com/Meituan-Dianping https://github.com/dianping https://github.com/dcloudio https://github.com/didi https://algorithm-visualizer.org/ https://github.com/yuuwill https://github.com/LibreOffice https://gitee.com/gvp https://github.com/iqiyi https://github.com/rancher https://www.gitbook.com/@skyao https://github.com/waylau/books-collection https://github.com/twbs https://github.com/sonatype https://chromium.googlesource.com/v8/v8.git https://github.com/antvis https://github.com/o2team https://github.com/JetBrains https://github.com/tencentyun https://github.com/OpenTSDB https://github.com/fex-team https://github.com/sofastack https://github.com/seata https://github.com/sohutv https://github.com/open-falcon-archive https://github.com/Netflix https://github.com/renrenio\n","dateformatted":"16, September 2017","dateiso":"2017-09-16T15:42:33Z","ref":"/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%B4%A2%E5%BC%95/","summary":"\n 1.alibaba 1.1.https://github.com/alibaba/canal.git canal [kə\u0026rsquo;næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费\n工作原理\n canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议 MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal ) canal 解析 binary log 对象(原始为 byte 流) 谷歌的TensorFlow可以说是当今最受欢迎的开源深度学习框架，可用于各类深度学习相关的任务中。TensorFlow = Tensor + Flow，Tensor就是张量，代表N维数组；Flow即流，代表基于数据流图的计算。\n\n","tags":["git"],"title":"开源项目索引"},{"content":"","dateformatted":"5, September 2017","dateiso":"2017-09-05T07:43:59+02:00","ref":"/kortkommandon-windows7/","summary":"\n \n\n","tags":null,"title":"Kortkommandon Windows 7"},{"content":"划分音节的五个步骤 音节简介\n开音节是以发音的元音a，e，i，o，u结尾的单词，或辅音+不发音e音节。r除外。开音节在和后面有辅音连续时很容易犯错，如，I like Bob，这句如果不懂得E是不发音的那句子就会读错。\n以一个或几个辅音字母（r除外）结尾而中间只有一个元音音素的音节，称为闭音节。例：map，desk，dog，pig\n注：在闭音节中，元音字母不发“字母”本身的音。重读的闭音节中元音字母读作短元音。\n重读闭音节是指在一个音节中，以辅音因素结尾的而且是重读音节的音节。重读闭音节中元音字母不是发它本身的字母音，而是发短元音，要注意其三要素\n（1）一个元音字母后跟一个或几个辅音字母，他们组成的音节必须是重读音节，如：apple。\n（2）以一个辅音字母结尾，如：fish。\n（3）元音字母发短元音。\n1.一个单词中有几个发音的元音字母，就有几个音节。\n2.两个元音间有两个辅音，则辅音分开，一边一个。\n3.两个元音间只有一个辅音，该辅音划分到后一个音节。\n4.字母组合要划分到同一个音节。\n5.词尾不发音的e不构成音节。\n6.两个元音字母在一起，一般为字母组合，发一个元音、构成一个音节。\n步骤：从后往前找到元音：单词中有多个元音时，方法都一样。\n元音往前找辅音。元音找到辅音，形成拼音，算一个音节。\n元音找不到辅音，自行发音，形成一个音节。\n辅音分配给念起来顺的音节；\n元音的前后最多三个辅音str-ai-ght。\n1音节划分步骤 1、找到元音：单词中有多个元音时，方法都一样。\n2、元音往前找辅音。\n3、元音找到辅音，形成拼音，算一个音节。\n4、元音找不到辅音，自行发音，形成一个音节。\n5、辅音分配给念起来顺的音节；元音的前后最多三个辅音str-ai-ght。\n2音节划分口诀 一靠后，二分手，多个中间偏左右，\n组合字母算一个，常见组合要遵守。\n词尾看e加音节，发音不发分两种，\n双字相连不连手，听音验证最后头。\n3判断开音节还是闭音节 （1）两元音字母之间如有两个辅音字母，则中间分开，一边一个。如mat－ter，mem－ber，win-dow，doc－tor，sup-per，lit－tle等。这样一分，第一个音节是以辅音字母结尾的，它就是重读闭音节，元音字母读短元音。\n（2）两元音字母中间有一辅音字母，该辅音字母划归后一音节。如basic，region，open，human等。这样一分，头一个音节是以元音字母结尾的，它是重读开音节，元音字母读其字母音。但是，双音节词中，重读开音节中的元音字母有不少仍读短元音。如second，present，ever，hover，modern，proper等。第二音节中有／i／时，第一音节中的a，e，i，o大多读短元音。如spanish，habit，mes-sage，city，system，profit等。\n（3）第一音节如是r音节或其他元音字母组合，其读音方法和单音节词基本一样，如army，merit，circle，order，purple，awful，autumn等。但也有读短元音的，如knowledge，nourish等。\n（4）非重读音节中的元音字母a，e，o，u，及字母组合ar，er，or，ure等一般读为／+／，如about，silent，atom，supply，radar，supper，doctor等。i，y及字母组合ay，ey一般读作／i／，如acid，thirty，Sunday，valley。a，e也可读作人／i／，如comrade，before等。o在词尾时仍读字母音。如hero，Negro等。\n","dateformatted":"1, January 0001","dateiso":"0001-01-01T00:00:00Z","ref":"/","summary":"\n 划分音节的五个步骤 音节简介\n开音节是以发音的元音a，e，i，o，u结尾的单词，或辅音+不发音e音节。r除外。开音节在和后面有辅音连续时很容易犯错，如，I like Bob，这句如果不懂得E是不发音的那句子就会读错。\n以一个或几个辅音字母（r除外）结尾而中间只有一个元音音素的音节，称为闭音节。例：map，desk，dog，pig\n注：在闭音节中，元音字母不发“字母”本身的音。重读的闭音节中元音字母读作短元音。\n重读闭音节是指在一个音节中，以辅音因素结尾的而且是重读音节的音节。重读闭音节中元音字母不是发它本身的字母音，而是发短元音，要注意其三要素\n（1）一个元音字母后跟一个或几个辅音字母，他们组成的音节必须是重读音节，如：apple。\n（2）以一个辅音字母结尾，如：fish。\n（3）元音字母发短元音。\n1.一个单词中有几个发音的元音字母，就有几个音节。\n2.两个元音间有两个辅音，则辅音分开，一边一个。\n3.两个元音间只有一个辅音，该辅音划分到后一个音节。\n4.字母组合要划分到同一个音节。\n5.词尾不发音的e不构成音节。\n6.两个元音字母在一起，一般为字母组合，发一个元音、构成一个音节。\n步骤：从后往前找到元音：单词中有多个元音时，方法都一样。\n元音往前找辅音。元音找到辅音，形成拼音，算一个音节。\n元音找不到辅音，自行发音，形成一个音节。\n\n","tags":null,"title":""}]