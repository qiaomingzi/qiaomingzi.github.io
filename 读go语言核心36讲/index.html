<!doctype html><html lang=en><head><meta charset=utf-8><meta name=referrer content="no-referrer"><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><title>读[GO语言核心36讲] | mingzi.li blog</title><meta property="og:type" content="website"><meta property="og:title" content="读[GO语言核心36讲]"><meta property="og:url" content="http://qiaomingzi.github.io/%E8%AF%BBgo%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2/"><meta property="og:locale" content="en_GB"><meta property="og:image" content="http://qiaomingzi.github.io/images/og-image.png"><link rel=canonical href=http://qiaomingzi.github.io/%E8%AF%BBgo%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2/><meta name=twitter:card content="summary"><meta name=twitter:site content="@p4lm"><link rel=stylesheet type=text/css href=/styles/main-bundle.108386b285ad502399f3a8ab890a333c177e59d922733a408892e466a7a87f70d143ace3585f247b62a75a780bd7bcff68b60fc6760b5ae1414e52c78fe708e7.css integrity media="screen, tv, projection"><link rel=stylesheet type=text/css href=/styles/print-bundle.f3d1ea3e2e864e24f7a26ff871aef6875b8e6246aad31fa6e63fdc9c91c629f6b4cdd7dca9beb3949f8b61a0db4c6fe8ec1bfc44ccf3a2cd9a91ea8e9eb20d44.css integrity media=print><link rel=preload as=font href=/fonts/muli1.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/muli2.woff2 type=font/woff2 crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#04396c><meta name=theme-color content="#ffffff"><meta name=generator content="Hugo 0.83.1"><svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><symbol id="icon-arrow-right" viewBox="0 0 32 32"><path d="M19.414 27.414l10-10c.781-.781.781-2.047.0-2.828l-10-10c-.781-.781-2.047-.781-2.828.0s-.781 2.047.0 2.828L23.172 14H4c-1.105.0-2 .895-2 2s.895 2 2 2h19.172l-6.586 6.586c-.39.39-.586.902-.586 1.414s.195 1.024.586 1.414c.781.781 2.047.781 2.828.0z"/></symbol><symbol id="icon-arrow-left" viewBox="0 0 32 32"><path d="M12.586 27.414l-10-10c-.781-.781-.781-2.047.0-2.828l10-10c.781-.781 2.047-.781 2.828.0s.781 2.047.0 2.828L8.828 14H28c1.105.0 2 .895 2 2s-.895 2-2 2H8.828l6.586 6.586c.39.39.586.902.586 1.414s-.195 1.024-.586 1.414c-.781.781-2.047.781-2.828.0z"/></symbol><symbol id="icon-calendar" viewBox="0 0 32 32"><path d="M27.2 4.8h-1.6V8h-4.8V4.8h-9.6V8H6.4V4.8H4.8C3.038 4.8 1.6 6.24 1.6 8v19.2c0 1.76 1.438 3.2 3.2 3.2h22.4c1.76.0 3.2-1.44 3.2-3.2V8c0-1.76-1.44-3.2-3.2-3.2zm0 22.4H4.8V14.4h22.4v12.8zM10.4 1.6H7.2v5.6h3.2V1.6zm14.4.0h-3.2v5.6h3.2V1.6z"/></symbol><symbol id="icon-expand" viewBox="0 0 32 32"><path d="M11.179 17.579l-4.69 4.85-3.29-3.886v10.258h10.219l-3.888-3.33 4.848-4.691-3.2-3.2zM18.581 3.2l3.888 3.33-4.848 4.691 3.2 3.2 4.69-4.85 3.29 3.886V3.199H18.582z"/></symbol><symbol id="icon-collapse" viewBox="0 0 32 32"><path d="M6.56 22.56 1.6 27.2l3.2 3.2 4.64-4.96 3.36 3.36v-9.6H3.2l3.36 3.36zM30.4 4.8l-3.2-3.2-4.64 4.96L19.2 3.2v9.6h9.6l-3.36-3.36L30.4 4.8z"/></symbol><symbol id="icon-bubble" viewBox="0 0 32 32"><path d="M16 2c8.837.0 16 5.82 16 13s-7.163 13-16 13c-.849.0-1.682-.054-2.495-.158C10.068 31.279 5.966 31.895 2 31.986v-.841C4.142 30.096 6 28.184 6 26c0-.305-.024-.604-.068-.897-3.619-2.383-5.932-6.024-5.932-10.103.0-7.18 7.163-13 16-13z"/></symbol><symbol id="icon-folder" viewBox="0 0 32 32"><path d="M29.448 7.678C29.27 6.974 28.4 6.4 27.512 6.4H16.61c-.886.0-2.128-.509-2.755-1.131l-.954-.941c-.627-.622-1.867-1.128-2.754-1.128H4.939c-.888.0-1.694.715-1.792 1.59L2.68 9.6h27.09l-.322-1.922zM31.059 11.2h-30.118c-.547.0-.976.47-.923 1.016l1.477 15.47c.059.63.59 1.114 1.226 1.114h26.56c.635.0 1.165-.483 1.226-1.114l1.477-15.47c.053-.546-.376-1.016-.923-1.016z"/></symbol><symbol id="icon-tag" viewBox="0 0 32 32"><path d="M31.021.648c-.178-.502-.726-.768-1.23-.594s-.77.728-.595 1.232c1.486 4.272-1.464 7.462-3.714 9.171l-.909-1.302c-.306-.437-.989-.8-1.52-.806l-5.101.022c-.531-.01-1.32.234-1.755.541l-15.03 10.539c-.728.512-.904 1.515-.395 2.246l6.83 9.773c.512.728 1.33.64 2.059.131l15.03-10.541c.432-.306.931-.965 1.107-1.469l1.597-5.032c.176-.502.069-1.269-.237-1.706l-.554-.794c3.021-2.315 6.157-6.406 4.416-11.413zM24.027 15.621c-1.163.816-2.77.531-3.584-.634-.818-1.168-.533-2.774.632-3.594.925-.648 2.125-.602 2.989.027-.435.262-.734.416-.79.44-.482.229-.688.806-.461 1.288.166.35.514.557.875.557.138.0.278-.032.411-.094.31-.147.643-.322.99-.528.155.95-.222 1.947-1.062 2.538z"/></symbol><symbol id="icon-circle-with-cross" viewBox="0 0 32 32"><title>Close (Esc)</title><path d="M16 2.56C8.578 2.56 2.56 8.578 2.56 16S8.578 29.44 16 29.44 29.44 23.422 29.44 16 23.422 2.56 16 2.56zm7.662 18.338-2.766 2.766L16 18.766l-4.898 4.896-2.766-2.766L13.235 16l-4.898-4.898 2.766-2.765 4.896 4.896 4.898-4.898 2.766 2.766-4.899 4.898 4.898 4.898z"/></symbol></defs></svg></head><body x-data=window.blog :class="{ 'modal-open': isModalOpen, 'keyboard-navigation' : keyboardNavigation }" @mouseup="keyboardNavigation = false" @keydown.tab="keyboardNavigation = true" @keydown.escape=closeModals()><script>try{const a=window.localStorage.getItem('theme');a==='dark'&&document.querySelector('body').classList.add('dark'),a==='light'&&document.querySelector('body').classList.add('light')}catch(a){}</script><link rel=stylesheet type=text/css href=/styles/post-bundle.min.a3c415b51dea409e064708f705f91702ddddb4aaf1c7522073113ac5c6941f198ce5f39ea63cfaf21674b905146c1bdf3eeb0eaa41d22b9d013117c9bb72d81e.css integrity="sha512-o8QVtR3qQJ4GRwj3BfkXAt3dtKrxx1IgcxE6xcaUHxmM5fOepjz68hZ0uQUUbBvfPusOqkHSK50BMRfJu3LYHg==" media="screen, tv, projection"><div id=page-wrapper><header><svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><symbol id="icon-home" viewBox="0 0 32 32"><path d="M32 18.451 16 6.031.0 18.451v-5.064l16-12.42 16 12.42zM28 18v12h-8v-8h-8v8H4V18l12-9z"/></symbol><symbol id="icon-user" viewBox="0 0 32 32"><path d="M18 22.082v-1.649c2.203-1.241 4-4.337 4-7.432.0-4.971.0-9-6-9s-6 4.029-6 9c0 3.096 1.797 6.191 4 7.432v1.649C7.216 22.637 2 25.97 2 30h28c0-4.03-5.216-7.364-12-7.918z"/></symbol><symbol id="icon-search" viewBox="0 0 32 32"><path d="M31.008 27.231l-7.58-6.447c-.784-.705-1.622-1.029-2.299-.998 1.789-2.096 2.87-4.815 2.87-7.787.0-6.627-5.373-12-12-12s-12 5.373-12 12 5.373 12 12 12c2.972.0 5.691-1.081 7.787-2.87-.031.677.293 1.515.998 2.299l6.447 7.58c1.104 1.226 2.907 1.33 4.007.23s.997-2.903-.23-4.007zM12 20c-4.418.0-8-3.582-8-8s3.582-8 8-8 8 3.582 8 8-3.582 8-8 8z"/></symbol></defs></svg><div class=header-content @click.away=menu.close()><div class=site-title>mingzi.li blog<span style=font-size:.5rem;margin-top:20px>&nbsp;&nbsp;行到水穷处，坐看风云起</span></div><div class=theme-switcher :class="{'has-javascript': true}"><div class=switch><input type=checkbox name=toggle id=theme-switcher-indicator aria-label="Switch theme" @click=theme.toggleChanged($event.target) checked>
<label for=theme-switcher-indicator><i></i></label>
<span></span></div></div><a href=#content id=skip-link class=skip-link @click.prevent=skipLink.skipToContent($refs.content) @click.away=skipLink.removeContentTabIndex($refs.content)>Skip to content</a>
<button @click=menu.toggle() class=hamburger-trigger>Menu<div class=hamburger-menu><div class=bar :class="{'animate': menu.hamburgerIsOpen()}"></div></div></button><nav :class="{'open': menu.isOpen() || menu.isOpening(), 'open closing': menu.isClosing()}"><a href=/ class=home><svg class="icon icon-home"><use xlink:href="#icon-home"/></svg>首页</a>
<a href=/about/ class=about><svg class="icon icon-user"><use xlink:href="#icon-user"/></svg>关于我</a>
<a href=/search-requires-javascript/ rel=nofollow class=search x-ref=searchMenuLink @click.prevent="menu.close(); search.open();$nextTick(() => $refs.searchInput.focus())"><svg class="icon icon-search"><use xlink:href="#icon-search"/></svg>搜索</a></nav></div></header><div class=body><div class=body-max-width><main id=content x-ref=content><article class=full-article><h1>读[GO语言核心36讲]</h1><div class=entry-meta><time class=published datetime="2022-05-29 15:42:33 +0000 UTC"><svg class="icon icon-calendar"><use xlink:href="#icon-calendar"/></svg>2022 May 29</time></div><div style=text-align:center;display:block;color:#999><div>本文仅为个人笔记,作为学习使用,如有雷同请联系作者 mingzi.li 处理,mail: qiaomingzi100@sina.com</div></div><h2 id=一概要>一：概要</h2><h3 id=11参考>1.1.参考</h3><p>【GO编程语言规范】https://golang.google.cn/ref/spec</p><p>【GO命令】https://golang.google.cn/cmd/</p><p>【环境设置】https://www.liwenzhou.com/posts/Go/install_go_dev_old/</p><p>【Unicode】https://home.unicode.org/</p><h2 id=二go语言基础知识>二：Go语言基础知识</h2><p>理解Go语言的开发环境配置、常用源码文件写法，以及程序实体（尤其是变量）及其相关的各种概念和编程技巧（比如类型推断、变量重声明、可重名变量、类型断言、类型转换、别名类型和潜在类型等）。</p><h3 id=1工作区和gopath>1.工作区和GOPATH</h3><p>GOROOT：Go语言安装根目录的路径，也就是GO语言的安装路径。</p><p>GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。</p><p>你可以把GOPATH简单理解成Go语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表Go语言的一个工作区（workspace）</p><pre><code>go mod init qiaomingzi.github.io/m/v1
</code></pre><p><img src=./images/1-1.jpg alt></p><p>GOBIN：GO程序生成的可执行文件（executable file）的路径。</p><h3 id=2源码文件>2.源码文件</h3><p><img src=./images/2-1.png alt></p><h4 id=21-运行程序>2.1 运行程序</h4><p>使用 <strong>go run</strong> 命令执行go源码main文件</p><pre><code>$ go run hello.go 
Hello, World!
</code></pre><p>此外我们还可以使用 <strong>go build</strong> 命令来生成二进制文件：</p><pre><code>$ go build hello.go 
$ ls
hello    hello.go
$ ./hello 
Hello, World!
</code></pre><h4 id=22-程序实体>2.2 程序实体</h4><p>是变量、常量、函数、结构体和接口的统称；程序实体的名字被统称为标识符。标识符可以是任何Unicode编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。</p><p>如：<code>var name string</code></p><h4 id=23-源文件包名>2.3 源文件包名</h4><p><code>package xxx</code></p><ul><li><p>同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。</p></li><li><p>源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。</p></li><li><p>为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致</p></li><li><p>名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。</p></li><li><p>Go 1.5及后续版本中，我们可以通过创建<code>internal</code>代码包让一些程序实体仅仅能被当前模块中的其他代码引用。这被称为Go程序实体的第三种访问权限：模块级私有</p></li></ul><h3 id=3程序实体的那些事儿>3.程序实体的那些事儿</h3><h4 id=31-变量声明>3.1 变量声明</h4><p>Go语言是静态类型的编程语言，所以我们在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让Go语言能够推导出它们的类型。Go语言是静态类型的，所以一旦在初始化变量时确定了它的类型，之后就不可能再改变。这就避免了在后面维护程序时的一些问题。另外，请记住，这种类型的确定是在编译期完成的，因此不会对程序的运行效率产生任何影响。</p><blockquote><p>在Go语言中，变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数、结构体或接口。</p></blockquote><p><img src=./images/4-1.jpg alt></p><h4 id=32-重构>3.2 重构</h4><blockquote><p>我们通常把不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码修改方式，叫做对该程序的重构。重构的对象可以是一行代码、一个函数、一个功能模块，甚至一个软件系统。</p></blockquote><h4 id=33-代码块>3.3 代码块</h4><p>代码块一般就是一个由花括号括起来的区域，里面可以包含表达式和语句。全域代码块、空代码块。</p><h4 id=34-变量重声明>3.4 变量重声明</h4><p>对已经声明过的变量再次声明。变量重声明的前提条件如下。</p><ol><li>由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误。</li><li>变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了，我在下一篇文章中会讲到。</li><li>变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字<code>var</code>的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。</li><li>被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。</li></ol><p>对于同一个代码块而言,声明重名的变量是无法通过编译的，用短变量声明对已有变量进行重声明除外;对于不同的代码块来说，其中的变量重名没什么大不了，照样可以通过编译。</p><h4 id=35-重名变量查找过程>3.5 重名变量查找过程</h4><ul><li>首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。</li><li>其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。</li><li>一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么Go语言的编译器就会报错了。</li></ul><h4 id=36-语法糖>3.6 语法糖</h4><p>或者叫便利措施</p><h4 id=37-作用域>3.7 作用域</h4><p>程序实体的访问权限有三种：包级私有的、模块级私有的和公开的，一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制。</p><h4 id=38-类型断言>3.8 类型断言</h4><p>类型断言表达式的语法形式是<code>x.(T)</code>。其中的<code>x</code>代表要被判断类型的值</p><pre><code>var container = []string{&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;}
value,ok = interface{}(container).([]string)
</code></pre><p><img src=./images/6-1.png alt></p><h4 id=39-类型>3.9 类型</h4><ul><li><p><code>interface{}</code>代表了不包含任何方法定义的、空的接口类型。任何类型都是它的实现类型。任何类型的值都可以很方便地被转换成空接口的值。</p></li><li><p><code>struct{}</code>，它就代表了不包含任何字段和方法的、空的结构体类型。</p></li><li><p>比如空的切片值<code>[]string{} </code>表示元素类型为string的切片类型</p></li><li><p>空的字典值<code>map[int]string{}</code> 用来表示键类型为<code>int</code>、值类型为<code>string</code>的字典类型</p></li><li><p>string<code>是表示字符串类型的字面量，</code></p></li><li><p>uint8`是表示8位无符号整数类型的字面量</p></li></ul><h4 id=310-类型转换>3.10 类型转换</h4><p><strong>首先，对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。</strong></p><p><strong>第二，虽然直接把一个整数值转换为一个<code>string</code>类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的Unicode代码点，否则转换的结果将会是<code>"�"</code>（仅由高亮的问号组成的字符串值）。</strong></p><p><strong>关于<code>string</code>类型与各种切片类型之间的互转的。</strong></p><p>一个值在从<code>string</code>类型向<code>[]byte</code>类型转换时代表着以UTF-8编码的字符串会被拆分成零散、独立的字节。</p><pre><code>string([]byte{'\xe4', '\xbd', '\xa0', '\xe5', '\xa5', '\xbd'}) // 你好
</code></pre><p>比如，UTF-8编码的三个字节<code>\xe4</code>、<code>\xbd</code>和<code>\xa0</code>合在一起才能代表字符<code>'你'</code>，而<code>\xe5</code>、<code>\xa5</code>和<code>\xbd</code>合在一起才能代表字符<code>'好'</code>。</p><p>一个值在从<code>string</code>类型向<code>[]rune</code>类型转换时代表着字符串会被拆分成一个个Unicode字符。</p><pre><code>string([]rune{'\u4F60', '\u597D'}) // 你好
</code></pre><h4 id=311-别名类型类型再定义与潜在类型>3.11 别名类型、类型再定义与潜在类型</h4><p>潜在类型相同的不同类型的值之间是可以进行类型转换的。但对于集合类的类型<code>[]MyString2</code>与<code>[]string</code>来说这样做却是不合法的，因为<code>[]MyString2</code>与<code>[]string</code>的潜在类型不同，分别是<code>[]MyString2</code>和<code>[]string</code>。</p><p><img src=./images/6-2.png alt></p><h2 id=三go语言实战与应用>三：Go语言实战与应用</h2><h3 id=1数组和切片>1.数组和切片</h3><p>数组（array）类型和切片（slice）类型。它们的共同点是都属于集合类的类型，并且，它们的值也都可以用来存储某一种类型的值（或者说元素）。它们最重要的不同是：<strong>数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。</strong></p><blockquote><p>Go语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等；而Go语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。</p><p>注意，Go语言里不存在像Java等编程语言中令人困惑的“传值或传引用”问题。在Go语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。</p><p>如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。</p><p>我们在数组和切片之上都可以应用索引表达式，得到的都会是某个元素。我们在它们之上也都可以应用切片表达式，也都会得到一个新的切片。</p></blockquote><p><img src=./images/7-1.png alt></p><h4 id=切片与数组的关系>切片与数组的关系</h4><p>可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。切片的容量代表了它的底层数组的长度，但这仅限于使用<code>make</code>函数或者切片值字面量初始化切片的情况。</p><p>更通用的规则是：一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。</p><pre><code>例子：
s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
s4 := s3[3:6]

the length of s4:3
the captcity of s4(8-3):5
</code></pre><p><img src=./images/7-2.png alt></p><h4 id=切片容量扩容>切片容量扩容</h4><p>一旦一个切片无法容纳更多的元素，Go语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的2倍。</p><p>但是，当原切片的长度（以下简称原长度）大于或等于<code>1024</code>时，Go语言将会以原容量的<code>1.25</code>倍作为新容量的基准（以下新容量基准）。新容量基准会被调整（不断地与<code>1.25</code>相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会比新长度大一些，当然，相等也是可能的。</p><p>另外，如果我们一次追加的元素过多，以至于使新长度比原容量的2倍还要大，那么新容量就会以新长度为基准。注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些</p><pre><code>	s5 := make([]int,0)
	for i :=1; i &lt; 5;i++{
		s5 = append(s5,i)
		fmt.Printf(&quot;s5(%d): len: %d, cap: %d\n&quot;, i, len(s5), cap(s5))
	}
	s5_1 := append(s5,make([]int,102)...)
	fmt.Printf(&quot;s6: len: %d, cap: %d\n&quot;, len(s5_1), cap(s5_1))
	s6 := make([]int, 1024)
	s6_1 := append(s6, make([]int, 200)...)
	fmt.Printf(&quot;s7e1: len: %d, cap: %d\n&quot;, len(s6_1), cap(s6_1))
	
	---------------------
	s5(1): len: 1, cap: 1
	s5(2): len: 2, cap: 2
	s5(3): len: 3, cap: 4
	s5(4): len: 4, cap: 4
	s5_1: len: 106, cap: 112
	s6_1: len: 1224, cap: 1280
</code></pre><p>注意：</p><ul><li><p><strong>一个切片的底层数组永远不会被替换,虽然在扩容的时候Go语言一定会生成新的底层数组，但是它也同时生成了新的切片。它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。</strong></p></li><li><p><strong><code>append</code>函数返回的是指向原底层数组的原切片，而在需要扩容时，<code>append</code>函数返回的是指向新底层数组的新切片。</strong></p></li></ul><h3 id=2container包中的那些容器>2.container包中的那些容器</h3><p>Go语言的链表实现在标准库的<code>container/list</code>代码包中，List实现了一个双向链表（以下简称链表），而Element则代表了链表中元素的结构。</p><h4 id=链表var-l-listlist>链表var l list.List</h4><p><code>List</code>这个结构体类型有两个字段，一个是<code>Element</code>类型的字段<code>root</code>，另一个是<code>int</code>类型的字段<code>len</code>,它们都是包级私有的，也就是说使用者无法查看和修改它们。</p><p><code>len</code>的零值是<code>0</code>，</p><p><code>root</code>是<code>Element</code>类型 零值 Element{}<code>。</code></p><blockquote><blockquote><p>Element`类型包含了几个包级私有的字段，分别用于存储前一个元素、后一个元素以及所属链表的指针值。</p></blockquote></blockquote><blockquote><blockquote><p><code>Value</code>的公开的字段， 它是<code>interface{}</code>类型的。在<code>Element</code>类型的零值中，这些字段的值都会是<code>nil</code>。</p></blockquote></blockquote><h4 id=延迟初始化>延迟初始化</h4><p>所谓的<strong>延迟初始化</strong>，你可以理解为把初始化操作延后，仅在实际需要的时候才进行。延迟初始化的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。</p><h4 id=ringring-与-listlist区别>ring.Ring 与 list.List区别</h4><p><code>container/ring</code>包中的<code>Ring</code>类型实现的是一个循环链表，也就是我们俗称的环。其实<code>List</code>在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。</p><ol><li>Ring<code>类型的数据结构仅由它自身即可代表，而</code>List<code>类型则需要由它以及</code>Element`类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。</li><li>一个<code>Ring</code>类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个<code>List</code>类型的值则代表了一个完整的链表。这是表示维度上的不同。</li><li>在创建并初始化一个<code>Ring</code>值的时候，我们可以指定它包含的元素的数量，但是对于一个<code>List</code>值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的<code>New</code>函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。</li><li>仅通过<code>var r ring.Ring</code>语句声明的<code>r</code>将会是一个长度为<code>1</code>的循环链表，而<code>List</code>类型的零值则是一个长度为<code>0</code>的链表。别忘了<code>List</code>中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。</li><li><code>Ring</code>值的<code>Len</code>方法的算法复杂度是O(N)的，而<code>List</code>值的<code>Len</code>方法的算法复杂度则是O(1)的。这是两者在性能方面最显而易见的差别。</li></ol><h3 id=3字典的操作和约束>3.字典的操作和约束</h3><p>Go语言字典的键类型不可以是函数类型、字典类型和切片类型。Go语言的字典类型其实是一个哈希表（hash table）的特定实现，键的类型是受限的，而元素却可以是任意类型的。</p><h4 id=根据键值获取值>根据键值获取值</h4><p>先把键值作为参数传给这个哈希表。哈希表会先用哈希函数（hash function）把键值转换为哈希值。哈希值通常是一个无符号的整数。一个哈希表会持有一定数量的桶（bucket），我们也可以叫它哈希桶，这些哈希桶会均匀地储存其所属哈希表收纳的键-元素对。</p><p>哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。由于键-元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素值。</p><h4 id=键值的约束>键值的约束</h4><p>Go语言规范规定，在键类型的值之间必须可以施加操作符<code>==</code>和<code>!=</code>键类型的值必须要支持判等操作。</p><h4 id=哈希碰撞>哈希碰撞</h4><p>不同值的哈希值是可能相同的。所以即使哈希值一样，键值也不一定一样。只有键的哈希值和键值都相等，才能说明查找到了匹配的键-元素对。</p><h4 id=哪些类型适和做键类型>哪些类型适和做键类型</h4><p><strong>求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。</strong></p><p>对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go语言都有一套算法与之对应。这套算法中就包含了哈希和判等。</p><h3 id=4通道的基本操作>4.通道的基本操作</h3><p>作为Go语言最有特色的数据类型，通道（channel）完全可以与goroutine（也可称为go程）并驾齐驱，共同代表Go语言独有的并发编程模式和编程哲学。</p><blockquote><p>Don’t communicate by sharing memory; share memory by communicating. （不要通过共享内存来通信，而应该通过通信来共享内存。）</p></blockquote><p>这是作为Go语言的主要创造者之一的Rob Pike的至理名言，这也充分体现了Go语言最重要的编程理念。通道类型的值本身就是并发安全的，这也是Go语言自带的、唯一一个可以满足并发安全性的类型。</p><h4 id=通道特性>通道特性</h4><p><strong>一个通道相当于一个先进先出（FIFO）的队列</strong>。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符<code>&lt;-</code>。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。</p><p>基本特性如下。</p><ol><li><p>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。</p><p><strong>元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。</strong></p></li><li><p>发送操作和接收操作中对元素值的处理都是不可分割的。</p></li><li><p>发送操作在完全完成之前会被阻塞。接收操作也是如此。</p></li></ol><hr><h4 id=通道panic>通道panic</h4><p>通道一旦关闭，再对它进行发送操作，就会引发panic。如果我们试图关闭一个已经关闭了的通道，也会引发panic。</p><h4 id=通道发送和接收>通道发送和接收</h4><p><strong>缓冲通道</strong> 如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。这时，通道会优先通知最早因此而等待的、那个发送操作所在的goroutine，后者会再次执行发送操作。它们所在的goroutine会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。</p><p>相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的goroutine，并使它再次执行接收操作。因此而等待的、所有接收操作所在的goroutine，都会按照先后顺序被放入通道内部的接收等待队列。</p><p>缓冲通道会作为收发双方的中间件。元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。</p><p><strong>非缓冲通道</strong> 无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。</p><p>非缓冲通道是在用同步的方式传递数据。 缓冲通道则在用异步的方式传递数据。</p><p>值为<code>nil</code>的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的goroutine中的任何代码，都不再会被执行。由于通道类型是引用类型，所以它的零值就是<code>nil</code>。换句话说，当我们只声明该类型的变量但没有用<code>make</code>函数对它进行初始化时，该变量的值就会是<code>nil</code>。<strong>我们一定不要忘记初始化通道！</strong></p><h4 id=单向通道>单向通道</h4><p>只能发而不能收 <code>var singleDirectionChan = make(chan&lt;- int, 1)</code></p><p>只能收不能发 `var singleDirectionChan = make(&lt;-chan int, 1)</p><p>单向通道最主要的用途就是约束其他代码的行为:</p><pre><code>type Notifier interface {
	SendInt(ch chan&lt;- int)
}
</code></pre><p>使用带<code>range</code>子句的<code>for</code>语句从通道中获取数据，也可以通过</p><h4 id=for-range语句操纵通道><code>for range</code>语句操纵通道</h4><p>带有<code>range</code>子句的<code>for</code>语句操纵通道：</p><h4 id=select语句操纵通道><code>select</code>语句操纵通道</h4><p><code>select</code>语句是Go语言还有一种专门为了操作通道而存在的语句，规则如下：</p><ul><li><p>对于每一个<code>case</code>表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。它包含的多个表达式总会以从左到右的顺序被求值。</p></li><li><p>select<code>语句包含的候选分支中的</code>case`表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。</p></li><li><p>对于每一个<code>case</code>表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该<code>case</code>表达式的求值就是不成功的。在这种情况下，我们可以说，这个<code>case</code>表达式所在的候选分支是不满足选择条件的。</p></li><li><p>仅当<code>select</code>语句中的所有<code>case</code>表达式都被求值完毕后，它才会开始选择候选分支。这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行。如果这时没有默认分支，那么<code>select</code>语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止。一旦有一个候选分支满足选择条件，<code>select</code>语句（或者说它所在的goroutine）就会被唤醒，这个候选分支就会被执行。</p></li><li><p>如果<code>select</code>语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行。注意，即使<code>select</code>语句是在被唤醒时发现的这种情况，也会这样做。</p></li><li><p>一条<code>select</code>语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关。</p></li><li><p>select<code>语句的每次执行，包括</code>case<code>表达式求值和分支选择，都是独立的。不过，至于它的执行是否是并发安全的，就要看其中的</code>case`表达式以及分支中，是否包含并发不安全的代码了。</p></li></ul><h3 id=5使用函数的正确姿势>5.使用函数的正确姿势</h3><p>“函数是一等的公民”，函数类型它是一种对一组输入、输出进行模板化的重要工具；函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等。</p><p>只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可以说它们是一样的函数，各个参数名称、结果的名称、函数的名称(调用函数时给定的标识符)不能算作函数签名的一部分。</p><p>函数参数原则：<strong>既不要把你程序的细节暴露给外界，也尽量不要让外界的变动影响到你的程序。</strong></p><p><strong>所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是它的副本。</strong></p><h4 id=函数类型>函数类型</h4><p>声明函数类型<code>type operate func(x, y int) int</code> 它有两个参数和一个结果，都是<code>int</code>类型。</p><p>函数类型属于引用类型，零值是nil。</p><h4 id=匿名函数>匿名函数</h4><pre><code>op := func(x, y int) int {
	return x + y
}
</code></pre><h4 id=高阶函数与闭包>高阶函数与闭包</h4><p>高阶函数条件</p><ul><li><p>接受其他的函数作为参数传入</p></li><li><p>把其他的函数作为结果返回</p></li></ul><p><img src=./images/12-1.png alt></p><p>严格来说，函数的名称也不能算作函数签名的一部分，它只是我们在调用函数时，需要给定的标识符而已。</p><h3 id=6结构体及其方法的使用法门>6.结构体及其方法的使用法门</h3><p><strong>Go语言中根本没有继承的概念</strong>，它所做的是通过嵌入字段的方式实现了类型之间的组合，见官方解释 <a href=https://golang.org/doc/faq#inheritance>https://golang.org/doc/faq#inheritance</a></p><blockquote><p>面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。</p></blockquote><h4 id=结构体接收者>结构体接收者</h4><p>接收者声明就是在关键字<code>func</code>和方法名称之间的圆括号包裹起来的内容，其中必须包含<strong>确切的名称</strong>和<strong>类型字面量</strong>。</p><pre><code>func (ac AnimalCategory) String() string {
    ....
}
</code></pre><p>上面代码的接收者声明可以看出它隶属于<code>AnimalCategory</code>类型，方法隶属的类型其实并不局限于结构体类型，但必须是某个自定义的数据类型，并且不能是任何接口类型。在Go语言中，我们可以通过为一个类型编写名为<code>String</code>的方法，来自定义该类型的字符串表示形式。这个<code>String</code>方法不需要任何参数声明，但需要有一个<code>string</code>类型的结果声明。</p><blockquote><p>一个数据类型关联的所有方法，共同组成了该类型的方法集合。同一个方法集合中的方法不能出现重名。并且，如果它们所属的是一个结构体类型，那么它们的名称与该类型中任何字段的名称也不能重复。</p></blockquote><blockquote><p>我们可以把结构体类型中的一个字段看作是它的一个属性或者一项数据，再把隶属于它的一个方法看作是附加在其中数据之上的一个能力或者一项操作。将属性及其能力（或者说数据及其操作）封装在一起，是面向对象编程（object-oriented programming）的一个主要原则。</p></blockquote><blockquote><p>Go语言摄取了面向对象编程中的很多优秀特性，同时也推荐这种封装的做法。从这方面看，Go语言其实是支持面向对象编程的，但它选择摒弃了一些在实际运用过程中容易引起程序开发者困惑的特性和规则。</p></blockquote><h4 id=嵌入字段>嵌入字段</h4><p>嵌入字段是其声明中只有类型而没有名称的字段，它可以以一种很自然的方式为被嵌入的类型带来新的属性和能力。但是需要小心可能产生“屏蔽”现象的地方，尤其是当存在多个嵌入字段或者多层嵌入的时候。“屏蔽”现象可能会让你的实际引用与你的预期不符。</p><pre><code>type Animal struct {
	scientificName string  
	AnimalCategory //嵌入字段 or 匿名字段,相当于此类型变量的名称后跟“.”,嵌入字段的类型既是类型也是名称。
}
</code></pre><h4 id=类型组合>类型组合</h4><p>类型之间的组合采用的是非声明的方式，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。组合要比继承更加简洁和清晰；</p><h4 id=值方法和指针方法区别>值方法和指针方法区别</h4><ul><li><p>值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型。</p></li><li><p>而指针方法的接收者，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内对该副本指向的值进行修改，却一定会体现在原值上。</p></li><li><p>一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。</p></li></ul><h3 id=7接口类型的合理运用>7.接口类型的合理运用</h3><p>在Go语言的语境中，当我们在谈论“接口”的时候，一定指的是接口类型。因为接口类型与其他数据类型不同，它是没法被实例化的，既不能通过调用<code>new</code>函数或<code>make</code>函数创建出一个接口类型的值，也无法用字面量来表示一个接口类型的值。通过关键字<code>type</code>和<code>interface</code>，我们可以声明出接口类型。</p><p>接口类型声明中的这些方法所代表的就是该接口的方法集合。一个接口的方法集合就是它的全部特征。对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征（即全部的方法），那么它就一定是这个接口的实现类型。</p><h4 id=鸭子类型>鸭子类型</h4><p>在程序设计中，<strong>鸭子类型</strong>（英语：<strong>duck typing</strong>）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，由"当前方法和属性的集合"决定。这是一种无侵入式的接口实现方式。详细了解：https://baike.baidu.com/item/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B</p><h4 id=判断方法是否被实现>判断方法是否被实现</h4><ul><li><p>两个方法的签名需要完全一致</p></li><li><p>两个方法的名称要一模一样</p></li></ul><h4 id=动态类型>动态类型</h4><pre><code>type Pet interface {
	SetName(name string)
	Name() string
	Category() string
}
dog := Dog{&quot;little pig&quot;}
var pet Pet = &amp;dog
</code></pre><p>比如，我们把取址表达式<code>&dog</code>的结果值赋给了变量<code>pet</code>，这时这个结果值就是变量<code>pet</code>的动态值，而此结果值的类型<code>*Dog</code>就是该变量的动态类型。变量<code>pet</code>，我们赋给它的值可以被叫做它的实际值（也称<strong>动态值</strong>），而该值的类型可以被叫做这个变量的实际类型（也称<strong>动态类型</strong>）。</p><p>动态类型这个叫法是相对于<strong>静态类型</strong>而言的。对于变量<code>pet</code>来讲，它的<strong>静态类型</strong>就是<code>Pet</code>，并且永远是<code>Pet</code>，但是它的动态类型却会随着我们赋给它的动态值而变化。在我们给一个接口类型的变量赋予实际的值之前，它的动态类型是不存在的。</p><p>当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存储在一个专用的数据结构中。这个专用的数据结构在Go语言的<code>runtime</code>包叫做<code>iface</code>。<code>iface</code>的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径，等等。总之,接口变量被赋予动态值的时候，存储的是包含了这个动态值的副本的一个结构更加复杂的值。</p><p>接口类型本身是无法被值化的。在我们赋予它实际的值之前，它的值一定会是<code>nil</code>，这也是它的零值。除非我们只声明而不初始化，或者显式地赋给它<code>nil</code>，否则接口变量的值就不会为<code>nil</code>。</p><h4 id=接口组合>接口组合</h4><p>Go语言团队鼓励我们声明体量较小的接口，并建议我们通过接口间的组合来扩展程序、增加程序的灵活性。这是因为相比于包含很多方法的大接口而言，小接口可以更加专注地表达某一种能力或某一类特征，同时也更容易被组合在一起。</p><p>接口类型间的嵌入也被称为接口的组合。<strong>接口类型间的嵌入会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此。因此，接口的组合根本不可能导致“屏蔽”现象的出现。</strong></p><h3 id=8关于指针的有限操作>8.关于指针的有限操作</h3><p>从传统意义上说，指针是一个指向某个确切的内存地址的值。</p><pre><code>type struct Dog{
   name string
}
func (dog *Dog) SetName(name string) {
	dog.name = name
}
func New(name string) Dog {
	return Dog{name}
}

【1】New(&quot;cat&quot;).SetName(&quot;miao miao&quot;)   //我们可以在一个基本类型的值上调用它的指针方法，这是因为Go语言会自动地帮我们转译，但是New`函数所得到的结果值属于临时结果 无法取址导致编译报错
【2】
 dog := Dog{&quot;little dog&quot;}
 dog.SetName(&quot;monster&quot;)  //Dog类型的变量dog，被自动地转译为(&amp;dog).SetName(&quot;monster&quot;)，即：先取dog的指针值，再在该指针值上调用SetName方法。

</code></pre><p>从例子代码看：对于基本类型<code>Dog</code>来说，<code>*Dog</code>就是它的指针类型。而对于一个<code>Dog</code>类型，值不为<code>nil</code>的变量<code>dog</code>，取址表达式<code>&dog</code>的结果就是该变量的值（也就是基本值）的指针值。如果一个方法的接收者是<code>*Dog</code>类型的，那么该方法就是基本类型<code>Dog</code>的指针方法。</p><h4 id=可以代表指针有哪些>可以代表指针有哪些</h4><p>在Go语言中 uintptr`类型可以代表“指针”，该类型实际上是一个数值类型，也是Go语言内建的数据类型之一。根据当前计算机的计算架构的不同，它可以存储32位或64位的无符号整数，可以代表任何指针的位（bit）模式，也就是原始的内存地址。</p><p>Go语言标准库中的<code>unsafe</code>包。``unsafe.Pointer<code>也代表了“指针”，表示任何指向可寻址的值的指针，同时它也是前面提到的指针值和</code>uintptr`值之间的桥梁。通过它，我们可以在这两种值之上进行双向的转换——可寻址的（addressable）。</p><h4 id=哪些值是不可寻址>哪些值是不可寻址</h4><p>常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是<strong>不可变的</strong>。由于Go语言中的字符串值也是不可变的，所以对于一个字符串类型的变量来说，基于它的索引或切片的结果值也都是不可寻址的。</p><p>算术操作的结果值属于一种<strong>临时结果</strong>,是不可寻址的。针对数组值、切片值或字典值的<strong>字面量</strong>的表达式会产生临时结果。这主要因为变量的值本身就不是“临时的”。对比而言，值字面量在还没有与任何变量（或者说任何标识符）绑定之前是没有落脚点的，我们无法以任何方式引用到它们。这样的值就是“临时的”。</p><blockquote><p>一个需要特别注意的例外是，对切片字面量的索引结果值是可寻址的。因为不论怎样，每个切片值都会持有一个底层数组，而这个底层数组中的每个元素值都是有一个确切的内存地址的。</p><p>如果针对的是数组类型或切片类型的<strong>变量</strong>，那么索引或切片的结果值就都不属于临时结果了，是可寻址的。</p><p>如果我们把临时结果赋给一个变量，那么它就是可寻址的了。如此一来，取得的指针指向的就是这个变量持有的那个值了。</p></blockquote><p>Go语言中以下是不可寻址</p><ul><li>常量的值。</li><li>基本类型值的字面量。</li><li>算术操作的结果值。</li><li>对各种字面量的索引表达式和切片表达式的结果值。不过有一个例外，对切片字面量的索引结果值却是可寻址的。</li><li>对字符串变量的索引表达式和切片表达式的结果值。</li><li>对字典变量的索引表达式的结果值。</li><li>函数字面量和方法字面量，以及对它们的调用表达式的结果值。</li><li>结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值。</li><li>类型转换表达式的结果值。</li><li>类型断言表达式的结果值。</li><li>接收表达式的结果值。</li></ul><p>不可寻址的判断方法</p><ol><li><strong>不可变的</strong>值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。</li><li>绝大多数被视为<strong>临时结果</strong>的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。</li><li>若拿到某值的指针可能会破坏程序的一致性，那么就是<strong>不安全的</strong>，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。</li></ol><p>不可寻址的值使用限制</p><ul><li><p>无法使用取址操作符<code>&</code>获取它们的指针了。 对不可寻址的值施加取址操作都会使编译器报错。</p></li><li><p>Go语言中的<code>++</code>和<code>--</code>并不属于操作符，只要在<code>++</code>或<code>--</code>的左边添加一个表达式，就可以组成一个自增语句或自减语句，这个表达式的结果值必须是可寻址的。</p></li><li><p>特殊情况</p><p><strong>虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。</strong></p><p><strong>在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。</strong></p><p><strong>在带有<code>range</code>子句的<code>for</code>语句中，在<code>range</code>关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。</strong></p></li></ul><h4 id=go语言中的常用表达式有以下几种>Go语言中的常用表达式有以下几种。</h4><ul><li>用于获得某个元素的索引表达式。</li><li>用于获得某个切片（片段）的切片表达式。</li><li>用于访问某个字段的选择表达式。</li><li>用于调用某个函数或方法的调用表达式。</li><li>用于转换值的类型的类型转换表达式。</li><li>用于判断值的类型的类型断言表达式。</li><li>向通道发送元素值或从通道那里接收元素值的接收表达式。</li></ul><h4 id=使用unsafepointer操纵可寻址的值>使用<code>unsafe.Pointer</code>操纵可寻址的值</h4><p>利用<code>unsafe.Pointer</code>的中转和<code>uintptr</code>的底层操作来操纵类型值，它可以绕过Go语言的编译器和其他工具的重重检查，并达到潜入内存修改数据的目的。这并不是一种正常的编程手段，很有可能造成安全隐患。</p><p>我们总是应该优先使用常规代码包中提供的API去编写程序，当然也可以把像<code>reflect</code>以及<code>go/ast</code>这样的代码包作为备选项。作为上层应用的开发者，请谨慎地使用<code>unsafe</code>包中的任何程序实体。</p><p><code>unsafe.Pointer</code>的中转和<code>uintptr</code>的转换规则：</p><ol><li>一个指针值（比如<code>*Dog</code>类型的值）可以被转换为一个<code>unsafe.Pointer</code>类型的值，反之亦然。</li><li>一个<code>uintptr</code>类型的值也可以被转换为一个<code>unsafe.Pointer</code>类型的值，反之亦然。</li><li>一个指针值无法被直接转换成一个<code>uintptr</code>类型的值，反过来也是如此。</li></ol><p>例：</p><pre><code>dog := Dog{&quot;little pig&quot;}
dogP := &amp;dog   //取出了它的指针值
dogPtr := uintptr(unsafe.Pointer(dogP))

namePtr := dogPtr + unsafe.Offsetof(dogP.name)  //起始存储地址 + 偏移量，以字节为单位
nameP := (*string)(unsafe.Pointer(namePtr)) // 转换成*string`类型的值
</code></pre><h3 id=9go语句及其执行规则>9.go语句及其执行规则</h3><p>Go语言编程提倡:不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。</p><blockquote><p>struct{}<code>类型值的表示法只有一个，即：</code>struct{}{}<code>。并且，它占用的内存空间是</code>0`字节。确切地说，这个值在整个Go程序中永远都只会存在一份。虽然我们可以无数次地使用这个值字面量，但是用到的却都是同一个值。</p></blockquote><blockquote><p>关键词: sleep、chan struct{}、<code>sync.WaitGroup</code>、自旋（spinning）</p></blockquote><h4 id=进程线程>进程&线程</h4><p>主线程之外的其他线程都只能由代码显式地创建和销毁。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。系统级线程由Go语言的运行时（runtime）系统帮助我们自动地创建和销毁。</p><p>Go语言不但有着独特的并发编程模型，以及用户级线程goroutine，还拥有强大的用于调度goroutine、对接系统级线程的调度器。这个调度器是Go语言运行时系统的重要组成部分，它主要负责统筹调配Go并发编程模型中的三个主要元素，即：G（goroutine的缩写）、P（processor的缩写）和M（machine的缩写）。</p><p>其中的M指代的就是系统级线程。而P指的是一种可以承载若干个G，且能够使这些G适时地与M进行对接，并得到真正运行的中介。</p><p><img src=./images/16-1.png alt></p><h4 id=goroutine>goroutine</h4><p>主goroutine的<code>go</code>函数就是那个作为程序入口的<code>main</code>函数。</p><p>go<code>函数真正被执行的时间，总会与其所属的</code>go<code>语句被执行的时间不同。当程序执行到一条</code>go`语句的时候，Go语言的运行时系统，会先试图从某个存放空闲的G的队列中获取一个G（也就是goroutine），队列中的G总是会按照先入先出的顺序，它只有在找不到空闲G的情况下才会去创建一个新的G。这也是为什么我总会说“启用”一个goroutine，而不说“创建”一个goroutine的原因。已存在的goroutine总是会被优先复用。</p><blockquote><p><code>byte</code>类型是<code>uint8</code>类型的别名类型</p></blockquote><h3 id=10if语句for语句和switch语句>10.if语句、for语句和switch语句</h3><p>if<code>语句、</code>for<code>语句和</code>switch`语句都属于Go语言的基本流程控制语句。</p><blockquote><p>关键词: 类型<code>switch</code>语句</p></blockquote><h4 id=for-range>for range</h4><pre><code>nums := [...]int{1,2,3,4,5,6}
maxIndex := len(nums) - 1
for i,meta := range nums {
   if i == maxIndex {
       num[0] += meta
   } else {
       number[i+1] += meta
   }
}
fmt.Println(nums)
</code></pre><p>当<code>for</code>语句被执行的时候，在<code>range</code>关键字右边的<code>numbers1</code>会先被求值。<code>range</code>表达式的结果值可以是数组、数组的指针、切片、字符串、字典或者允许接收操作的通道中的某一个，并且结果值只能有一个。</p><p>这里需要注意两点：</p><ol><li><code>range</code>表达式只会在<code>for</code>语句开始执行时被求值一次，无论后边会有多少次迭代；</li><li><code>range</code>表达式的求值结果会被复制，也就是说，被迭代的对象是<code>range</code>表达式结果值的副本而不是原值。</li></ol><h4 id=switch>switch</h4><p>在Go语言中，只有类型相同的值之间才有可能被允许进行判等操作。如果<code>switch</code>表达式的结果值是无类型的常量，比如<code>1 + 3</code>的求值结果就是无类型的常量<code>4</code>，那么这个常量会被自动地转换为此种常量的默认类型的值，比如整数<code>4</code>的默认类型是<code>int</code>，又比如浮点数<code>3.14</code>的默认类型是<code>float64</code>。</p><p><code>switch</code>的<code>case</code>表达式的所有子表达式的结果值都是要与<code>switch</code>表达式的结果值判等的，它们的类型必须相同或者能够都统一到<code>switch</code>表达式的结果类型。</p><p><code>switch</code>语句会进行有限的类型转换，但肯定不能保证这种转换可以统一它们的类型。还要注意，如果这些表达式的结果类型有某个接口类型，那么一定要小心检查它们的动态值是否都具有可比性（或者说是否允许判等操作）,如果不是，虽然不会造成编译错误，但是后果会更加严重：引发panic（也就是运行时恐慌）。</p><p><strong><code>switch</code>语句在<code>case</code>子句的选择上是具有唯一性的。</strong> <code>switch</code>语句不允许<code>case</code>表达式中的子表达式结果值存在相等的情况，不论这些结果值相等的子表达式，是否存在于不同的<code>case</code>表达式中，都会是这样的结果。</p><p><img src=./images/18-1.png alt></p><h3 id=11错误处理>11.错误处理</h3><p><code>error</code>类型其实是一个接口类型，也是一个Go语言的内建类型。</p><blockquote><p>关键词:卫述语句、最小化访问权限</p></blockquote><p>怎样判断一个错误值具体代表的是哪一类错误？</p><ol><li><p>对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型<code>switch</code>语句来判断；</p><p>如：<code>os</code>包中的几个代表错误的类型<code>os.PathError</code>、<code>os.LinkError</code>、<code>os.SyscallError</code>和<code>os/exec.Error</code>来说</p></li><li><p>对于已有相应变量且类型相同的一系列错误值，一般直接使用判等操作来判断；</p></li><li><p>对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来做判断。</p></li></ol><p>Go语言中处理错误的最基本方式，这涉及了函数结果列表设计、<code>errors.New</code>函数、卫述语句以及使用打印函数输出错误值。构建错误值体系的基本方式有两种，即：创建立体的错误类型体系和创建扁平的错误值列表。用类型建立起树形结构的错误体系，用统一字段建立起可追根溯源的链式错误关联。</p><h4 id=panic>panic</h4><p>在大多数操作系统中，只要退出状态码不是<code>0</code>，都意味着程序运行的非正常结束。在Go语言中，因panic导致程序结束运行的退出状态码一般都会是<code>2</code>。panic详情会在控制权传播的过程中，被逐渐地积累和完善，并且，控制权会一级一级地沿着调用栈的反方向传播至顶端。当一个panic发生时，如果我们不施加任何保护措施，那么导致的直接后果就是程序崩溃</p><h4 id=recover>recover</h4><p>Go语言的内建函数<code>recover</code>专用于恢复panic，或者说平息运行时恐慌。<code>recover</code>函数无需任何参数，并且会返回一个空接口类型的值。</p><pre><code>func main() {
 fmt.Println(&quot;Enter function main.&quot;)
 defer func(){
  fmt.Println(&quot;Enter defer function.&quot;)
  if p := recover(); p != nil {
   fmt.Printf(&quot;panic: %s\n&quot;, p)
  }
  fmt.Println(&quot;Exit defer function.&quot;)
 }()
 // 引发panic。
 panic(errors.New(&quot;something wrong&quot;))
 fmt.Println(&quot;Exit function main.&quot;)
}
</code></pre><h4 id=defer>defer</h4><p>当一个函数即将结束执行时，其中的写在最下边的<code>defer</code>函数调用会最先执行，其次是写在它上边、与它的距离最近的那个<code>defer</code>函数调用，以此类推，最上边的<code>defer</code>函数调用会最后一个执行。 同一条<code>defer</code>语句每被执行一次，其中的<code>defer</code>函数调用就会产生一次，而且，这些函数调用同样不会被立即执行。</p><p>在<code>defer</code>语句每次执行的时候，Go语言会把它携带的<code>defer</code>函数及其参数值另行存储到一个链表中。这个链表与该<code>defer</code>语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈。这正是我说“<code>defer</code>函数调用与其所属的<code>defer</code>语句的执行顺序完全相反”的原因了。</p><h2 id=四go语言进阶技术>四：Go语言进阶技术</h2><h3 id=1测试的基本规则和流程>1.测试的基本规则和流程</h3><p>测试源码文件的主名称应该以被测源码文件的主名称为前导，并且必须以“_test”为后缀。例如，demo.go 测试源码文件的名称是demo_test.go。</p><p><strong>Go语言对测试函数的名称和签名都有哪些规定？</strong></p><ul><li>对于功能测试函数来说，其名称必须以<code>Test</code>为前缀，并且参数列表中只应有一个<code>*testing.T</code>类型的参数声明。</li><li>对于性能测试函数来说，其名称必须以<code>Benchmark</code>为前缀，并且唯一参数的类型必须是<code>*testing.B</code>类型的。</li><li>对于示例测试函数来说，其名称必须以<code>Example</code>为前缀，但对函数的参数列表没有强制规定。</li></ul><h4 id=go-test基本规则和主要流程的><code>go test</code>基本规则和主要流程的</h4><p>只有测试源码文件的名称对了，测试函数的名称和签名也对了，当我们运行<code>go test</code>命令的时候，其中的测试代码才有可能被运行。</p><ul><li><p><code>go test</code>命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，以及判断我们给予的标记是否合法，等等。</p></li><li><p>在准备工作顺利完成之后，<code>go test</code>命令就会针对每个被测代码包，依次地进行构建、执行包中符合要求的测试函数，清理临时文件，打印测试结果。这就是通常情况下的主要测试流程。</p><blockquote><p>为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试，只不过，在最后打印测试结果的时候，它会依照我们给定的顺序逐个进行，这会让我们感觉到它是在完全串行地执行测试流程。</p><p>由于并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的。更具体地说，只有在所有构建步骤都做完之后，<code>go test</code>命令才会真正地开始进行性能测试。</p><p>并且，下一个代码包性能测试的进行，总会等到上一个代码包性能测试的结果打印完成才会开始，而且性能测试函数的执行也都会是串行的。</p></blockquote></li></ul><h3 id=2并发同步变成>2.并发同步变成</h3><h4 id=21syncmutex与syncrwmutex>2.1.sync.Mutex与sync.RWMutex</h4><h5 id=共享资源与一致性>共享资源与一致性</h5><p>相比于Go语言宣扬的“用通讯的方式共享数据”，通过共享数据的方式来传递信息和协调线程运行的做法其实更加主流，毕竟大多数的现代编程语言，都是用后一种方式作为并发编程的解决方案的。</p><p>一旦数据被多个线程共享，那么就很可能会产生争用和冲突的情况。这种情况也被称为<strong>竞态条件（race condition）</strong>，这往往会破坏共享数据的一致性。共享数据的一致性代表着某种约定，即：多个线程对共享数据的操作总是可以达到它们各自预期的效果。</p><p><strong>同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。</strong></p><p>由于这样的数据块和代码块的背后都隐含着一种或多种资源（比如存储资源、计算资源、I/O资源、网络资源等等），所以我们可以把它们看做是共享资源，或者说共享资源的代表。我们所说的同步其实就是在控制多个线程对共享资源的访问。</p><h5 id=临界区>临界区</h5><p>多个并发运行的线程对这个共享资源的访问是完全串行的。只要一个代码片段需要实现对共享资源的串行化访问，就可以被视为一个临界区（critical section），也就是说，由于要访问到资源而必须进入的那个区域。</p><p><img src=./images/26-1.png alt></p><h5 id=互斥锁>互斥锁</h5><p><strong>在Go语言中我们最常用的同步工具当属互斥量（mutual exclusion，简称mutex）。</strong><code>sync</code>包中的<code>Mutex</code>就是与其对应的类型，该类型的值可以被称为互斥量或者互斥锁。一个互斥锁可以被用来保护一个临界区或者一组相关临界区。我们可以通过它来保证，在同一时刻只有一个goroutine处于该临界区之内。</p><p>互斥锁可以看作是针对某一个临界区或某一组相关临界区的唯一访问令牌。</p><p>使用互斥锁的注意事项如下：</p><ol><li>不要重复锁定互斥锁；</li><li>不要忘记解锁互斥锁，必要时使用<code>defer</code>语句；</li><li>不要对尚未锁定或者已解锁的互斥锁解锁；</li><li>不要在多个函数之间直接传递互斥锁。</li></ol><blockquote><p>死锁：指的就是当前程序中的主goroutine，以及我们启用的那些goroutine都已经被阻塞。这些goroutine可以被统称为用户级的goroutine。这就相当于整个程序都已经停滞不前了。对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的goroutine的。这个goroutine所执行的流程，会一直停滞在调用该互斥锁的<code>Lock</code>方法的那行代码上。直到该互斥锁的<code>Unlock</code>方法被调用</p><p>我们一定要尽量避免这种情况的发生。而最简单、有效的方式就是让每一个互斥锁都只保护一个临界区或一组相关临界区。在这个前提之下，我们还需要注意，对于同一个goroutine而言，既不要重复锁定一个互斥锁，也不要忘记对它进行解锁。</p></blockquote><h5 id=读写锁>读写锁</h5><p>读写锁是读/写互斥锁的简称。在Go语言中，读写锁由<code>sync.RWMutex</code>类型的值代表。与<code>sync.Mutex</code>类型一样，这个类型也是开箱即用的。</p><p>读写锁是把对共享资源的“读操作”和“写操作”区别对待了。它可以对这两种操作施加不同程度的保护。换句话说，相比于互斥锁，读写锁可以实现更加细腻的访问控制。</p><p>一个读写锁中实际上包含了两个锁，即：读锁和写锁。<code>sync.RWMutex</code>类型中的<code>Lock</code>方法和<code>Unlock</code>方法分别用于对写锁进行锁定和解锁，而它的<code>RLock</code>方法和<code>RUnlock</code>方法则分别用于对读锁进行锁定和解锁。</p><p>另外，对于同一个读写锁来说有如下规则。</p><ol><li>在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的goroutine。</li><li>在写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的goroutine。</li><li>在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的goroutine。</li><li>在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的goroutine。</li></ol><h4 id=22条件变量>2.2.条件变量</h4><p>条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用。</p><p>条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。</p><p><strong>条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。</strong></p><p>条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。</p><pre><code>发送
lock.Lock()
for mailbox == 1 {
 sendCond.Wait()
}
mailbox = 1
lock.Unlock()
recvCond.Signal()

接收
lock.RLock()
for mailbox == 0 {
 recvCond.Wait()
}
mailbox = 0
lock.RUnlock()
sendCond.Signal()
</code></pre><p><img src=./images/27-1.png alt></p><p>条件变量的<code>Wait</code>方法主要做了四件事。</p><ol><li>把调用它的goroutine（也就是当前的goroutine）加入到当前条件变量的通知队列中。</li><li>解锁当前的条件变量基于的那个互斥锁。</li><li>让当前的goroutine处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个goroutine就会阻塞在调用这个<code>Wait</code>方法的那行代码上。</li><li>如果通知到来并且决定唤醒这个goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的goroutine就会继续执行后面的代码了。</li></ol><p>条件变量的<code>Signal</code>方法和<code>Broadcast</code>方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的goroutine，而后者的通知却会唤醒所有为此等待的goroutine。</p><p>条件变量的<code>Wait</code>方法总会把当前的goroutine添加到通知队列的队尾，而它的<code>Signal</code>方法总会从通知队列的队首开始，查找可被唤醒的goroutine。所以，因<code>Signal</code>方法的通知，而被唤醒的goroutine一般都是最早等待的那一个。</p><h4 id=23原子操作>2.3.原子操作</h4><p><strong><code>sync/atomic</code>包中提供了几种原子操作？可操作的数据类型又有哪些？</strong></p><p><code>sync/atomic</code>包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称CAS）、加载（load）、存储（store）和交换（swap）。</p><p>数据类型有：<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>，atomic.Value，以及<code>unsafe</code>包中的<code>Pointer</code>。不过，针对<code>unsafe.Pointer</code>类型，该包并未提供进行原子加法操作的函数。</p><p><strong>原子值使用建议。</strong></p><ol><li>不要把内部使用的原子值暴露给外界。比如，声明一个全局的原子变量并不是一个正确的做法。这个变量的访问权限最起码也应该是包级私有的。</li><li>如果不得不让包外，或模块外的代码使用你的原子值，那么可以声明一个包级私有的原子变量，然后再通过一个或多个公开的函数，让外界间接地使用到它。注意，这种情况下不要把原子值传递到外界，不论是传递原子值本身还是它的指针值。</li><li>如果通过某个函数可以向内部的原子值存储值的话，那么就应该在这个函数中先判断被存储值类型的合法性。若不合法，则应该直接返回对应的错误值，从而避免panic的发生。</li><li>如果可能的话，我们可以把原子值封装到一个数据类型中，比如一个结构体类型。这样，我们既可以通过该类型的方法更加安全地存储值，又可以在该类型中包含可存储值的合法类型信息。</li></ol><p>怎样用好<code>sync/atomic.Value</code></p><ol><li>一旦<code>atomic.Value</code>类型的值（以下简称原子值）被真正使用，它就不应该再被复制了。</li><li>不能用原子值存储<code>nil</code>。也就是说，我们不能把<code>nil</code>作为参数值传入原子值的<code>Store</code>方法，否则就会引发一个panic。</li><li>我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。</li></ol><h4 id=24syncwaitgroup>2.4.sync.WaitGroup</h4><p><code>sync.WaitGroup</code>类型（以下简称<code>WaitGroup</code>类型）是开箱即用的，是并发安全的。它一旦被真正使用就不能被复制了。它拥有三个指针方法：<code>Add</code>、<code>Done</code>和<code>Wait</code>。你可以想象该类型中有一个计数器，它的默认值是<code>0</code>。我们可以通过调用该类型值的<code>Add</code>方法来增加、<code>Done</code>方法减一操作、<code>Wait</code>方法阻塞当前的goroutine，直到其所属值中的计数器归零。</p><p><code>WaitGroup</code>值的使用禁忌，即：<strong>不要把增加其计数器值的操作和调用其<code>Wait</code>方法的代码，放在不同的goroutine中执行。换句话说，要杜绝对同一个<code>WaitGroup</code>值的两种操作的并发执行。</strong></p><p><img src=./images/31-1.png alt></p><h4 id=25synconece>2.5.sync.Onece</h4><p><code>sync.Once</code>类型（以下简称<code>Once</code>类型）也属于结构体类型，是开箱即用和并发安全的。由于这个类型中包含了一个<code>sync.Mutex</code>类型的字段，复制该类型的值也会导致功能的失效。</p><p><code>Once</code>类型的<code>Do</code>方法只接受一个参数，这个参数的类型必须是<code>func()</code>，即：无参数声明和结果声明的函数。该方法的功能是只执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数。</p><p><code>Once</code>类型中还有一个名叫<code>done</code>的<code>uint32</code>类型的字段。它的作用是记录其所属值的<code>Do</code>方法被调用的次数。不过，该字段的值只可能是<code>0</code>或者<code>1</code>。一旦<code>Do</code>方法的首次调用完成，它的值就会从<code>0</code>变为<code>1</code>。</p><p>这个<code>Do</code>方法在功能方面的两个特点</p><p><strong>第一个特点</strong>，由于<code>Do</code>方法只会在参数函数执行结束之后把<code>done</code>字段的值变为<code>1</code>，因此，如果参数函数的执行需要很长时间或者根本就不会结束（比如执行一些守护任务），那么就有可能会导致相关goroutine的同时阻塞。</p><p><strong>第二个特点</strong>，<code>Do</code>方法在参数函数执行结束后，对<code>done</code>字段的赋值用的是原子操作，并且，这一操作是被挂在<code>defer</code>语句中的。因此，不论参数函数的执行会以怎样的方式结束，<code>done</code>字段的值都会变为<code>1</code>。</p><h4 id=26contextcontext>2.6.context.Context</h4><p><code>context.Context</code>类型（以下简称<code>Context</code>类型）是在Go 1.7发布时才被加入到标准库的。而后，标准库中的很多其他代码包都为了支持它而进行了扩展，包括：<code>os/exec</code>包、<code>net</code>包、<code>database/sql</code>包，以runtime/pprof<code>包和</code>runtime/trace`包，等等。</p><p><code>Context</code>类型它是一种非常通用的同步工具。它的值不但可以被任意地扩散，而且还可以被用来传递额外的信息和信号。<code>Context</code>类型可以提供一类代表上下文的值。此类值是并发安全的，也就是说它可以被传播给多个goroutine。</p><p><code>context.Background</code>、<code>context.WithCancel</code>、<code>context.WithDeadline</code>、<code>context.WithTimeout</code>和<code>context.WithValue</code>。</p><p><code>Context</code>类型的实际值大体上分为三种，即：根<code>Context</code>值、可撤销的<code>Context</code>值和含数据的<code>Context</code>值。所有的<code>Context</code>值共同构成了一颗上下文树。这棵树的作用域是全局的，而根<code>Context</code>值就是这棵树的根。它是全局唯一的，并且不提供任何额外的功能。</p><p>可撤销的<code>Context</code>值又分为：只可手动撤销的<code>Context</code>值，和可以定时撤销的<code>Context</code>值。</p><p><img src=./images/32-1.png alt></p><h4 id=27syncpool>2.7.sync.Pool</h4><p><code>sync.Pool</code>类型可以被称为临时对象池，它的值可以被用来存储临时的对象。与Go语言的很多同步工具一样，<code>sync.Pool</code>类型也属于结构体类型，它的值在被真正使用之后，就不应该再被复制了。</p><p>我们可以把临时对象池当作针对某种数据的缓存来用。<code>sync.Pool</code>类型只有两个方法——<code>Put</code>和<code>Get</code>。Put用于在当前的池中存放临时对象，它接受一个<code>interface{}</code>类型的参数；而Get则被用于从当前的池中获取临时对象，它会返回一个<code>interface{}</code>类型的值。</p><p><strong>为什么说临时对象池中的值会被及时地清理掉？</strong></p><p>因为，Go语言运行时系统中的垃圾回收器，在每次开始执行之前，都会对所有已创建的临时对象池中的值进行全面地清除。</p><p><strong>临时对象池存储值所用的数据结构</strong></p><p>在临时对象池中，有一个多层的数据结构。这个数据结构的顶层，我们可以称之为本地池列表，不过更确切地说，它是一个数组。这个列表的长度，总是与Go语言调度器中的P的数量相同，原因是为了分散并发程序的执行压力，这里所说的压力包括了存储和性能两个方面。</p><p>在每个本地池中，都包含一个私有的临时对象和一个共享的临时对象列表。前者只能被其对应的P所关联的那个goroutine中的代码访问到，而后者却没有这个约束。从另一个角度讲，前者用于临时对象的快速存取，而后者则用于临时对象的池内共享。</p><p><img src=./images/33-1.png alt></p><p><strong>从sync.Pool中获取临时对象的步骤</strong></p><p><img src=./images/33-2.png alt></p><h4 id=28syncmap>2.8.sync.Map</h4><p>Go语言官方终于在2017年发布的Go 1.9中，正式加入了并发安全的字典类型<code>sync.Map</code>。这个字典类型提供了一些常用的键值存取操作方法，并保证了这些操作的并发安全。它们的算法复杂度与<code>map</code>类型一样都是<code>O(1)</code>的。</p><p>使用锁就意味着要把一些并发的操作强制串行化。这往往会降低程序的性能，尤其是在计算机拥有多个CPU核心的情况下。因此，能用原子操作就不要用锁，不过这很有局限性，毕竟原子只能对一些基本的数据类型提供支持。</p><p><strong>并发安全字典对键的类型有要求吗？</strong></p><p>有要求。键的实际类型不能是函数类型、字典类型和切片类型。我们必须保证键的类型是可比较的（或者说可判等的）。我们可以先通过调用<code>reflect.TypeOf</code>函数得到一个键值对应的反射类型值（即：<code>reflect.Type</code>类型的值），然后再调用这个值的<code>Comparable</code>方法，得到确切的判断结果。</p><p><strong>保证并发安全字典中的键和值的类型正确性</strong></p><ul><li><p>方案一，在编码时就完全确定键和值的类型，然后利用Go语言的编译器帮我们做检查。</p><pre><code>type IntStrMap struct {
 m sync.Map
}
</code></pre></li><li><p>方案二，接受动态的类型设置，并在程序运行的时候通过反射操作进行检查。</p><pre><code>type ConcurrentMap struct {
 m         sync.Map
 keyType   reflect.Type
 valueType reflect.Type
}
</code></pre></li></ul><p><strong>并发安全字典如何做到尽量避免使用锁？</strong></p><p><code>sync.Map</code>类型在内部使用了大量的原子操作来存取键和值，并使用了两个原生的<code>map</code>作为存储介质。</p><p><strong>其中一个原生<code>map</code>被存在了<code>sync.Map</code>的<code>read</code>字段中，该字段是<code>sync/atomic.Value</code>类型的。</strong> 这个原生字典可以被看作一个快照，它总会在条件满足时，去重新保存所属的<code>sync.Map</code>值中包含的所有键值对。</p><p><strong>另一个原生字典由它的<code>dirty</code>字段代表。</strong> 它存储键值对的方式与<code>read</code>字段中的原生字典一致，它的键类型也是<code>interface{}</code>，并且同样是把值先做转换和封装后再进行储存的。我们暂且把它称为脏字典。</p><blockquote><p>注意，脏字典和只读字典如果都存有同一个键值对，那么这里的两个键指的肯定是同一个基本值，对于两个值来说也是如此。</p></blockquote><p>**只读字典和脏字典之间是会互相转换的。**在脏字典中查找键值对次数足够多的时候，<code>sync.Map</code>会把脏字典直接作为只读字典，保存在它的<code>read</code>字段中，然后把代表脏字典的<code>dirty</code>字段的值置为<code>nil</code>。在这之后，一旦再有新的键值对存入，它就会依据只读字典去重建脏字典。这个时候，它会把只读字典中已被逻辑删除的键值对过滤掉。</p><p><img src=./images/35-1.png alt></p><h3 id=9unicode与字符编码>9.unicode与字符编码</h3><h3 id=10strings包与字符串操作>10.strings包与字符串操作</h3><h3 id=11bytes包与字节串操作>11.bytes包与字节串操作</h3><h3 id=12io包中的接口和工具>12.io包中的接口和工具</h3><h3 id=13bufio包中的数据类型>13.bufio包中的数据类型</h3><h3 id=14使用os包中的api>14.使用os包中的API</h3><h3 id=15访问网络服务>15.访问网络服务</h3><h3 id=16基于http协议的网络服务>16.基于HTTP协议的网络服务</h3><h3 id=17程序性能分析基础>17.程序性能分析基础</h3><h2 id=五附录>五：附录</h2><h3 id=1go命令>1.go命令</h3><h4 id=go-get><code>go get</code></h4><p>命令<code>go get</code>会自动从一些主流公用代码仓库（比如GitHub）下载目标代码包，并把它们安装到环境变量<code>GOPATH</code>包含的第1工作区的相应目录中。如果存在环境变量<code>GOBIN</code>，那么仅包含命令源码文件的代码包会被安装到<code>GOBIN</code>指向的那个目录。</p><p>最常用的几个标记有下面几种。</p><ul><li><code>-u</code>：下载并安装代码包，不论工作区中是否已存在它们。</li><li><code>-d</code>：只下载代码包，不安装代码包。</li><li><code>-fix</code>：在下载代码包后先运行一个用于根据当前Go语言版本修正代码的工具，然后再安装代码包。</li><li><code>-t</code>：同时下载测试所需的代码包。</li><li><code>-insecure</code>：允许通过非安全的网络协议下载和安装代码包。HTTP就是这样的协议。</li></ul><h4 id=go-build><code>go build</code></h4><p>默认不会编译目标代码包所依赖的那些代码包。当然，如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。</p><p>-a 强制编译,不但目标代码包总是会被编译，它依赖的代码包也总会被编译</p><p>-i 不但要编译依赖的代码包，还要安装它们的归档文件</p><p>-v 可以看到<code>go build</code>命令编译的代码包的名称</p><p>-x 这样可以看到<code>go build</code>命令具体都执行了哪些操作</p><p>-n 可以只查看具体操作而不执行它们</p><h4 id=go-install><code>go install</code></h4><h3 id=1go基础知识>1.go基础知识</h3><p><img src=./images/dt.jpg alt></p><h3 id=2github优秀项目导图>2.github优秀项目导图</h3><p>【clash】https://github.com/Dreamacro/clash</p><p><img src=./images/goproject.jpg alt></p><h3 id=3问题记录>3.问题记录</h3><h4 id=1main-file-has-non-main-package-or-doesnt-contain-main-function>1）Main file has non-main package or doesn&rsquo;t contain main function</h4><p>如果为程序入口的main方法文件，则包应为package main,注意与目录无关。</p><footer><section class=categories-tags><span><svg class="icon icon-folder"><use xlink:href="#icon-folder"/></svg><span class=screen-reader-text>This entry was posted in</span>
<a href=/categories/%E5%90%8E%E7%AB%AF>后端</a></span> <span><svg class="icon icon-tag"><use xlink:href="#icon-tag"/></svg><a class=article-tags href=/tags/go>GO</a></span></section></footer><div id=comments-button-container class=comments-button-container><button type=button onclick=loadDisqus() class=comments-button><svg class="icon icon-bubble"><use xlink:href="#icon-bubble"/></svg> <span>Show Comments</span></button></div><div id=disqus_thread></div><script type=text/javascript>function loadDisqus(){var a,b;document.getElementById('comments-button-container').style.display='none',a=document.createElement('script'),a.type='text/javascript',a.async=!0,b='李明梓',a.src='//'+b+'.disqus.com/embed.js',(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(a)}</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><aside id=sidebar><div class=widget><div class=widget-title>Recent posts</div><ol class="recent-widget widget-content"><li><a href=/go-sdk/>GO SDK</a></li><li><a href=/jemeter%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/>jemeter基本使用</a></li><li><a href=/%E5%A4%A7%E9%A3%8E%E6%AD%8C%E7%8E%8B%E7%AB%8B%E7%BE%A4/>&lt;&lt;大风歌>>王立群</a></li><li><a href=/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/>位运算基础知识</a></li><li><a href=/canal-mysql-binlog%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90/>canal-mysql binlog日志解析</a></li></ol></div><div class=widget><div class=widget-title>Categories</div><ol class="all-categories widget-content"><li><a href=/categories/devops>devops</a> (1)</li><li><a href=/categories/java>java</a> (4)</li><li><a href=/categories/mysql>mysql</a> (1)</li><li><a href=/categories/%E5%85%B6%E4%BB%96>其他</a> (4)</li><li><a href=/categories/%E5%89%8D%E7%AB%AF>前端</a> (1)</li><li><a href=/categories/%E5%90%8E%E7%AB%AF>后端</a> (4)</li><li><a href=/categories/%E5%9F%BA%E7%A1%80>基础</a> (1)</li><li><a href=/categories/%E5%B7%A5%E5%85%B7>工具</a> (3)</li></ol></div><div class=widget><div class=widget-title>Tags</div><div class="tag-cloud-tags widget-content"><a href=/tags/canal aria-label="canal (2 posts)" style=font-size:1rem>canal</a>
<a href=/tags/git aria-label="git (1 posts)" style=font-size:1rem>git</a>
<a href=/tags/go aria-label="go (4 posts)" style=font-size:1rem>go</a>
<a href=/tags/hexo aria-label="hexo (1 posts)" style=font-size:1rem>hexo</a>
<a href=/tags/java aria-label="java (1 posts)" style=font-size:1rem>java</a>
<a href=/tags/maven aria-label="maven (1 posts)" style=font-size:1rem>maven</a>
<a href=/tags/mysql aria-label="mysql (1 posts)" style=font-size:1rem>mysql</a>
<a href=/tags/yarn aria-label="yarn (1 posts)" style=font-size:1rem>yarn</a>
<a href=/tags/zabbix aria-label="zabbix (1 posts)" style=font-size:1rem>zabbix</a>
<a href=/tags/%E5%9F%BA%E7%A1%80 aria-label="基础 (1 posts)" style=font-size:1rem>基础</a>
<a href=/tags/%E5%B7%A5%E5%85%B7 aria-label="工具 (2 posts)" style=font-size:1rem>工具</a>
<a href=/tags/%E8%BD%AF%E6%96%87%E6%94%B6%E9%9B%86 aria-label="软文收集 (2 posts)" style=font-size:1rem>软文收集</a></div></div></aside></div></div><svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><symbol id="icon-github" viewBox="0 0 32 32"><path d="M16 .395c-8.836.0-16 7.163-16 16 0 7.069 4.585 13.067 10.942 15.182.8.148 1.094-.347 1.094-.77.0-.381-.015-1.642-.022-2.979-4.452.968-5.391-1.888-5.391-1.888-.728-1.849-1.776-2.341-1.776-2.341-1.452-.993.11-.973.11-.973 1.606.113 2.452 1.649 2.452 1.649 1.427 2.446 3.743 1.739 4.656 1.33.143-1.034.558-1.74 1.016-2.14-3.554-.404-7.29-1.777-7.29-7.907.0-1.747.625-3.174 1.649-4.295-.166-.403-.714-2.03.155-4.234.0.0 1.344-.43 4.401 1.64 1.276-.355 2.645-.532 4.005-.539 1.359.006 2.729.184 4.008.539 3.054-2.07 4.395-1.64 4.395-1.64.871 2.204.323 3.831.157 4.234 1.026 1.12 1.647 2.548 1.647 4.295.0 6.145-3.743 7.498-7.306 7.895.574.497 1.085 1.47 1.085 2.963.0 2.141-.019 3.864-.019 4.391.0.426.288.925 1.099.768C27.421 29.457 32 23.462 32 16.395c0-8.837-7.164-16-16-16z"/></symbol><symbol id="icon-arrow-with-circle-up" viewBox="0 0 32 32"><path d="M16 .64C7.515.64.638 7.517.638 16c0 8.485 6.877 15.362 15.362 15.362 8.482.0 15.36-6.877 15.36-15.362.0-8.483-6.878-15.36-15.36-15.36zM15.998 28.16c-6.715.0-12.16-5.443-12.16-12.16S9.281 3.84 15.998 3.84 28.16 9.285 28.16 16s-5.446 12.16-12.162 12.16zM16 8.8l7.2 7.2h-4v6.4h-6.4V16h-4L16 8.8z"/></symbol></defs></svg><footer id=page-footer><div class=footer-content><a href=https://github.com/qiaomingzi/limz-blog-hugo target=_blank rel=noopener title="Source Code for this Blog"><div class=footer-text><svg class="icon icon-github"><use xlink:href="#icon-github"/></svg>Blog code</div></a><a href=#page-wrapper title="Go to top" id=go-to-top-link><div class=footer-text>To top<svg class="icon icon-arrow-with-circle-up"><use xlink:href="#icon-arrow-with-circle-up"/></svg></div></a><script>document.getElementById("go-to-top-link").onclick=function(){return window.scroll(0,0),!1}</script></div></footer></div><div id=lightbox-container :class="{'open': lightbox.isOpen, 'close': !lightbox.isOpen}"><button type=button aria-label="Close image modal" class=modal-close-button @click=lightbox.close()><svg class="icon icon-circle-with-cross"><use xlink:href="#icon-circle-with-cross"/></svg>
(ESC)</button><div id=lightbox-loading-container x-ref=lightboxLoadingContainer x-show=lightbox.showLoading><div id=lightbox-loading><div aria-busy=true aria-label="Loading, please wait." role=progressbar class=spinner @click=lightbox.cancel() @click.away=lightbox.cancel()></div></div></div><div id=lightbox x-ref=lightbox :class="{'open': lightbox.openImage, 'close': !lightbox.openImage}" @click=lightbox.close()></div></div><div id=code-container :class="{'open': code.isOpening, 'close': !code.isOpening}"><button class=modal-close-button><svg class="icon icon-circle-with-cross"><use xlink:href="#icon-circle-with-cross"/></svg>
(ESC)</button><div id=code-container-inner class=close :class="{'open': code.isOpening, 'close': !code.isOpening}"><div class=box-shadow-container @click.away=code.close()><div id=code-placeholder></div></div></div></div><div id=searchbox-container :class="{'open': search.isOpen}" x-show=search.isOpen x-on:keydown.escape="$nextTick(() => $refs.searchMenuLink.focus())"><button type=button aria-label="Close search modal" class=modal-close-button @click="search.close();$nextTick(() => $refs.searchMenuLink.focus())"><svg class="icon icon-circle-with-cross"><use xlink:href="#icon-circle-with-cross"/></svg>
(ESC)</button><div id=searchbox :class="{'open': search.isOpen}"><svg class="icon icon-search"><use xlink:href="#icon-search"/></svg><label for=search-input class=sr-only>Searchbox</label>
<input id=search-input type=search placeholder=Search... class=search-input x-ref=searchInput autocomplete=off autocorrect=off autocapitalize=off spellcheck=false x-model=search.textInSearchBox x-on:input=search.searchBoxChanged($event.target.value) x-on:keydown.enter="search.focusFirstAnchor($event, $refs.hits)" x-on:keydown.arrow-down="search.focusFirstAnchor($event, $refs.hits)"><svg class="icon icon-circle-with-cross close-search" role="button" aria-label="Close search" @click="search.close();$nextTick(() => $refs.searchMenuLink.focus())"><use xlink:href="#icon-circle-with-cross"/></svg></div><div class=search-results-container><div id=search-output x-show=search.textInSearchBox><div id=no-results-message x-show="search.store && search.textInSearchBox && !search.hits.length">No matching posts found. You can use wildcards and search only in titles, e.g. <code>title:iot</code></div><div id=index-loading-message x-show="!search.indexLoadFailed && search.indexLoading && search.textInSearchBox"><span class=icon-spinner aria-hidden=true></span>Loading search index, please wait...</div><div id=index-failed-message x-show="search.indexLoadFailed && search.textInSearchBox">Search index failed to download 😢</div><div id=number-of-hits-message x-text=search.getHitsText() x-show=search.hits.length></div><ol class=result-list x-show=search.hits.length x-ref=hits><template x-for="hit in search.hits" :key=hit.ref><li><h2><a :href=hit.ref x-text=search.fromStore(hit).title></a></h2><div class=entry-meta><time class=published :datetime=search.fromStore(hit).dateiso><svg class="icon icon-calendar"><use xlink:href="#icon-calendar"/></svg><span x-text=search.fromStore(hit).dateformatted></span></time></div><p x-text=search.fromStore(hit).summary></p></li></template></ol></div></div></div><script src=/bundle.326b2331e4a76c824b17b8d379095b25394912a8f7f1c8a6162a06f763a2caabe6226dee31773ec698c47b06f1de9bb7133091e9260d4d95b4011c7351300442.js integrity="sha512-MmsjMeSnbIJLF7jTeQlbJTlJEqj38cimFioG92OiyqvmIm3uMXc+xpjEewbx3pu3EzCR6SYNTZW0ARxzUTAEQg=="></script></body></html>